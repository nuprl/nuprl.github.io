<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">PRL Blog: PRL Blog</title>
 <link rel="self" href="http://prl.ccs.neu.edu/blog/feeds/all.atom.xml" />
 <link href="http://prl.ccs.neu.edu/blog/index.html" />
 <id>urn:http-prl-ccs-neu-edu:-blog-index-html</id>
 <updated>2019-05-11T00:03:16Z</updated>
 <entry>
  <title type="text">[Conversational Concurrency (cross-post)](https://eighty-twenty.org/2018/01/24/conversational-concurrency)</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/05/11/-conversational-concurrency-cross-post-https-eighty-twenty-org-2018-01-24-conversational-concurrency/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-05-11-conversational-concurrency-cross-post-https-eighty-twenty-org-2018-01-24-conversational-concurrency</id>
  <published>2019-05-11T00:03:16Z</published>
  <updated>2019-05-11T00:03:16Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html"></content></entry>
 <entry>
  <title type="text">Forgetful and Heedful contracts</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/04/07/forgetful-and-heedful-contracts/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-04-07-forgetful-and-heedful-contracts</id>
  <published>2019-04-07T23:15:11Z</published>
  <updated>2019-04-07T23:15:11Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;&lt;em&gt;Forgetful&lt;/em&gt; and &lt;em&gt;heedful&lt;/em&gt; are two methods for space-efficient contracts  developed by &lt;a href="http://www.cs.pomona.edu/~michael/"&gt;Michael Greenberg&lt;/a&gt; in &lt;a href="https://arxiv.org/abs/1410.2813"&gt;2014&lt;/a&gt;. These methods were born in the shadow of a third method, &lt;em&gt;eidetic&lt;/em&gt;,  with stronger theoretic properties. Since then, however, the forgetful method has been re-invented at least twice. Both deserve a second look.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;p&gt;Contracts are a tool for specifying and dynamically-enforcing the behavior  of a program. In a language with contracts, a programmer can annotate an API with  code that documents the intended use for other readers. When client code interacts with such an API, the annotations ensure that the  actual behavior matches the expected. If there is a mismatch, the contract annotations can report an issue  in terms of &lt;a href="https://www2.ccs.neu.edu/racket/pubs/popl11-dfff.pdf"&gt;three parties&lt;/a&gt;:  the API code, the client code, and the contract between them.&lt;/p&gt;

&lt;p&gt;For example, a Racket module that exports a sorting function can use a contract  to describe the kind of input it expects. If a client module sends invalid input, the contract blames the client  module for the error, assuming that the contract is bug-free:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #lang racket/base

  (module sort racket
    (provide
      (contract-out
        [quicksort
          (-&amp;gt; (vectorof point/c) void?)]))

    (define point/c (vectorof integer?))

    (define (quicksort points)
      ....))

  (module client racket
    (require (submod ".." sort))
    (quicksort '()))

  (require 'client)&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;quicksort: contract violation;
 expected a vector
  given: '()
  in: the 1st argument of
      (-&amp;gt; (vectorof (vectorof integer?)) void?)
  contract from: 
      (file.rkt sort)
  blaming: (file.rkt client)
   (assuming the contract is correct)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That covers the basics. For an extended introduction to contracts, visit  &lt;a href="https://docs.racket-lang.org/guide/contracts.html"&gt;The Racket Guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The quicksort example and the related figures are from the paper  &lt;a href="http://users.cs.northwestern.edu/~robby/pubs/papers/oopsla2018-fgsfs.pdf"&gt;&lt;em&gt;Collapsible Contracts: Fixing a Pathology of Gradual Typing&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="classic-contracts-and-space-efficiency"&gt;Classic contracts and &amp;ldquo;Space Efficiency&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;(vectorof point/c)&lt;/code&gt; contract used above describes a possibly-mutable  array whose elements match the &lt;code&gt;point/c&lt;/code&gt; contract. Since the array can be mutated, this contract has implications for two parties:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;the client module must supply a good array, and&lt;/li&gt;
 &lt;li&gt;the sorting module must not insert a bad element.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;To enforce the second condition, the &lt;code&gt;vectorof&lt;/code&gt; contract wraps incoming  vectors in a proxy that checks future writes. Suppose the client sends a vector with four points:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(quicksort (vector (vector 4 4)
                   (vector 2 2)
                   (vector 1 1)
                   (vector 3 3)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After applying the contract, the vector is wrapped in a proxy that checks  incoming writes and outgoing reads. The following picture illustrates the wrapper with a &lt;strong&gt;solid&lt;/strong&gt; blue bar  for the &lt;strong&gt;write&lt;/strong&gt; checks against the sort module and a &lt;em&gt;striped&lt;/em&gt; blue bar  for the &lt;em&gt;read&lt;/em&gt; checks against the client.&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/vector-chaperone-0.png" alt="A wrapped vector" /&gt;&lt;/p&gt;

&lt;p&gt;In a straightforward implementation, these wrappers can stack up if multiple  contracts are applied to the same value. For our quicksort in particular, the elements of the vector are mutable  vectors and may accumulate wrappers as the vector is sorted &amp;mdash;  because every &lt;strong&gt;write&lt;/strong&gt; and &lt;em&gt;read&lt;/em&gt; applies a contract to the element.&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/vector-chaperone-1.png" alt="Layers of element wrappers" /&gt;&lt;/p&gt;

&lt;p&gt;On the bright side, these wrappers enforce the contracts and help the  programmer understand the source of the error if any contract is violated.&lt;/p&gt;

&lt;p&gt;Unfortunately, the wrappers also affect the performance of the program. There are prices to pay for:  (1) checking values against the contracts,  (2) allocating new wrappers,  (3) and &amp;ldquo;indirecting&amp;rdquo; future writes/reads through wrappers. These space and time costs can add up.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;on a randomly ordered vector of 1,000 points, a call to quicksort can wrap the inner vectors an average of 21 times&amp;rdquo; &amp;mdash; &lt;a href="http://users.cs.northwestern.edu/~robby/pubs/papers/oopsla2018-fgsfs.pdf"&gt;&lt;em&gt;Collapsible Contracts&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;To fix the problem, researchers have been exploring &lt;em&gt;space-efficient&lt;/em&gt;  implementations of contracts that attach a bounded number of wrappers to any  value. Michael Greenberg is one of these researchers, and &lt;em&gt;eidetic&lt;/em&gt;, &lt;em&gt;forgetful&lt;/em&gt;,  and &lt;em&gt;heedful&lt;/em&gt; are his names for three implementations.&lt;/p&gt;

&lt;p&gt;(Although the goal of this post is to promote &lt;em&gt;forgetful&lt;/em&gt; and &lt;em&gt;heedful&lt;/em&gt;,  we will review all three.)&lt;/p&gt;

&lt;h3 id="eidetic-space-efficiency"&gt;Eidetic space-efficiency&lt;/h3&gt;

&lt;p&gt;The eidetic method introduces a data structure to represent higher-order  contracts. The structure supports a &lt;em&gt;merge&lt;/em&gt; operation;  when two contracts meet, they are merged in a way that avoids duplication. Eidetic contracts have the same behavior as normal &amp;ldquo;wrapping&amp;rdquo; contracts  and their size is bounded by the number (and height) of source-code  contracts in the program.&lt;/p&gt;

&lt;p&gt;An eidetic contract is an &lt;code&gt;N&lt;/code&gt;-ary tree (for &lt;code&gt;N &amp;gt; 0&lt;/code&gt;):&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;each node represents a higher-order contract combinator, such as &lt;code&gt;vectorof&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;the &lt;code&gt;N&lt;/code&gt; children of a node represent the different interactions that the  value supports&lt;/li&gt;
 &lt;li&gt;each leaf is a list of non-higher-order, or &lt;em&gt;flat&lt;/em&gt;, contracts&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;For example, the &lt;code&gt;(vectorof point/c)&lt;/code&gt; source-code contract describes an  eidetic tree with 3 nodes and 4 singleton-list leaves. Section 3.1 of the &lt;a href="http://users.cs.northwestern.edu/~robby/pubs/papers/oopsla2018-fgsfs.pdf"&gt;Collapsible Contracts&lt;/a&gt; paper has an illustration. Each tree node represents a &lt;code&gt;vectorof&lt;/code&gt; contract;  these nodes have &lt;code&gt;N=2&lt;/code&gt; children because vectors support reads and writes.&lt;/p&gt;

&lt;p&gt;A successful merge combines two trees of the same shape  by re-using half the nodes  and appending the leaf lists. Re-using nodes saves some space, and helps reduce the overhead of trees  relative to simple wrapping contracts. The main savings comes from filtering the leaf lists &amp;mdash; if an  implementation comes with a &lt;code&gt;contract-stronger?&lt;/code&gt; predicate that tests  whether one flat contract accepts fewer values than a second, then it  can remove leaf-list contracts that are preceded by stronger ones. Trees make this filtering possible.&lt;/p&gt;

&lt;p&gt;Suffice to say, eidetic is an ideal solution in theory but comes with  practical challenges. Are trees more expensive than wrappers in the common case? Can the leaf-lists in a tree share elements? Should &lt;code&gt;contract-stronger?&lt;/code&gt; try to solve problems that lack polynomial-time  solutions?&lt;/p&gt;

&lt;p&gt;Thankfully, there are at least two &amp;ldquo;compromise&amp;rdquo; alternatives.&lt;/p&gt;

&lt;h3 id="forgetful-space-efficiency"&gt;Forgetful space-efficiency&lt;/h3&gt;
&lt;!-- "no operation relies on e being a T2, skipping the check doesn't risk soundness" p.12--&gt;
&lt;!-- "In forgetful \lambda_H, we offer a simple solution to space inefficient casts: just forget about them" p.11--&gt;
&lt;!-- "Just the same, when accumulating casts on the stack, we throw away all but the last cast" p.11--&gt;
&lt;!-- "forgetful ... skip[s] checks and change[s] blame labels" p.3--&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;Forgetful is an interesting middle ground: if contracts exist to make partial operations safe (and not abstraction or information hiding), forgetfulness may be a good strategy.&amp;rdquo; &amp;mdash; &lt;a href="https://arxiv.org/abs/1410.2813"&gt;&lt;em&gt;Space-Efficient Manifest Contracts&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- Section 10, bottom of page 23--&gt;&lt;/blockquote&gt;

&lt;p&gt;The forgetful method is exceptionally simple. When applying a new contract to a value, first check whether it is  wrapped in a similar contract. If so, then replace the existing wrapper with one that combines:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;the client obligations from the old contract, and&lt;/li&gt;
 &lt;li&gt;the server obligations from the new contract&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;If not, proceed as usual &amp;mdash; by wrapping (an unwrapped value)  or raising an error. Every value receives at most &lt;strong&gt;one&lt;/strong&gt; wrapper;  this wrapper changes as the value flows to different clients.&lt;/p&gt;

&lt;p&gt;Forgetful is safe in the sense that every piece of code can trust the  top-level shape of the values it receives. Suppose module &lt;code&gt;A&lt;/code&gt; exports a function &lt;code&gt;f&lt;/code&gt; with contract &lt;code&gt;(-&amp;gt; T1 T2)&lt;/code&gt; to  module &lt;code&gt;B&lt;/code&gt;, and suppose module &lt;code&gt;B&lt;/code&gt; shares this function with a few other  client modules using different contracts. As &lt;code&gt;f&lt;/code&gt; flows to a new client, it keeps the &lt;code&gt;T1&lt;/code&gt; domain check and gets a  replacement for the &lt;code&gt;T2&lt;/code&gt; codomain check.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Keeping &lt;code&gt;T1&lt;/code&gt; ensures that the code inside the function  (defined by module &lt;code&gt;A&lt;/code&gt;) receives input that matches its expectation.&lt;/li&gt;
 &lt;li&gt;Replacing &lt;code&gt;T2&lt;/code&gt; ensures that each new client receives output that it expects.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Unfortunately, replacing &lt;code&gt;T2&lt;/code&gt; also means that clients of module &lt;code&gt;B&lt;/code&gt; cannot  trust the &lt;code&gt;T2&lt;/code&gt; contract. This contract is not checked, and so forgetful contracts &lt;strong&gt;miss&lt;/strong&gt; some  errors that would be caught by standard contracts. For the same reason, a bug in module &lt;code&gt;B&lt;/code&gt; may go undetected by its clients  &amp;mdash; even if a later contract reports an issue, the contract system has  no memory that &lt;code&gt;B&lt;/code&gt; was partly-responsible.&lt;/p&gt;

&lt;p&gt;Despite these changes in behavior, forgetful is a straightforward  method for saving space and time relative to classic contracts.&lt;/p&gt;

&lt;h3 id="heedful-space-efficiency"&gt;Heedful space-efficiency&lt;/h3&gt;

&lt;p&gt;A heedful contract is a set of classic higher-order contracts. When applying a new contract to a value, check whether the new contract  is in the set. If so, ignore the new contract. If not, add the new contract to the set &amp;mdash; or raise an error. Every value gets at most one set-wrapper, and each member of a set-wrapper  represents a new constraint.&lt;/p&gt;

&lt;p&gt;To check a value against a set, for example when reading from a vector, check  each of the elements in any order. If an element raises an error, report it.* Alternatively, an implementation can check all the elements and report  all that disagree with the value.&lt;/p&gt;

&lt;p&gt;The heedful method is a compromise between forgetful and eidetic.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Unlike forgetful, heedful uses a new data structure to represent contacts  and requires some kind of &lt;code&gt;contract-stronger?&lt;/code&gt; predicate.  Heedful also remembers (some of) the history of a value and catches the  same errors as classic and eidetic contracts.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Unlike eidetic, heedful uses a simpler data structure with  no need to keep duplicate flat contracts  depending on the order they are encountered.  Heedful cannot, however, uniquely identify the two parties involved in a  contract error.  In general, there are multiple contracts that a programmer  must inspect to find the source of a mismatch.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;For details, see &lt;a href="https://arxiv.org/abs/1410.2813"&gt;the extended version&lt;/a&gt;  of Michael&amp;rsquo;s POPL 2015 paper. Don&amp;rsquo;t bother searching &lt;a href="http://www.cs.pomona.edu/~michael/papers/popl2015_space.pdf"&gt;the conference version&lt;/a&gt;  &amp;mdash; aside from one remark  in Appendix B, heedful and forgetful are nowhere to be found.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt; If an implementation promises to report one mismatch, instead of all  mismatches, then it does not need to keep the full set of contracts. Thanks to &lt;a href="http://mballantyne.net/"&gt;Michael Ballantyne&lt;/a&gt; for explaining  this to me.&lt;/p&gt;

&lt;h3 id="priorities-and-appearances"&gt;Priorities and Appearances&lt;/h3&gt;

&lt;p&gt;The extended version of &lt;em&gt;Space-Efficient Manifest Contracts&lt;/em&gt; introduces  the forgetful and heedful methods with extreme modesty. It&amp;rsquo;s tempting to skip past them and focus on the eidetic method.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;Since eidetic and classic contracts behave the same, why bother with forgetful and heedful? First and foremost, the calculi offer insights into the semantics of contracts: the soundness of forgetful depends on a certain philosophy of contracts; heedful relates to threesomes without blame [&lt;a href="https://dl.acm.org/citation.cfm?doid=1706299.1706342"&gt;Siek and Wadler 2010&lt;/a&gt;]. Second, we offer them as alternative points in the design space. Finally and perhaps cynically, they are strawmen&amp;mdash;warm up exercises for eidetic.&amp;rdquo; &amp;mdash; &lt;a href="https://arxiv.org/abs/1410.2813"&gt;&lt;em&gt;Space-Efficient Manifest Contracts&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- Section 1, bottom of page 2--&gt;&lt;/blockquote&gt;

&lt;p&gt;And yet, at least two other research papers rely on these &amp;ldquo;strawmen&amp;rdquo; &amp;mdash; or  rather, the ideas behind the names.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://dl.acm.org/citation.cfm?id=3110285"&gt;&lt;em&gt;Gradual Typing with Union and Intersection Types&lt;/em&gt;&lt;/a&gt;,  at ICFP 2017,  demonstrates one technique for adding two varieties of types to a gradual  language. The semantics in the paper is forgetful;  if a higher-order value crosses multiple type boundaries,  the intermediate server obligations disappear.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;if a lambda abstraction is preceded by multiple casts, then the rule erases all of them, except for the last one&amp;rdquo; &amp;mdash; &lt;a href="https://dl.acm.org/citation.cfm?id=3110285"&gt;&lt;em&gt;Gradual Typing with Union and Intersection Types&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- page 21--&gt;&lt;/blockquote&gt;

&lt;p&gt;This forgetfulness was a deliberate choice. A classic semantics would satisfy the same type soundness theorem,  but the authors picked forgetful for its simplicity and performance  implications.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;removing these casts preserves the soundness of the evaluation while reducing the number of them&amp;rdquo;&lt;/p&gt;
 &lt;p&gt;&amp;ldquo;while this choice makes the calculus simpler without hindering soundness, it yields a formalism unfit to finger culprits&amp;rdquo; &amp;mdash; &lt;a href="https://dl.acm.org/citation.cfm?id=3110285"&gt;&lt;em&gt;Gradual Typing with Union and Intersection Types&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- p.27--&gt;&lt;!-- page 21--&gt;&lt;/blockquote&gt;
&lt;!-- The followup at POPL 2019 is not forgetful.--&gt;
&lt;!-- It's similar to eager coercions ... keep all types around and error--&gt;
&lt;!--  if there's a new type that doesn't match the old ones.--&gt;
&lt;!-- Also, that paper chooses not to let functions have intersection types,--&gt;
&lt;!--  which kind-of-avoids the questions ... but really the eagerness is key.--&gt;

&lt;p&gt;&lt;a href="https://dl.acm.org/citation.cfm?id=3009849"&gt;&lt;em&gt;Big Types in Little Runtime&lt;/em&gt;&lt;/a&gt;, at POPL 2017,  presents a gradual typing system that avoids the use of wrappers. Instead, their &lt;em&gt;transient&lt;/em&gt; semantics rewrites typed code ahead of time  to mimic the checks that forgetful contracts would perform. These checks suffice for a shallow type soundness theorem.&lt;/p&gt;

&lt;p&gt;That paper also introduces a heedful-like strategy for improving the error  messages produced by a forgetful check. The strategy adds a global map to the semantics;  keys in the map are unique identifiers for values (heap addresses),  and values are sets of types. When a value meets a compatible type, the type is added to the value&amp;rsquo;s set. When a mismatch occurs, the semantics &lt;a href="https://www.ccs.neu.edu/home/types/resources/notes/transient-undefined-blame-extract.pdf"&gt;tries to report&lt;/a&gt;  every type in the set that relates to the mismatch.&lt;/p&gt;

&lt;p&gt;And so, forgetful and heedful were edged out of POPL 2015 but managed to sneak in  to POPL 2017. Since then, forgetful appeared in ICFP 2017 and, briefly, in  &lt;a href="https://www2.ccs.neu.edu/racket/pubs/icfp18-gf.pdf"&gt;ICFP 2018&lt;/a&gt;. Where will we see them next?&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">PLISS: Learn About PL Implementation in a Castle</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/03/09/pliss-learn-about-pl-implementation-in-a-castle/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-03-09-pliss-learn-about-pl-implementation-in-a-castle</id>
  <published>2019-03-09T14:40:16Z</published>
  <updated>2019-03-09T14:40:16Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;We love programming languages (PLs), and we should all be in on the ins and outs of implementing them. If you&amp;rsquo;re interested in learning the tricks of the trade of PL design and implementation, what better opportunity than the second Programming Languages Implementation Summer School (&lt;a href="https://pliss2019.github.io/"&gt;PLISS&lt;/a&gt; for short).&lt;/p&gt;

&lt;p&gt;PLISS will be held from May 19th to 24th 2019, and the deadline to express your interest is &lt;em&gt;March 29th, 2019&lt;/em&gt; at &lt;em&gt;17:00 GMT&lt;/em&gt;. More details can be found &lt;a href="https://pliss2019.github.io/registration.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;&lt;img src="/img/pliss_summer_school_2017_logo.png" alt="PLISS logo" /&gt;&lt;/p&gt;

&lt;p&gt;The school will feature &lt;a href="https://pliss2019.github.io/speakers.html"&gt;ten speakers&lt;/a&gt; from both academia and industry, each well-versed in the practical side of programming languages. The lectures cover current research as well as future trends in programming language design and implementation, including:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Developing Security-Aware Languages with Cristina Cifuentes;&lt;/li&gt;
 &lt;li&gt;Semantics-First Language Design with Sylvan Clebsch;&lt;/li&gt;
 &lt;li&gt;Compiler Design Patterns for Machine Learning by Albert Cohen;&lt;/li&gt;
 &lt;li&gt;Design and Analysis of Configuration Languages by Arjun Guha;&lt;/li&gt;
 &lt;li&gt;A Survey of V8 and WebAssembly by Ben L. Titzer;&lt;/li&gt;
 &lt;li&gt;Crafting User-Friendly Compilers by Nicholas Matsakis;&lt;/li&gt;
 &lt;li&gt;Static Program Analysis by Anders Møller;&lt;/li&gt;
 &lt;li&gt;How Industry Approaches Language and Compiler Design by Joe Pamer;&lt;/li&gt;
 &lt;li&gt;What an End to Non-Volatile RAM Means for Researchers by Mario Wolczko.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Besides attending lectures, students will also be able to get to know the speakers and attendees and think of new research problems. A week-long stay in beautiful Bertinoro, Italy is an ideal setting for socializing with other PL enthusiasts and building lasting relationships.&lt;/p&gt;

&lt;p&gt;If I may, I attended the first PLISS in 2017 and can&amp;rsquo;t recommend it enough. The atmosphere at summer schools is truly unparalleled, and I made friends there that have stood the test of time. For what it&amp;rsquo;s worth to any prospective graduate students, PLISS is also where I met my PhD advisor. Students will be surprised at how many faces they recognize at future conferences, and in a sense summer schools are nice introduction to the research community. You can read another attendee&amp;rsquo;s testimonial &lt;a href="http://prl.ccs.neu.edu/blog/2017/06/05/report-pliss-2017/"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;More information can be found at:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://pliss2019.github.io"&gt;https://pliss2019.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(No, really, it&amp;rsquo;s in a castle. Look at the pictures.)&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Writing a paper with Scribble</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/02/17/writing-a-paper-with-scribble/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-02-17-writing-a-paper-with-scribble</id>
  <published>2019-02-17T16:20:50Z</published>
  <updated>2019-02-17T16:20:50Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;This post explains how to get started using Scribble to write a research paper.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
 &lt;p&gt;This post was written using &lt;a href="http://download.racket-lang.org/all-versions.html"&gt;Racket 7.1&lt;/a&gt; and &lt;a href="https://github.com/racket/scribble/releases/tag/v7.1"&gt;Scribble 1.29&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Writing about research is always difficult,  but a compile-to-LaTeX tool can make the task easier. If your research code is written in the same language as the paper, then:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;the paper can import definitions from the research,  keeping a single point of control;&lt;/li&gt;
 &lt;li&gt;the language&amp;rsquo;s functional abstractions can help manage the writing;&lt;/li&gt;
 &lt;li&gt;the language&amp;rsquo;s drawing and/or plotting libraries can replace &lt;a href="https://ctan.org/pkg/pgf?lang=en"&gt;TikZ&lt;/a&gt;;&lt;/li&gt;
 &lt;li&gt;and you can write unit tests to validate the claims made in the paper.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Scribble, &lt;a href="http://docs.racket-lang.org/scribble/index.html"&gt;the Racket documentation tool&lt;/a&gt;,  comes with a to-LaTeX compiler and a &lt;a href="&amp;lt;http://docs.racket-lang.org/scribble/ACM_Paper_Format.html&amp;gt;"&gt;scribble/acmart&lt;/a&gt;  library tailored to the new &lt;a href="https://ctan.org/pkg/acmart?lang=en"&gt;ACM paper format&lt;/a&gt;. I have been a pretty happy user of these tools. In the interest of attracting more happy users, this post  presents a short &amp;ldquo;getting started&amp;rdquo; guide  and links to some larger examples.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;For a Scribble tutorial, see the links in: &lt;a href="/blog/2017/05/23/building-a-website-with-scribble/index.html"&gt;Building a Website with Scribble&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id="getting-started-with-"&gt;Getting started with &lt;a href="&amp;lt;http://docs.racket-lang.org/scribble/ACM_Paper_Format.html&amp;gt;"&gt;scribble/acmart&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The first line of a &lt;a href="&amp;lt;http://docs.racket-lang.org/scribble/ACM_Paper_Format.html&amp;gt;"&gt;scribble/acmart&lt;/a&gt; document sets the formatting options (similar to a LaTeX file using &lt;code&gt;acmart.cls&lt;/code&gt;). For example, the &lt;a href="https://conf.researchr.org/track/gpce-2018/gpce-2018#Call-for-Papers"&gt;GPCE 2018 call for papers&lt;/a&gt;  asks for anonymized &lt;code&gt;sigplan&lt;/code&gt;-format submissions with line numbers and 10 point font. The proper Scribble incantation is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang scribble/acmart @sigplan @anonymous @review @10pt&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, you may want to import some definitions. If we have a file &lt;code&gt;references.rkt&lt;/code&gt; (see below for a definition), we can import it as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@require{references.rkt}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third main ingredient is the title and author information:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@(define neu (affiliation #:institution "Northeastern University"))
@(define anon (email "anon@anon.net"))

@title{Writing a paper with Scribble}
@author[#:affiliation neu #:email anon]{Ben Greenman}

@; optional: set the author names in the page headers
@elem[#:style "Sshortauthors"]{B. Greenman}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The paper is now ready to be written. You can forge ahead with a new &lt;a href="http://docs.racket-lang.org/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._section%29%29"&gt;section&lt;/a&gt;  and start adding content to the same file;  alternatively, you can organize the writing across different modules. In this post, we will use the main document as an outline and &lt;a href="http://docs.racket-lang.org/scribble/base.html#%28form._%28%28lib._scribble%2Fbase..rkt%29._include-section%29%29"&gt;import&lt;/a&gt;  content from other modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@include-abstract{abstract.scrbl}
@include-section{introduction.scrbl}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the main page is a good place to &lt;a href="https://docs.racket-lang.org/scriblib/autobib.html"&gt;generate the bibliography&lt;/a&gt;. Assuming this document imports a file like the &lt;code&gt;references.rkt&lt;/code&gt; below,  this expression inserts a bibliography titled &amp;ldquo;References&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@generate-bibliography[#:sec-title "References"]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To build the document, invoke &lt;code&gt;scribble&lt;/code&gt; on the command-line with the &lt;code&gt;--pdf&lt;/code&gt; or &lt;code&gt;--latex&lt;/code&gt;  options:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ raco scribble --pdf FILE.scrbl&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If all goes well, this command generates a &lt;code&gt;FILE.pdf&lt;/code&gt; with properly-linked cross references.&lt;/p&gt;

&lt;h3 id="auxiliary-files"&gt;Auxiliary Files&lt;/h3&gt;

&lt;p&gt;If you save the code above to a file &lt;code&gt;example.scrbl&lt;/code&gt; and save the files below  in the same directory, then you should be able to build an &lt;code&gt;example.pdf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These files are available in a slightly different format at this link:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://gitlab.com/bengreenman/scribble-acmart-example"&gt;https://gitlab.com/bengreenman/scribble-acmart-example&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h4 id="referencesrkt"&gt;&lt;code&gt;references.rkt&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#lang racket/base

(provide
  ~cite citet generate-bibliography
  fbf-icfp-2009)

(require
  scriblib/autobib)

(define-cite ~cite citet generate-bibliography
  #:style author+date-square-bracket-style)

(define icfp "ICFP")

(define fbf-icfp-2009
  (make-bib
    #:title "Scribble: Closing the Book on Ad Hoc Documentation Tools"
    #:author (authors "Matthew Flatt" "Eli Barzilay" "Robert Bruce Findler")
    #:location (proceedings-location icfp #:pages '(109 120))
    #:date 2017))&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="abstractscrbl"&gt;&lt;code&gt;abstract.scrbl&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#lang scribble/acmart

A simple Scribble document.&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="introductionscrbl"&gt;&lt;code&gt;introduction.scrbl&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#lang scribble/acmart
@require{references.rkt}

@; start with `title` instead of `section`, because importing via
@;  `include-section` shifts all title/section/subsections down one level
@title{Introduction}

Scribble creates a connection between a stand-alone document and the artifact
it describes@~cite[fbf-icfp-2009].&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-how-to-debug-scribble-error-messages"&gt;Q. How to debug Scribble error messages?&lt;/h3&gt;

&lt;p&gt;If something goes wrong building a Scribble document, Racket is usually able to give a helpful error message.&lt;/p&gt;

&lt;p&gt;As a compile-time example, adding &lt;code&gt;@ foo&lt;/code&gt; to a document produces the message  &lt;code&gt;unexpected whitespace after @&lt;/code&gt; and you can either delete the whitespace  or change the &lt;code&gt;@&lt;/code&gt; to &lt;code&gt;@"@"&lt;/code&gt; for a literal &lt;code&gt;@&lt;/code&gt;-sign.&lt;/p&gt;

&lt;p&gt;As a run-time example, adding &lt;code&gt;@(+ 2 2)&lt;/code&gt; produces this message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;not valid in document body (need a pre-part for decode) in: 4&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One fix is to convert &lt;code&gt;4&lt;/code&gt; to a string, as in &lt;code&gt;@~a[(+ 2 2)]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But if something goes wrong when Scribble renders a generated document to  PDF, the default error output is &lt;strong&gt;not&lt;/strong&gt; likely to help. For example, adding &lt;code&gt;@elem[#:style "oops"]&lt;/code&gt; to a document produces a giant  message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ raco scribble --pdf FILE.scrbl
[[ ... 84K of output ... ]]
Output written on example.pdf (1 page, 277876 bytes).
PDF statistics:
 53 PDF objects out of 1000 (max. 8388607)
 37 compressed objects within 1 object stream
 7 named destinations out of 1000 (max. 500000)
 36877 words of extra memory for PDF output out of 42996 (max. 10000000)

run-pdflatex: got error exit code
  context...:
  [[ ... 17 more lines ... ]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The best way to debug these messages is to &lt;strong&gt;ignore them&lt;/strong&gt; and use a LaTeX  compiler directly. For the &amp;ldquo;oops&amp;rdquo; mistake, LaTeX stops at the undefined control sequence &amp;mdash; giving  a hint about how to find the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ raco scribble --latex FILE.scrbl
$ pdflatex FILE.tex
[[ ... 12KB of output ... ]]
! Undefined control sequence.
l.549 \oops
           {}
? &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-how-to-add-a-latex-style-file"&gt;Q. How to add a LaTeX style file?&lt;/h3&gt;

&lt;p&gt;To add extra LaTeX code to the final document, create a new file and include  it with the &lt;code&gt;++style&lt;/code&gt; command-line flag. This copies the contents of the style file into the generated document  (the copy appears near the top of the generated code).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ raco scribble ++style style.tex --pdf FILE.scrbl&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is an example style file.&lt;/p&gt;

&lt;h4 id="styletex"&gt;&lt;code&gt;style.tex&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;\settopmatter{printfolios=true,printccs=true,printacmref=true}
% add page numbers etc.

\overfullrule=1mm
% draw a black rectangle near lines that overflow the margin&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another way to add extra LaTeX code is to add a &lt;a href="https://docs.racket-lang.org/scribble/core.html#%28def._%28%28lib._scribble%2Flatex-properties..rkt%29._tex-addition%29%29"&gt;&lt;code&gt;tex-addition&lt;/code&gt;&lt;/a&gt;  style property to the main title. This second approach makes it easy to include more than one file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang scribble/acmart

@require[
  (only-in scribble/core make-style)
  (only-in scribble/latex-properties make-tex-addition)]

@(define extra-style-files
   (list (make-tex-addition "style.tex")))

@title[#:style (make-style #f extra-style-files)]{Writing a paper with Scribble}

@; ....&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-how-to-make-a-figure"&gt;Q. How to make a figure?&lt;/h3&gt;

&lt;p&gt;Use the &lt;a href="&amp;lt;http://docs.racket-lang.org/scriblib/figure.html#%28def._%28%28lib._scriblib%2Ffigure..rkt%29._figure%29%29&amp;gt;"&gt;scriblib/figure&lt;/a&gt;  library to add figures to a document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@require[pict scriblib/figure]
@figure[
  "fig:fish"  @; figure tag, see `figure-ref`
  @elem{A Standard Fish}  @; figure caption, appears below the content
  @elem{fish = @(standard-fish 90 40)}]  @; content&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The content of a figure can be almost anything that would work in the toplevel  of the document.&lt;/p&gt;

&lt;h3 id="q-how-to-include-extra-files-pictures-latex"&gt;Q. How to include extra files (pictures, LaTeX)?&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;++extra&lt;/code&gt; command-line flag names an auxilliary file that Scribble should  include when rendering the document. This flag may be supplied more than once.&lt;/p&gt;

&lt;p&gt;For example, if a document includes the content of an external LaTeX file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@elem[#:style "input"]{inline-this.tex}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then make sure to build the document with a command like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ raco scribble ++style style.tex ++extra inline-this.tex FILE.scrbl&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="inline-thistex"&gt;&lt;code&gt;inline-this.tex&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;% Raw LaTeX allowed here
$\lambda x.\, x$&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-about-in-line-latex"&gt;Q. What about in-line LaTeX?&lt;/h3&gt;

&lt;p&gt;An &lt;a href="https://docs.racket-lang.org/scribble/core.html#%28def._%28%28lib._scribble%2Fcore..rkt%29._element%29%29"&gt;element&lt;/a&gt;  with the &lt;a href="https://docs.racket-lang.org/scribble/core.html#%28idx._%28gentag._60._%28lib._scribblings%2Fscribble%2Fscribble..scrbl%29%29%29"&gt;&lt;code&gt;'exact-chars&lt;/code&gt;&lt;/a&gt;  &lt;a href="https://docs.racket-lang.org/scribble/core.html#%28tech._style._property%29"&gt;style property&lt;/a&gt;  renders directly to LaTeX.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@(define (exact . stuff)
   @; the style name "relax" puts a `\relax` no-op in front of the stuff
   (make-element (make-style "relax" '(exact-chars)) stuff))

@exact|{$\lambda x.\, x$}|
@; ==&amp;gt; \relax{$\lambda x.\, x$}

@(define ($ . math-stuff)
   (apply exact (list "$" math-stuff "$")))

@${\lambda x.\, x}
@; ==&amp;gt; \relax{$\lambda x.\, x$}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="creating-a-httpdocsracket-langorgguidemodulesyntaxhtml28parthash-lang29lang-for-a-paper"&gt;Creating a &lt;a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29"&gt;#lang&lt;/a&gt; for a paper&lt;/h2&gt;

&lt;p&gt;For a Scribble document that is split across multiple files, it can be helpful  to make a &lt;code&gt;#lang&lt;/code&gt; that &lt;a href="http://blog.racket-lang.org/2017/03/languages-as-dotfiles.html"&gt;provides a common environment&lt;/a&gt;. Instead of starting each file with a &lt;code&gt;require&lt;/code&gt;, e.g.:&lt;/p&gt;

&lt;h4 id="paperscrbl"&gt;&lt;code&gt;paper.scrbl&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#lang scribble/acmart
@require["references.rkt" "helper-functions.rkt" scriblib/figure]

....&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;files can start with a name that describes their common purpose:&lt;/p&gt;

&lt;h4 id="paperscrbl"&gt;&lt;code&gt;paper.scrbl&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#lang conference-2018-submission

....&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a bonus, if the language is defined as a package then the Scribble document  can use Racket&amp;rsquo;s dependency management tools:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# to install the paper and interactively install dependencies:
$ cd conference-2018-submission;
$ raco pkg install

# To check that the paper builds with no dependency issues:
$ raco setup --check-pkg-deps conference-2018-submission

# To run all unit tests
$ raco test -c conference-2018-submission&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create a package and language:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Move the Scribble document to a directory with the language name, i.e.,  &lt;code&gt;conference-2018-submission/&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;Write a simple &lt;code&gt;info.rkt&lt;/code&gt; to configure the package&lt;/li&gt;
 &lt;li&gt;Create a normal Racket module that exports the common environment&lt;/li&gt;
 &lt;li&gt;Create a &lt;code&gt;conference-2018-submission/lang/reader.rkt&lt;/code&gt; module&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Details below. For a full example, visit:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://gitlab.com/bennn/scribble-acmart-example"&gt;https://gitlab.com/bennn/scribble-acmart-example&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id="conference-2018-submissioninforkt"&gt;&lt;code&gt;conference-2018-submission/info.rkt&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;This file defines the basic metadata for a package. For more about &lt;code&gt;info.rkt&lt;/code&gt;, see: &lt;a href="http://blog.racket-lang.org/2017/10/tutorial-creating-a-package.html"&gt;Tutorial: Creating a Package&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang info
(define collection "conference-2018-submission")
(define deps '("base" "scribble-lib" "at-exp-lib"))
(define build-deps '("racket-doc" "scribble-doc"))
(define pkg-desc "Paper for Conference 2018")
(define version "0.1")&lt;/code&gt;&lt;/pre&gt;

&lt;br /&gt;

&lt;h4 id="conference-2018-submissionmainrkt"&gt;&lt;code&gt;conference-2018-submission/main.rkt&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;This file defines and exports the common environment for every file in our  Scribble document. In this example, the common environment is:  the &lt;a href="&amp;lt;http://docs.racket-lang.org/scribble/ACM_Paper_Format.html&amp;gt;"&gt;scribble/acmart&lt;/a&gt; language,  the file &amp;ldquo;references.rkt&amp;rdquo;,  and the &lt;a href="&amp;lt;http://docs.racket-lang.org/scriblib/figure.html#%28def._%28%28lib._scriblib%2Ffigure..rkt%29._figure%29%29&amp;gt;"&gt;scriblib/figure&lt;/a&gt; library.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang racket/base

(provide
  (all-from-out
    scribble/acmart
    scribble/acmart/lang
    scriblib/figure
    "references.rkt"))

(require
  scribble/acmart
  scribble/acmart/lang
  scriblib/figure
  "references.rkt")&lt;/code&gt;&lt;/pre&gt;

&lt;br /&gt;

&lt;h4 id="conference-2018-submissionlangreaderrkt"&gt;&lt;code&gt;conference-2018-submission/lang/reader.rkt&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;This file:  (1) tells Racket to use the Scribble reader on &lt;code&gt;#lang conference-2018-submission&lt;/code&gt;  modules, and (2) wraps the result of such modules in a shape that Scribble  expects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang s-exp scribble/base/reader
conference-2018-submission
#:wrapper1 (lambda (t) (cons 'doc (t)))&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="links-to-example-documents"&gt;Links to Example Documents&lt;/h2&gt;

&lt;p&gt;These documents use the &lt;code&gt;#lang&lt;/code&gt; approach to writing a paper with Scribble. Check their &lt;code&gt;main.rkt&lt;/code&gt; for example formatting functions and unit tests,  and check the &lt;code&gt;.scrbl&lt;/code&gt; files to see how the ideas above look in a larger document.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/retic_performance/tree/master/gm-pepm-2018"&gt;https://github.com/nuprl/retic_performance/tree/master/gm-pepm-2018&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/tag-sound/tree/master/gf-icfp-2018"&gt;https://github.com/nuprl/tag-sound/tree/master/gf-icfp-2018&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Finally, this repository provides a tool to start a new Scribble document:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://pkgd.racket-lang.org/pkgn/package/gtp-paper"&gt;https://pkgd.racket-lang.org/pkgn/package/gtp-paper&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="further-reading"&gt;Further Reading&lt;/h2&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://project.inria.fr/coqexchange/checking-machine-checked-proofs/"&gt;Checking Machine-Checked Proofs&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry>
 <entry>
  <title type="text">On-Stack Replacement</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/01/28/on-stack-replacement/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-01-28-on-stack-replacement</id>
  <published>2019-01-28T10:29:57Z</published>
  <updated>2019-01-28T10:29:57Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;Last semester, I took &lt;a href="https://course.ccs.neu.edu/cs7600/"&gt;a course&lt;/a&gt; where the final project was to write a survey paper on &amp;ldquo;a topic in the intersection between computer systems and your area.&amp;rdquo; So I wrote about on-stack replacement.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;On-stack replacement (OSR) is a programming language implementation technique that allows a running program to switch to a different version of code. For example, a program could start executing optimized code, and then transfer to and start executing unoptimized code. This was the original use case for OSR, to facilitate debugging of optimized code.&lt;/p&gt;
 &lt;p&gt;After its original use was established, OSR shifted to a different use case: optimizing programs. OSR allows the run-time system to detect if a program is executing an inefficient loop, recompile and optimize the method that contains the loop, and then transfer control to the newly compiled method. Another strategy is to optimize code based on some assumptions, then, if the assumptions are invalidated at run-time, transfer control back to the original, unoptimized code.&lt;/p&gt;
 &lt;p&gt;In this survey paper, we study how OSR was first introduced as a means for debugging, how it came to be used for program optimizations, its implementation as a reusable library, and other directions of research.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If you&amp;rsquo;re interested, you can find a copy &lt;a href="/img/cs7600-mhyee-survey-paper-osr.pdf"&gt;here&lt;/a&gt; or on &lt;a href="https://www.overleaf.com/read/smcmsnksxfdk"&gt;Overleaf&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;If you liked this post, you may also be interested in &lt;a href="http://prl.ccs.neu.edu/blog/2017/03/15/tracing-jits-for-dynamic-languages/"&gt;tracing JITs for dynamic languages&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">The Behavior of Gradual Types: A User Study</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/12/11/the-behavior-of-gradual-types-a-user-study/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-12-11-the-behavior-of-gradual-types-a-user-study</id>
  <published>2018-12-11T19:50:33Z</published>
  <updated>2018-12-11T19:50:33Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">&lt;!-- more--&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: this post is an extended abstract for the paper &lt;em&gt;The Behavior of Gradual Types: A User Study&lt;/em&gt; by Preston Tunnell&amp;mdash;Wilson, Ben Greenman, Justin Pombrio, and Shriram Krishnamurthi. For the full paper, datasets, and slides, &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#tgpk-dls-2018"&gt;click here&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The long-term goal of gradual typing is to build languages that offer the  &amp;ldquo;best&amp;rdquo; of both static and dynamic typing. Researchers disagree, however, on what the semantics of a mixed-typed language  should be; there are &lt;a href="/blog/2018/10/06/a-spectrum-of-type-soundness-and-performance/"&gt;at least three competing proposals&lt;/a&gt;  for combining a dynamically-typed language with a similar statically-typed language.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;It&amp;rsquo;s an interesting situation. There are dozens of papers on the semantics of gradual types&amp;mdash;and &lt;a href="http://www.ccs.neu.edu/home/types/resources/talks/tgpk-dls-2018.pdf"&gt;many claim&lt;/a&gt; to have developers in mind&amp;mdash;but zero papers that ask developers what they think.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;To help inform the discussion, we recently designed a &lt;a href="&amp;lt;http://cs.brown.edu/research/plt/dl/dls2018&amp;gt;"&gt;survey&lt;/a&gt;  to see what programmers think of three mixed-typed semantics. The survey is based on 8 example programs; we selected these 8 programs because the set as a whole tells the three mixed-typed semantics apart. For each program, the survey presents a few possible outcomes of running the  program and asks participants for their opinion on each outcome.&lt;/p&gt;

&lt;p&gt;The image below shows one program from the survey:&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-program.png" alt="Figure 1: example program" /&gt;&lt;/p&gt;

&lt;p&gt;This program creates an array, passes it between typed and untyped variables,  and performs write &amp;amp; read operations. What should happen when we run this program? One option is to ignore the type annotations and return the second element  of the array (&lt;code&gt;"bye"&lt;/code&gt;). A second option is to reject the write operation (on line 4) because it attempts  to write a number to a variable of type &lt;code&gt;Array(String)&lt;/code&gt;. A third option is to reject the assignment after the read operation (on line 5)  because it attempts to assign a string to a variable of type &lt;code&gt;Number&lt;/code&gt;. These are the three behaviors in the survey:&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-behaviors.png" alt="Figure 2: behaviors for the example question" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;A fourth option is to reject the assignment of an &lt;code&gt;Array(String)&lt;/code&gt; to a variable of type &lt;code&gt;Array(Number)&lt;/code&gt;. A few participants left comments asking for this behavior. See the &lt;a href="&amp;lt;http://cs.brown.edu/research/plt/dl/dls2018&amp;gt;"&gt;anonymized responses&lt;/a&gt; for their comments, and see &lt;a href="&amp;lt;http://cs.brown.edu/~sk/Publications/Papers/Published/tgpk-beh-grad-types-user-study&amp;gt;"&gt;the paper&lt;/a&gt; for why we left that behavior out.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For each behavior, we asked for respondents&amp;rsquo; preference along two independent dimensions:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Do you &lt;em&gt;like&lt;/em&gt; or &lt;em&gt;dislike&lt;/em&gt; this behavior?&lt;/li&gt;
 &lt;li&gt;Does it match your &lt;em&gt;expectation&lt;/em&gt; as a programmer?&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Combined, the dimensions lead to four possible &lt;em&gt;attitudes&lt;/em&gt;: Like and Expected,  Like and Unexpected, Dislike and Expected, Dislike and Unexpected. The full example question, with attitudes and space for comments, is below.&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-question.png" alt="Figure 3: complete question" /&gt;&lt;/p&gt;

&lt;p&gt;We administered the survey to three populations &amp;mdash; software engineers,  students, and Mechanical Turk workers &amp;mdash; and thereby collected three sets of  attitudes for each question. The results for the running example are below:&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-data.png" alt="Figure 4: results for Question 7" /&gt;&lt;/p&gt;

&lt;p&gt;The figure is a matrix of three columns (one for each population)  and three rows (one for each behavior). Each cell of the matrix contains a bar chart showing the attitudes  that we collected.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Unlike the survey question, the behaviors in the results are labeled as &lt;strong&gt;Deep&lt;/strong&gt;, &lt;strong&gt;Erasure&lt;/strong&gt;, and &lt;strong&gt;Shallow&lt;/strong&gt;. These names describe the three mixed-typed semantics.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For this question, the software engineers (left column, green bars)  mostly picked the &amp;ldquo;Dislike and Unexpected&amp;rdquo; attitude for every behavior. The students (mid column, blue bars) also show consensus on &amp;ldquo;Dislike and  Unexpected&amp;rdquo; for the &lt;strong&gt;Deep&lt;/strong&gt; and &lt;strong&gt;Erasure&lt;/strong&gt; behaviors; however, they are split  for the &lt;strong&gt;Shallow&lt;/strong&gt; behavior. The Mechanical Turk workers are divided on every behavior.&lt;/p&gt;

&lt;p&gt;See &lt;a href="&amp;lt;http://cs.brown.edu/~sk/Publications/Papers/Published/tgpk-beh-grad-types-user-study&amp;gt;"&gt;the paper&lt;/a&gt; for the other questions and responses.&lt;/p&gt;

&lt;p&gt;Overall, our main finding is that respondents preferred behaviors that enforced  full types and reported runtime mismatches as early as possible. The takeaway is thus:&lt;/p&gt;

&lt;p style="margin-left: 40px; margin-right: 40px"&gt;if you are designing a mixed-typed language and choose &lt;strong&gt;not&lt;/strong&gt; to enforce full types, then make sure to explain this behavior to users!&lt;/p&gt;

&lt;p&gt;Put lots of example programs in the language&amp;rsquo;s documentation. The programs in the survey can be adapted to explain how your chosen  behavior differs from alternatives.&lt;/p&gt;

&lt;h2 id="questions"&gt;Questions&lt;/h2&gt;

&lt;p&gt;Here are some good questions we&amp;rsquo;ve gotten that are not clearly answered in the paper.&lt;/p&gt;

&lt;h4 id="q-did-any-respondents-expect-more-than-one-behavior"&gt;Q. Did any respondents &amp;ldquo;expect&amp;rdquo; more than one behavior?&lt;/h4&gt;

&lt;p&gt;Yes, 59% &lt;!-- 20/34--&gt; of the software engineers and 82% &lt;!-- 14/17--&gt; of the students selected &amp;ldquo;Liked and Expected&amp;rdquo; and/or &amp;ldquo;Dislike and Expected&amp;rdquo; for different behaviors on the same program.&lt;/p&gt;
&lt;!-- They probably interpreted "Expected" as--&gt;
&lt;!--  "the program does something that makes sense", rather than--&gt;
&lt;!--  "the program does the one thing that I believe it should do".--&gt;
&lt;!-- ids for "double-expect" S.Es : R_24bz47lgcAOkCux R_2R4dZ1l0t3yx6fW R_b7yMVe7VtmmsrHb R_31MXSUfCyDE8FdG R_6LGXyOirYNtYWd3 R_2qyMZBAs74PrsSz R_2ASFRBh2jfuRgP1 R_1PUc0AUEzdXKGt8 R_2dL60N9oPIkbvWY R_1BXXqYyxH7R4r9l R_1ON2sxGalcODyAd R_1oyZasBudU5gKPS R_1FIHgkQbWGaxuHd R_b1s2YMBWCrCRvxf R_29t0zWxkQsfb9FT R_2fevZOrFGzS6JLf R_8Dn6NMjDyigT59n R_2pRG370z3cBUaKv R_2qDXTFI53ntWMu4 R_ZI8AwATueqyWwOR--&gt;
&lt;!-- ids for "double-expect" students : R_9B6WHWEX5l0DskN R_22VAu37cGWQPQx1 R_3hgYSaGy2tbyY3G R_3rTbAqgn1rhQK4d R_r3HqAP1yGRXHaZX R_1l05qvQ1sYOCcCF R_3qaMT9xR7CRYg2Y R_1Li0sGHkxk1VfcA R_24ITtgvBzg9RpE3 R_3HzshHbDWkayp4t R_5mtEFLtSX0iPVOp R_1IR6vdpmVw4OCqV R_2XpWlkKjH9LQqln R_DoQrROe0dcb1YJz--&gt;

&lt;h4 id="q-did-the-respondents-have-a-prior-preference-for-static-or-dynamic-typing"&gt;Q. Did the respondents have a prior preference for static or dynamic typing?&lt;/h4&gt;

&lt;p&gt;Near the end of the survey we asked: &amp;ldquo;Which do you prefer, typed or untyped programming?&amp;rdquo;. See table 2 of &lt;a href="&amp;lt;http://cs.brown.edu/~sk/Publications/Papers/Published/tgpk-beh-grad-types-user-study&amp;gt;"&gt;the paper&lt;/a&gt; for coded responses to this question,  or the &lt;a href="&amp;lt;http://cs.brown.edu/research/plt/dl/dls2018&amp;gt;"&gt;anonymized responses&lt;/a&gt; for the ground truth. Most preferred typed programming.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Java and Migratory Typing</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/12/02/java-and-migratory-typing/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-12-02-java-and-migratory-typing</id>
  <published>2018-12-02T14:41:53Z</published>
  <updated>2018-12-02T14:41:53Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;The &lt;em&gt;transient&lt;/em&gt; approach to migratory typing (circa &lt;a href="http://homes.sice.indiana.edu/mvitouse/papers/dls14.pdf"&gt;2014&lt;/a&gt;)  is similar to type erasure in Java (circa &lt;a href="https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html"&gt;2004&lt;/a&gt;)  in a few interesting ways.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="migratory-typing"&gt;Migratory typing&lt;/h2&gt;

&lt;p&gt;The goal of &lt;em&gt;migratory typing&lt;/em&gt; is to enrich the type system of a language  without breaking backwards compatibility. Ideally, code that uses the enriched types:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;(G1) benefits from new ahead-of-time checks,&lt;/li&gt;
 &lt;li&gt;(G2) benefits from stronger run-time guarantees, and&lt;/li&gt;
 &lt;li&gt;(G3) may interact with all kinds of existing code.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;There are tradeoffs involved in the implementation of a migratory typing  system, however, and (as we will see) different implementations may focus on  different goals than the three above.&lt;/p&gt;

&lt;p&gt;A typical migratory typing system adds a static type checker to a dynamically  typed language (&lt;a href="/blog/2018/10/06/a-spectrum-of-type-soundness-and-performance/index.html"&gt;examples&lt;/a&gt;),  but one could also extend the type system of a statically-typed language;  for example, by &lt;a href="https://hal.inria.fr/hal-01629909v2"&gt;adding dependent types&lt;/a&gt;. In this sense, Java 1.5.0 is a migratory typing system for pre-generics Java. The addition of generic types enabled new ahead-of-time checks and maintained backwards  compatibility with existing Java code.&lt;/p&gt;

&lt;p&gt;Java&amp;rsquo;s implementation of migratory typing has some interesting things in common  with the &lt;em&gt;transient&lt;/em&gt; implementation strategy recently proposed by  Michael Vitousek and collaborators (&lt;a href="http://homes.sice.indiana.edu/mvitouse/papers/dls14.pdf"&gt;DLS&amp;rsquo;14&lt;/a&gt;, &lt;a href="https://mail.google.com/mail/u/0/h/1atrn21qlyrrh/?&amp;amp;"&gt;POPL&amp;rsquo;17&lt;/a&gt;). The goal of this post is to demonstrate the connections.&lt;/p&gt;

&lt;h2 id="erasure-migratory-typing"&gt;Erasure migratory typing&lt;/h2&gt;

&lt;p&gt;Before we compare Java 1.5.0 to transient, let&amp;rsquo;s review a simpler strategy:  the &lt;em&gt;erasure&lt;/em&gt; approach to migratory typing.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.typescriptlang.org/"&gt;TypeScript&lt;/a&gt; is a great (modern) example of the erasure approach. TypeScript is a migratory typing system for JavaScript. A TypeScript module gets validated by an ahead-of-time type checker and  compiles to JavaScript. After compilation, any JavaScript program may import bindings  from the generated code. Conversely, a TypeScript module may import bindings from a JavaScript module  by declaring a static type for each binding.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;The &lt;a href="http://definitelytyped.org/"&gt;DefinitelyTyped&lt;/a&gt; repository provides TypeScript type definitions for many JavaScript libraries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The TypeScript compiler erases types;  every type &lt;code&gt;T&lt;/code&gt; in the source code translates to the universal &amp;ldquo;JavaScript type&amp;rdquo;. For instance, a TypeScript function declaration compiles to an untyped  JavaScript function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function (n0 : number, n1 : number) { return n0 + n1; })

// ==(compiles to)==&amp;gt;

(function (n0, n1) { return n0 + n1; })&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TypeScript satisfies goals &lt;strong&gt;G1&lt;/strong&gt; and &lt;strong&gt;G3&lt;/strong&gt; for a migratory typing system  because its type checker adds ahead-of-time checks and its  compiler outputs JavaScript. TypeScript does not satisfy goal &lt;strong&gt;G2&lt;/strong&gt; because the compiler erases types. In terms of the example above, the compiled function may be invoked with any  pair of JavaScript values; the variable &lt;code&gt;n0&lt;/code&gt; is not guaranteed to point  to a &lt;code&gt;number&lt;/code&gt; at run-time. On one hand, this means the type annotations have no effect on the behavior  of a program &amp;mdash; and in particular, cannot be trusted for debugging. On the other hand, it means that an experienced JavaScript programmer can  re-use their knowledge to predict the behavior of a TypeScript program.&lt;/p&gt;

&lt;p&gt;In an ordinary program, the run-time guarantees of TypeScript are simply  the run-time guarantees of JavaScript:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;if a TypeScript expression &lt;code&gt;e&lt;/code&gt; has the static type &lt;code&gt;T&lt;/code&gt; and evaluates to  a value &lt;code&gt;v&lt;/code&gt;,&lt;/li&gt;
 &lt;li&gt;then the only guarantee is that &lt;code&gt;v&lt;/code&gt; is a valid JavaScript value  (e.g., &lt;code&gt;T&lt;/code&gt; could be &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; could be an incompatible object).&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="transient-migratory-typing"&gt;Transient migratory typing&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/mvitousek/reticulated"&gt;Reticulated&lt;/a&gt; is a migratory typing  system for Python that follows a &lt;em&gt;transient&lt;/em&gt; implementation strategy. A Reticulated module gets type-checked and compiles to a Python module that  defends itself from certain type-invalid inputs through the use of  assertions that run in near-constant time. The type-checking addresses goal &lt;strong&gt;G1&lt;/strong&gt;,  the compilation to Python provides interoperability (goal &lt;strong&gt;G3&lt;/strong&gt;),  and the assertions partially meet goal &lt;strong&gt;G2&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;These &lt;em&gt;certain&lt;/em&gt; inputs are the ones that would cause a standard typed operational semantics to reach an undefined state. For a discussion of &lt;em&gt;near-constant&lt;/em&gt;, see &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gm-pepm-2018"&gt;&lt;em&gt;On the Cost of Type-Tag Soundness&lt;/em&gt;, section 2&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For example, here is a Reticulated function  that computes the average of a list of numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Reticulated (commit e478343)
def average(nums : List(Float)) -&amp;gt; Float:
  if ns:
    return sum(ns) / len(ns)
  else:
    raise ValueError("average: expected non-empty list")&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and here is the Python code it compiles to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from retic.runtime import *
from retic.transient import *
from retic.typing import *

def average(nums):
    check_type_list(nums)
    if ns:
        return check_type_float((check_type_function(sum)(ns) / check_type_function(len)(ns)))
    else:
        raise check_type_function(ValueError)('average: expected non-empty list')&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: the Reticulated syntax for type annotations is similar to the one proposed in &lt;a href="https://www.python.org/dev/peps/pep-0484/"&gt;PEP 484&lt;/a&gt;, but not identical. For example, Reticulated does not require forward references to be embedded in strings.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The Reticulated compiler removes all type annotations and inserts &lt;code&gt;check_type&lt;/code&gt;  assertions throughout the code. In &lt;code&gt;average&lt;/code&gt;, these assertions check that: (1) the input is a list,  (2) the output is a &lt;code&gt;float&lt;/code&gt;, (3) and the names &lt;code&gt;sum&lt;/code&gt; &lt;code&gt;len&lt;/code&gt; and  &lt;code&gt;ValueError&lt;/code&gt; point to callable values. That&amp;rsquo;s all. The assertions &lt;strong&gt;do not check&lt;/strong&gt; that &lt;code&gt;nums&lt;/code&gt; contains only floating-point  numbers.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;The assertions also do not check that the function bound to &lt;code&gt;sum&lt;/code&gt; is defined for a single argument, which is arguably a bug. Scaling a model to an implementation is always challenging.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If &lt;code&gt;nums&lt;/code&gt; contains something other than floating point numbers, then the  call to &lt;code&gt;average&lt;/code&gt; may cause &lt;code&gt;sum&lt;/code&gt; to raise an exception or it may silently  compute a nonsense result. The behavior depends on the implementation of &lt;code&gt;sum&lt;/code&gt; in the same way that  the behavior of a TypeScript function depends on any JavaScript functions  that it invokes.&lt;/p&gt;

&lt;p&gt;Reticulated does not erase types, nor does it fully enforce types. Every type in a Reticulated module translates to its  top-level type constructor &lt;code&gt;C(T)&lt;/code&gt;, e.g.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  C(Float)                = Float
  C(List(Float))          = List
  C(List(Float) -&amp;gt; Float) = -&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Consequently, Reticulated has a slightly stronger run-time guarantee than Python:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;if &lt;code&gt;e&lt;/code&gt; is an expression with static type &lt;code&gt;T&lt;/code&gt; that evaluates to a value &lt;code&gt;v&lt;/code&gt;,&lt;/li&gt;
 &lt;li&gt;then &lt;code&gt;v&lt;/code&gt; is guaranteed to have a top-level shape that matches the &lt;code&gt;C(T)&lt;/code&gt;  constructor.&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="java-migratory-typing"&gt;Java migratory typing&lt;/h2&gt;

&lt;p&gt;Java 1.5.0 added &lt;a href="https://www.jcp.org/en/jsr/detail?id=14"&gt;generic types&lt;/a&gt;  to the Java 1.4.0 type system. The benefit of generics is that a programmer can:  write one class definition,  use the definition in a few different contexts,  and receive specific feedback from the type checker in each context.&lt;/p&gt;

&lt;h3 id="review-generic-types"&gt;Review: generic types&lt;/h3&gt;

&lt;p&gt;Suppose we want to write a &lt;code&gt;Box&lt;/code&gt; class that holds some kind of value;  the value could be an &lt;code&gt;Integer&lt;/code&gt; or a &lt;code&gt;String&lt;/code&gt; or anything else. Here is a pre-generics definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Box {
  private Object val;

  public Box(Object val) { this.set(val); }

  public void set(Object val) { this.val = val; }

  public Object get() { return this.val; }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this definition is it possible to make boxes that hold different types  of values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// good!
Box iBox = new Box(new Integer(4));
Box sBox = new Box(new String("X"));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it is also possible to &amp;ldquo;change the type&amp;rdquo; of the contents of a &lt;code&gt;Box&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// maybe bad!
iBox.set(new String("not a number"));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and some calls to &lt;code&gt;get&lt;/code&gt; must be followed by a type cast:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// annoying!
((String) sBox.get()).charAt(0);&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;With generics, we can give a name (e.g. &lt;code&gt;ValType&lt;/code&gt;) to &amp;ldquo;the type of the value inside a box&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class GBox&amp;lt;ValType&amp;gt; {
  private ValType val;

  public GBox(ValType val) { this.set(val); }

  public void set(ValType val) { this.val = val; }

  public ValType get() { return this.val; }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now we can tell the type checker to check different boxes differently (satisfying goal &lt;strong&gt;G1&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GBox&amp;lt;Integer&amp;gt; iBox = new GBox&amp;lt;Integer&amp;gt;(new Integer(0));
GBox&amp;lt;String&amp;gt; sBox = new GBox&amp;lt;String&amp;gt;(new String("A"));

// iBox.set(new String("not a number")); // Type Error, good!

sBox.get().charAt(0); // no cast, good!&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="backwards-compatibility--danger"&gt;Backwards compatibility &amp;amp; danger&lt;/h3&gt;

&lt;p&gt;Java generics are backwards-compatible with older code (goal &lt;strong&gt;G3&lt;/strong&gt;). This means that pre-generics code can interact with instances of a generic  class. Vice-versa, generic code can interact with pre-generics classes. Since pre-generics code is not aware of type parameters, these interactions  are potentially unsafe. For example, a pre-generics method can change the type of a &lt;code&gt;GBox&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Java 1.4.0 method
public static void evil(GBox b) { b.set(666); }

// Java 1.5.0 method
public static void test() {
  GBox&amp;lt;String&amp;gt; sBox = new GBox&amp;lt;String&amp;gt;(new String("A"));
  evil(sBox); // OK, but generates unchecked warning
  sBox.get().charAt(0);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above passes the type checker (with a warning about the &lt;code&gt;evil&lt;/code&gt; method),  and so it &lt;em&gt;seems&lt;/em&gt; as though running the code will run the nonsense  method call &lt;code&gt;666.charAt(0)&lt;/code&gt; and lead to evil behavior. The actual result, however, is a cast error immediately after the call  &lt;code&gt;sBox.get()&lt;/code&gt; returns.&lt;/p&gt;

&lt;p&gt;Based on the cast error, we can tell that  the compiler does not trust the type &lt;code&gt;GBox&amp;lt;String&amp;gt;&lt;/code&gt; and  inserts a run-time check that the result of the &lt;code&gt;.get()&lt;/code&gt; is a string object.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;Calling legacy code from generic code is inherently dangerous; once you mix generic code with non-generic legacy code, all the safety guarantees that the generic type system usually provides are void.&amp;rdquo; &lt;a href="https://www.oracle.com/technetwork/java/javase/generics-tutorial-159168.pdf"&gt;Generics in the Java Programming Language, Section 6.1&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="run-time-guarantees"&gt;Run-time guarantees&lt;/h3&gt;

&lt;p&gt;In order to support pre-generics and post-generics code on the same  &lt;a href="https://docs.oracle.com/javase/specs/jvms/se11/html/index.html"&gt;virtual machine&lt;/a&gt;,  the Java compiler &lt;a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.6"&gt;erases&lt;/a&gt;  generic type parameters after type-checking.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;"The decision not to make all generic types [not erased] is one of the most crucial, and controversial design decisions involving the type system of the Java programming language.&lt;/p&gt;
 &lt;p&gt;"Ultimately, the most important motivation for this decision is compatibility with existing code." &lt;a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.7"&gt;Java Language Specification, section 4.7&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;By contrast to Reticulated&amp;rsquo;s &lt;code&gt;C(T)&lt;/code&gt; transformation, the following &lt;code&gt;G(T)&lt;/code&gt;  transformation describes generic-type erasure,  where &lt;code&gt;T&amp;lt;T1&amp;gt;&lt;/code&gt; describes a type &lt;code&gt;T&lt;/code&gt; with parameter &lt;code&gt;T1&lt;/code&gt;  and &lt;code&gt;A[T1, T2]&lt;/code&gt; describes a type variable &lt;code&gt;A&lt;/code&gt; with lower bound &lt;code&gt;T1&lt;/code&gt; and upper bound &lt;code&gt;T2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  G(T&amp;lt;T1&amp;gt;)     = G(T)
  G(A[T1, T2]) = G(T1)
  G(T)         = T      otherwise&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If generic-type erasure results in a type mismatch (e.g., in &lt;code&gt;sBox.get().charAt(0)&lt;/code&gt; above),  the compiler inserts a cast. The inserted casts led to the runtime error in the previous example, and  provide the following run-time guarantee:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;if &lt;code&gt;e&lt;/code&gt; is an expression with static type &lt;code&gt;T&lt;/code&gt; that evaluates to a value &lt;code&gt;v&lt;/code&gt;,&lt;/li&gt;
 &lt;li&gt;then &lt;code&gt;v&lt;/code&gt; is guaranteed to match the (bytecode) type &lt;code&gt;G(T)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="discussion"&gt;Discussion&lt;/h2&gt;

&lt;p&gt;TypeScript, Reticulated Python, and Java 1.5.0 each improved the type system  of an existing language, but maintained backwards compatibility with existing  code. The name &lt;a href="http://drops.dagstuhl.de/opus/volltexte/2017/7120/"&gt;migratory typing&lt;/a&gt;  describes this kind of language extension.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;Gradual typing&lt;/a&gt; is a similar; a gradual type system starts with a statically-typed language and adds dynamic typing in a principled way (&lt;a href="https://pleiad.cl/papers/2016/garciaAl-popl2016.pdf"&gt;example&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The TypeScript team had a choice between erasing types and enforcing types. They chose to erase types and run all code (typed or untyped) at the level  of JavaScript. (Some TypeScript &lt;a href="https://lorefnon.tech/2018/03/25/typescript-and-validations-at-runtime-boundaries/"&gt;libraries&lt;/a&gt;, however, can enforce some types.)&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;TypeScript is not the only erasure language, nor is it the first. The oldest (I think) is &lt;a href="http://www.softwarepreservation.org/projects/LISP/maclisp_family/"&gt;MACLISP&lt;/a&gt;. For an erasure manifesto, see &lt;a href="http://bracha.org/pluggableTypesPosition.pdf"&gt;Pluggable Type Systems&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The Reticulated team faced a similar choice, and chose to enforce the top-level  shape of values in typed code (&lt;a href="http://homes.sice.indiana.edu/mvitouse/papers/popl17.pdf"&gt;POPL 2017&lt;/a&gt;). It will be interesting to see if this guarantee helps developers maintain programs,  or if it is too shallow to be much use. The &lt;a href="https://www.pyret.org/index.html"&gt;Pyret&lt;/a&gt; language has been successful with  a similar, shallow approach.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: the POPL 2017 paper advertises an &amp;ldquo;open-world soundness&amp;rdquo;, but I do not see how this idea is different from the older idea of soundness in a multi-language system (&lt;a href="https://www.eecs.northwestern.edu/~robby/pubs/papers/toplas09-mf.pdf"&gt;TOPLAS 2009&lt;/a&gt;, &lt;a href="https://www2.ccs.neu.edu/racket/pubs/dls06-tf.pdf"&gt;DLS 2006&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The Java team faced a &lt;em&gt;different&lt;/em&gt; choice because the Java Virtual Machine is  a typed programming language. The casts around type-erased generics provide a minimal level of safety  &amp;mdash; without casts, use of a generic object might corrupt the state of a VM instance. Nevertheless, the implementation of generic-type erasure + cast insertion  is very similar to Reticulated&amp;rsquo;s implementation of stronger guarantees for Python.&lt;/p&gt;

&lt;p&gt;Alternatively, Java could enforce generic types at run-time. Over the years there have been a few proposals to do so (&lt;a href="http://gafter.blogspot.com/2006/11/reified-generics-for-java.html"&gt;example 1&lt;/a&gt;,  &lt;a href="https://wiki.openjdk.java.net/display/valhalla/Main"&gt;example 2&lt;/a&gt;). The C# language has a similar type system and does enforce  generics at run-time (sources:  &lt;a href="https://mattwarren.org/2018/03/02/How-generics-were-added-to-.NET/"&gt;blog post&lt;/a&gt;,  &lt;a href="https://www.microsoft.com/en-us/research/publication/design-and-implementation-of-generics-for-the-net-common-language-runtime/"&gt;PLDI 2001 paper&lt;/a&gt;,  &lt;a href="https://dl.acm.org/citation.cfm?doid=378795.378797"&gt;backup link to paper&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id="acknowledgments"&gt;Acknowledgments&lt;/h2&gt;

&lt;p&gt;Thank you to &lt;a href="https://github.com/rmculpepper"&gt;Ryan Culpepper&lt;/a&gt; and &lt;a href="http://users.eecs.northwestern.edu/~jesse/"&gt;Jesse Tov&lt;/a&gt; for noticing the similarity between  Java&amp;rsquo;s generic-type erasure and transient migratory typing.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Turnstile Mailing List</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/11/30/turnstile-mailing-list/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-11-30-turnstile-mailing-list</id>
  <published>2018-11-30T14:55:30Z</published>
  <updated>2018-11-30T14:55:30Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;&lt;a href="https://docs.racket-lang.org/turnstile/The_Turnstile_Guide.html"&gt;Turnstile&lt;/a&gt; now has a mailing list: &lt;a href="https://groups.google.com/forum/#!forum/turnstile-users"&gt;https://groups.google.com/forum/#!forum/turnstile-users&lt;/a&gt;&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;There is also a &lt;code&gt;#turnstile&lt;/code&gt; channel on &lt;a href="https://racket.slack.com"&gt;the Racket Slack&lt;/a&gt;.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Disappearing Code</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/11/24/disappearing-code/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-11-24-disappearing-code</id>
  <published>2018-11-24T09:52:58Z</published>
  <updated>2018-11-24T09:52:58Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;Two experiences at &lt;a href="https://2018.splashcon.org/home"&gt;SPLASH 2018&lt;/a&gt; reminded me that software gets thrown away and replaced.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h3 id="story-1"&gt;Story 1&lt;/h3&gt;

&lt;p&gt;The first reminder came near the end of a &lt;a href="https://conf.researchr.org/event/sle-2018/papers-a-new-approach-for-software-correctness-and-reliability"&gt;talk&lt;/a&gt; by  &lt;a href="https://people.csail.mit.edu/rinard/"&gt;Martin Rinard&lt;/a&gt;. Once upon a time, Martin was working as a consultant and a firm asked him to  review a software package. (The firm wanted a second opinion about how the software computed its results.) The firm sent a zipfile; Martin found six versions of the code inside; the  firm said &amp;ldquo;well, please check all six versions&amp;rdquo;; and it turned out:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;strong&gt;Version 1&lt;/strong&gt; : the source code was written in a domain-specific language  (DSL) that generated code for the application&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Version 2&lt;/strong&gt; : the DSL source was the same as version 1, but the generated  code was slightly modified&lt;/li&gt;
 &lt;li&gt;&amp;hellip;&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Version 6&lt;/strong&gt; : the generated code was the source code and the DSL was gone&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The moral of Martin&amp;rsquo;s story was:   (1) the creators of a software system are often different from the maintainers,  and (2) researchers need to build tools to help these maintainers.&lt;/p&gt;

&lt;h3 id="story-2"&gt;Story 2&lt;/h3&gt;

&lt;p&gt;The second reminder came from a teaching assistant who said the  &lt;a href="https://www.cs.cornell.edu/courses/cs3110/2018fa/"&gt;functional programming course&lt;/a&gt;  at their institution was currently using a Python script  to test students&amp;rsquo; code. Once upon a time, I was a teaching assistant for the  &lt;a href="https://www.cs.cornell.edu/courses/cs3110/2014sp/"&gt;same course&lt;/a&gt; at the same  institution. We had trouble testing students&amp;rsquo; code via the Python script  left by the pre&amp;ndash;2013 course staff, so I wrote a  &lt;a href="https://gitlab.com/bengreenman/ocaml_tools/"&gt;command-line tool&lt;/a&gt; to handle the tests and other  compile/run/grade tasks. To keep history from repeating itself, I used the same language the course  teaches (OCaml) and wrote some documentation &amp;mdash; but it seems like that was  not enough. At any rate, writing the tool was a good exercise.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;In the end, everybody must understand for himself.&lt;/em&gt; &amp;mdash; &lt;a href="https://dl.acm.org/citation.cfm?id=3731"&gt;Per Martin-Löf&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="reflection"&gt;Reflection&lt;/h3&gt;

&lt;p&gt;In each story, the maintainers of a software system threw away some old  code to make their job easier in the short term. How can we stop this &amp;ldquo;re-inventing the wheel&amp;rdquo; from happening?&lt;/p&gt;

&lt;p&gt;Martin Rinard&amp;rsquo;s solution is to let maintenance programmers keep their current  habits, but provide tools to make the short-term, pragmatic solutions into a  more robust systems. Search for "&lt;a href="https://people.csail.mit.edu/rinard/paper/osdi04.pdf"&gt;failure-oblivious computing&lt;/a&gt;"  to learn more (this was the topic of his &lt;a href="https://conf.researchr.org/event/sle-2018/papers-a-new-approach-for-software-correctness-and-reliability"&gt;talk&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In Story 1, the maintainers were able to avoid the DSL by modifying an  inherited blob of DSL-generated code. If the DSL did not generate code, history might have taken a different course;  it might be best to start with a language that offers tools for linguistic  re-use, and to build a DSL from these tools &amp;mdash; so there is no generated code. The Racket programming language is exploring this path. For a recent example, see the &lt;a href="https://www2.ccs.neu.edu/racket/pubs/icfp17-acf.pdf"&gt;video-lang paper&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Story 2 test harness, however, was not generating code. Its maintainers discarded a &amp;ldquo;big&amp;rdquo; program written in a typed  functional language in favor of a script. Perhaps we need a language that allows mixing statically-typed and  dynamically-typed code (shouts out to  &lt;a href="https://www2.ccs.neu.edu/racket/pubs/icfp18-gf.pdf"&gt;my own research&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The best solution is probably to start with a team and keep the culture alive. Always pair program!&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id="addendum-comment-from-mitch-wand"&gt;Addendum: comment from Mitch Wand&lt;/h4&gt;

&lt;blockquote&gt;
 &lt;p&gt;The best solution is probably to start with a team and keep the culture alive. Always pair program!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ermm, this works better for sourdough bread than for people.&lt;/p&gt;

&lt;p&gt;Even in the not-so-real world of checking student solutions, there&amp;rsquo;s often no way of guaranteeing that one half of a pair will be around for the second round. They may be on co-op. Or the course will not be offered the next semster/year/etc. Or the course will change at the next offering (from OCaml to Python or from Racket to Java) so that large chunks of the infrastructure will have to be discarded or rewritten.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;real&amp;rdquo; solution is to write literate code (as we preached incessantly in PDP), so that the next reader will have at least some clue as about what you wrote. This just may be sufficient incentive to modify rather than rebuild from scratch.&lt;/p&gt;

&lt;p&gt;Ever the optimist, &amp;mdash;Mitch&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Defining Local Bindings in Turnstile Languages</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/10/22/defining-local-bindings-in-turnstile-languages/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-10-22-defining-local-bindings-in-turnstile-languages</id>
  <published>2018-10-22T15:05:17Z</published>
  <updated>2018-10-22T15:05:17Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;In &lt;a href="http://racket-lang.org/"&gt;Racket&lt;/a&gt;, programmers can create powerful abstractions by bundling together a family of values, functions, and syntax extensions in the form of a new language. These languages, however, are typically untyped. &lt;a href="http://docs.racket-lang.org/turnstile/The_Turnstile_Guide.html"&gt;Turnstile&lt;/a&gt; is a new Racket {library,language} for creating typed languages by integrating type checking with Racket&amp;rsquo;s existing tools for describing languages. The technique is described by fellow PRL&amp;rsquo;ers in the paper &lt;a href="http://www.ccs.neu.edu/home/stchang/pubs/ckg-popl2017.pdf"&gt;&lt;em&gt;Type Systems as Macros&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Racket encourages language developers to take full advantage of &lt;a href="https://scholarship.rice.edu/handle/1911/17993"&gt;linguistic reuse&lt;/a&gt; by defining new language forms in terms of existing constructs. Unsurprisingly, language extensions often retain some of the Racket-y flavor from the underlying constructs. Implementors save time and energy while users of the language benefit from the familiarity they already have with the Racket ecosystem.&lt;/p&gt;

&lt;p&gt;Unfortunately, Turnstile does not lend itself to expressing one of Racket&amp;rsquo;s most ubiquitous idioms: naming local bindings with &lt;code&gt;define&lt;/code&gt;. Early experience reports from Turnstile, including my own, suggest that language implementors very much desire to include &lt;code&gt;define&lt;/code&gt;-like binding forms in their languages.&lt;/p&gt;

&lt;p&gt;This blog post provides a brief overview of what Turnstile is and how it works, an introduction to defining typed language forms, and how to equip these languages with a &lt;code&gt;define&lt;/code&gt; binding form.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;The code for this blog post can be found &lt;a href="https://gist.github.com/howell/e2d4501e24db503e4cd9aa368172a502"&gt;in this gist&lt;/a&gt;. To run it, you will need the Turnstile package, which can be installed with &lt;code&gt;raco pkg install
turnstile&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="turnstile-typechecking-intertwined-with-elaboration"&gt;Turnstile: Typechecking Intertwined with Elaboration&lt;/h2&gt;

&lt;p&gt;Turnstile provides a convenient way of defining syntax transformations that also perform typechecking. Since processing the syntax of a form typically involves some amount of analysis, such as for error checking, it is a natural place to put the logic for typechecking. With forms defined as such, macro expanding a program determines both a type and an elaborated term in the target language.&lt;/p&gt;

&lt;p&gt;While macro expansion proceeds outside-in, type information typically flows up from the leaves of the AST during checking. To reconcile the two directions, Turnstile language forms invoke the macro expander on subexpressions when their types are needed for the current rule. This expansion yields both the elaboration of the term and its type, or fails with an error. Turnstile abstracts over the process of invoking the expander on subterms, allowing implementors to describe the language in terms of high-level type checking and elaboration specifications.&lt;/p&gt;

&lt;h2 id="type--elaboration-rules"&gt;Type &amp;amp; Elaboration Rules&lt;/h2&gt;

&lt;p&gt;To get a feel for defining language forms in Turnstile, this section walks through the core of a simply-typed functional language.&lt;/p&gt;

&lt;h3 id="functions"&gt;Functions&lt;/h3&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-type-constructor&lt;/span&gt; &lt;span class="err"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._~e2~86~92))" style="color: inherit"&gt;→&lt;/a&gt;&lt;/span&gt; &lt;span class="kd"&gt;#:arity&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3e~3d))" style="color: inherit"&gt;&amp;gt;=&lt;/a&gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-typed-syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&lt;a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._~ce~bb))" style="color: inherit"&gt;λ&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#(form._((lib._syntax/parse..rkt)._~7edatum))" style="color: inherit"&gt;~datum&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_in:type&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;x-&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_in&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;norm&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_out&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="nv"&gt;-------------------------------------------------&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;%plain-lambda-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;x-&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._~e2~86~92))" style="color: inherit"&gt;→&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_in&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;norm&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_out&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Looking at this item by item, we see:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;&lt;code&gt;define-type-constructor&lt;/code&gt; creates a new type. Here, we say the &lt;code&gt;→&lt;/code&gt; requires  at least one parameter.&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;define-typed-syntax&lt;/code&gt; is the primary way to define a language form in terms  of its syntactic shape, how it is type checked, the target language term it  expands to, and its type.&lt;/li&gt;
 &lt;li&gt;The next part is a &lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html"&gt;syntax-pattern&lt;/a&gt; describing the the shape of  the syntax this rule applies to. In this case, we&amp;rsquo;re defining &lt;code&gt;λ&lt;/code&gt; as a macro  that expects a parenthesized sequence of identifier-colon-type triples,  describing the formal arguments to the procedure, followed by the body &lt;code&gt;e&lt;/code&gt;. The  &lt;code&gt;type&lt;/code&gt; &lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html"&gt;syntax class&lt;/a&gt; is provided by Turnstile, and describes the surface  syntax of types (such as those created with &lt;code&gt;define-type-constructor&lt;/code&gt;);  internal operations over types use the expanded version of the type, which is  accessed via the &lt;code&gt;norm&lt;/code&gt; attribute.&lt;/li&gt;
 &lt;li&gt;The chevron &lt;code&gt;≫&lt;/code&gt; on the first line signifies that there is only one case in  this type rule. Some rules, which we will see later, use multiple  cases to check different kinds of uses.&lt;/li&gt;
 &lt;li&gt;The body of the rule is a sequence of premises, that usually check and  analyze the types of sub-expressions, followed by a dashed line, and  then the conclusion, describing the output syntax and its type.&lt;/li&gt;
 &lt;li&gt;Here, the single premise describes how to check the body of the function. The  context, which associates variables with types, goes to the left of the  turnstile (&lt;code&gt;⊢&lt;/code&gt;). For each formal &lt;code&gt;x&lt;/code&gt;, this lets us know what type &lt;code&gt;x&lt;/code&gt; has  when we find a reference to it in &lt;code&gt;e&lt;/code&gt;. In this rule, we are saying &amp;ldquo;while  checking the right-hand-side, assume &lt;code&gt;x&lt;/code&gt;&amp;mdash;which elaborates to  &lt;code&gt;x-&lt;/code&gt;&amp;mdash;has type &lt;code&gt;τ_in&lt;/code&gt;, for each triple in the input syntax (signified by the  ellipses &lt;code&gt;...&lt;/code&gt;)&amp;rdquo;. More on the &amp;ldquo;elaborates to &lt;code&gt;x-&lt;/code&gt;&amp;rdquo; below.&lt;/li&gt;
 &lt;li&gt;To the right of the turnstile, we write the expression we are checking, &lt;code&gt;e&lt;/code&gt;,  and patterns &lt;code&gt;e-&lt;/code&gt; and &lt;code&gt;τ_out&lt;/code&gt; matching the elaboration of &lt;code&gt;e&lt;/code&gt; and its type,  respectively.&lt;/li&gt;
 &lt;li&gt;After the dashes comes the conclusion, which begins with &lt;code&gt;⊢&lt;/code&gt;. The next part  specifies the elaboration of the term. Here, the meaning of the typed &lt;code&gt;λ&lt;/code&gt; is  given in terms of Racket&amp;rsquo;s &lt;a href="http://docs.racket-lang.org/reference/lambda.html?q=%23%25plain-lambda#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~23~25plain-lambda%29%29"&gt;&lt;code&gt;#%plain-lambda&lt;/code&gt;&lt;/a&gt;. Turnstile uses the  convention of a &lt;code&gt;-&lt;/code&gt; suffix for forms in the untyped/target language to avoid  conflicting names and confusion. Suffixed names are usually bound using  &lt;code&gt;postfix-in&lt;/code&gt;, such as in &lt;code&gt;(require (postfix-in - racket/base))&lt;/code&gt; to bind  &lt;code&gt;#%plain-lambda-&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Finally, we give the type of the term to the right of the &lt;code&gt;⇒&lt;/code&gt;, referring to  pattern variables bound in the premises.&lt;/li&gt;&lt;/ol&gt;

&lt;h4 id="renaming-typed-variables"&gt;Renaming Typed Variables&lt;/h4&gt;

&lt;p&gt;Turnstile lets the Racket expander take care of the details of variable scope, shadowing, etc. To associate identifier &lt;code&gt;x&lt;/code&gt; with type &lt;code&gt;τ&lt;/code&gt;, Turnstile binds &lt;code&gt;x&lt;/code&gt; to a macro that knows &lt;code&gt;τ&lt;/code&gt; when it expands. References to &lt;code&gt;x&lt;/code&gt; now become references to that macro, and expanding them provides access to &lt;code&gt;τ&lt;/code&gt;. Concretely, the underlying Racket code implementing this behavior looks roughly like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit"&gt;let&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;x-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;assign-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/syntax-util.html#(def._((lib._racket/syntax..rkt)._generate-temporary))" style="color: inherit"&gt;generate-temporary&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let-syntax))" style="color: inherit"&gt;let-syntax&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._make-rename-transformer))" style="color: inherit"&gt;make-rename-transformer&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x-&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
    &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/Expanding_Top-Level_Forms.html#(def._((quote._~23~25kernel)._expand))" style="color: inherit"&gt;expand&lt;/a&gt;&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._and))" style="color: inherit"&gt;and&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;check&lt;/span&gt; &lt;span class="nv"&gt;forms&lt;/span&gt; &lt;span class="nv"&gt;that&lt;/span&gt; &lt;span class="nv"&gt;may&lt;/span&gt; &lt;span class="nv"&gt;reference&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The type &lt;code&gt;τ&lt;/code&gt; is attached as &lt;a href="http://docs.racket-lang.org/reference/stxprops.html"&gt;metadata&lt;/a&gt; for a new identifier &lt;code&gt;x-&lt;/code&gt;, which is what &lt;code&gt;x&lt;/code&gt; will transform to at any reference site. In order for this to work, &lt;code&gt;x-&lt;/code&gt; must be distinct from &lt;code&gt;x&lt;/code&gt;&amp;mdash;hence the &lt;code&gt;generate-temporary&lt;/code&gt;&amp;mdash;to avoid an infinite expansion loop.&lt;/p&gt;

&lt;h3 id="application"&gt;Application&lt;/h3&gt;

&lt;p&gt;We can define a version of &lt;code&gt;#%app&lt;/code&gt; that type checks function applications to  accompany our typed &lt;code&gt;λ&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-typed-syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;%app&lt;/span&gt; &lt;span class="nv"&gt;e_fn&lt;/span&gt; &lt;span class="nv"&gt;e_arg&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="nv"&gt;e_fn&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;e_fn-&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;~&lt;/span&gt;&lt;span class="err"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._~e2~86~92))" style="color: inherit"&gt;→&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_in&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_out&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="kd"&gt;#:fail-unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stx-length=?&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_in&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;e_arg&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;num-args-fail-msg&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'e_fn&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_in&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;e_arg&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="nv"&gt;e_arg&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;e_arg-&lt;/span&gt; &lt;span class="err"&gt;⇐&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_in&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;
  &lt;span class="nv"&gt;--------&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;%plain-app-&lt;/span&gt; &lt;span class="nv"&gt;e_fn-&lt;/span&gt; &lt;span class="nv"&gt;e_arg-&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_out&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;ol&gt;
 &lt;li&gt;The syntax pattern on the first line describes the shape of applications.&lt;/li&gt;
 &lt;li&gt;On the second line, we pattern match the result of expanding and checking  &lt;code&gt;e_fn&lt;/code&gt;, checking that it produces an arrow type. More specifically, when we defined the arrow  type &lt;code&gt;→&lt;/code&gt; above, &lt;code&gt;define-type-constructor&lt;/code&gt; also implicitly defined a &lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html?q=pattern%20expander#%28part._.Pattern_.Expanders%29"&gt;pattern  expander&lt;/a&gt; &lt;code&gt;~→&lt;/code&gt; (which uses the Racket &lt;code&gt;~&lt;/code&gt; prefix convention for syntax patterns)  that matches instances of the type.&lt;/li&gt;
 &lt;li&gt;The next clause checks that the number of provided arguments matches the  arity of the function as specified by its type.&lt;/li&gt;
 &lt;li&gt;Line 5 checks that each argument expression has the required type. Turnstile  uses &lt;a href="http://davidchristiansen.dk/tutorials/bidirectional.pdf"&gt;bidirectional typechecking rules&lt;/a&gt;, which either infer the type of a  term or checks that a term satisfies a given type. We write &lt;code&gt;⇐ τ_in&lt;/code&gt; in the  premise to switch to checking mode.&lt;/li&gt;
 &lt;li&gt;Finally, typed function application elaborates to Racket&amp;rsquo;s function application,  &lt;code&gt;#%plain-app&lt;/code&gt;, with the usual suffix, and produces type &lt;code&gt;τ_out&lt;/code&gt; for the application&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;We can try out these new typed forms on a few examples:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;code&gt;((λ ([x : Int]) (+ x 1)) 2)&lt;/code&gt; successfully typechecks and yields &lt;code&gt;3&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;((λ ([x : Int]) (+ x 1)))&lt;/code&gt; raises an error based on the check on lines 3 and  4 in the rule: "#%app: (λ ((x : Int)) (+ x 1)): wrong number of arguments: expected  1, given 0."&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;((λ ([x : (→ Int Int)]) (x 1)) 2)&lt;/code&gt; raises an error: "#%app: type mismatch:  expected (→ Int Int), given Int" as a consequence of using checking mode on  line 5 of the rule.&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="extending-our-language-with-local-bindings"&gt;Extending Our Language with Local Bindings&lt;/h2&gt;

&lt;p&gt;When writing functional programs, we often want to name various sub-computations. One way to do that is with a &lt;code&gt;let&lt;/code&gt; construct, which Turnstile allows us to easily create:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-typed-syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit"&gt;let&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;x:id&lt;/span&gt; &lt;span class="nv"&gt;e-x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;e-body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="nv"&gt;e-x&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;e-x-&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;-x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;x-&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;-x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="nv"&gt;e-body&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;e-body-&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;-body&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="nv"&gt;-------------------------------------&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;let-&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;x-&lt;/span&gt; &lt;span class="nv"&gt;e-x-&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;e-body-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;-body&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Unsurprisingly, this looks very similar to the definition of &lt;code&gt;λ&lt;/code&gt; above. Now we can write functions with named intermediate results:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&lt;a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._~ce~bb))" style="color: inherit"&gt;λ&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit"&gt;let&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;almost-there&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost-there&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;However, in Racket it&amp;rsquo;s common to name such intermediate results using &lt;code&gt;define&lt;/code&gt; rather than &lt;code&gt;let&lt;/code&gt;. In fact, it&amp;rsquo;s &lt;a href="https://docs.racket-lang.org/style/Choosing_the_Right_Construct.html#%28part._.Definitions%29"&gt;prescribed by the style guide&lt;/a&gt;. Naturally, we would like to do so in our Racket language extension as well, which would allow us to write the above function as:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&lt;a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._~ce~bb))" style="color: inherit"&gt;λ&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost-there&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost-there&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Unfortunately, this is not nearly as easy to do in Turnstile as &lt;code&gt;let&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="sequences"&gt;Sequences&lt;/h2&gt;

&lt;p&gt;At first glance, the issue seems to be that the definition of &lt;code&gt;λ&lt;/code&gt; above limits the body to be a single expression when what we want to put there is a sequence of definitions and expressions. To reach our goal, we need to change the definition of &lt;code&gt;λ&lt;/code&gt; to allow its body to be a sequence.&lt;/p&gt;

&lt;p&gt;The first step is to create a typed form for sequences of definitions and expressions, which can then be used by rules like &lt;code&gt;λ&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-typed-syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;-final&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stx-last&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="nv"&gt;-----------------------------------&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;begin-&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;-final&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;This directs type checking to:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Check each &lt;code&gt;e&lt;/code&gt; in the sequence individually, obtaining an expanded &lt;code&gt;e-&lt;/code&gt; and  inferred type &lt;code&gt;τ&lt;/code&gt; for each.&lt;/li&gt;
 &lt;li&gt;Take the last type in the sequence and call it &lt;code&gt;τ-final&lt;/code&gt;; Turnstile allows  using &lt;code&gt;syntax-parse&lt;/code&gt; &lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html?#%28tech._pattern._directive%29"&gt;directives&lt;/a&gt; such as &lt;code&gt;#:with&lt;/code&gt; as premises.&lt;/li&gt;
 &lt;li&gt;Expand to Racket&amp;rsquo;s &lt;code&gt;begin&lt;/code&gt; (with the usual &lt;code&gt;-&lt;/code&gt; suffix) and give the whole  expression the type of the last term in the body.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Now, we can use &lt;code&gt;begin&lt;/code&gt; in a revised definition of &lt;code&gt;λ&lt;/code&gt;. The new rule takes a non-empty sequence of forms in the body and wraps them in our new &lt;code&gt;begin&lt;/code&gt; form for typechecking.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-typed-syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&lt;a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._~ce~bb))" style="color: inherit"&gt;λ&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#(form._((lib._syntax/parse..rkt)._~7edatum))" style="color: inherit"&gt;~datum&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_in:type&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;x-&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_in&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;norm&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_out&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="nv"&gt;-------------------------------------------------&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;%plain-lambda-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;x-&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._~e2~86~92))" style="color: inherit"&gt;→&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_in&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;norm&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;_out&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Now we need a way to include definitions in these sequences and we&amp;rsquo;re set!&lt;/p&gt;

&lt;h2 id="the-difficulty-with-define"&gt;The Difficulty With Define&lt;/h2&gt;

&lt;p&gt;If we think about how type information is communicated between a binder and its reference we can see why &lt;code&gt;define&lt;/code&gt; is a different beast than &lt;code&gt;let&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(let ([x 5]) (+ x 1))
       ^        ^
       |        |- TO HERE
FROM HERE&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the rule for our &lt;code&gt;let&lt;/code&gt; is invoked, it has access to both the binding sites and the place where references may occur. The situation lends itself to a straightforward implementation strategy: create an environment of identifier/type associations to use when analyzing the body. Turnstile directly accommodates this scenario in its language for creating type rules with the optional context appearing on the left of the &lt;code&gt;⊢&lt;/code&gt;, as in our rules for &lt;code&gt;λ&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; above.&lt;/p&gt;

&lt;p&gt;Define is different.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define x 5)
        ^
        |------ TO WHERE?
FROM HERE&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is apparent: we can&amp;rsquo;t see where the reference to &lt;code&gt;x&lt;/code&gt; occurs! The information about the binding needs to escape from the &lt;code&gt;define&lt;/code&gt; to the surrounding context. In other words, when we implement &lt;code&gt;define&lt;/code&gt;, we don&amp;rsquo;t have a body term available that contains all the possible references. Instead, we will have to find a way of communicating the existence of the &lt;code&gt;x&lt;/code&gt; binding and its type to the surrounding context.&lt;/p&gt;

&lt;p&gt;Above, in the subsection on &amp;ldquo;Renaming Typed Variables&amp;rdquo;, we saw that the context in Turnstile type rules is implemented as syntax transformers with &lt;code&gt;let&lt;/code&gt;-like scope (created with &lt;code&gt;let-syntax&lt;/code&gt;). One idea would be to mimic this approach, but instead of using &lt;code&gt;let-syntax&lt;/code&gt; to achieve &lt;code&gt;let&lt;/code&gt;-like scope, use &lt;code&gt;define-syntax&lt;/code&gt; to achieve &lt;code&gt;define&lt;/code&gt;-like scope.&lt;/p&gt;

&lt;p&gt;Fortunately for us, someone has already tried their hand at writing a &lt;code&gt;define&lt;/code&gt; form for Turnstile languages using a &lt;code&gt;define-syntax&lt;/code&gt; rename, found in the &lt;a href="https://github.com/stchang/macrotypes/blob/c5b663f7e663c564cb2baf0e0a352d5fde4d2bd7/turnstile/examples/ext-stlc.rkt#L55"&gt;Turnstile examples&lt;/a&gt;. We can take that as our starting point:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-base-type&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Void))" style="color: inherit"&gt;Void&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-&lt;/span&gt; &lt;span class="nv"&gt;a-deep-dark-void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;%app-&lt;/span&gt; &lt;span class="nv"&gt;void-&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-typed-syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x:id&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="nv"&gt;x-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;assign-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/syntax-util.html#(def._((lib._racket/syntax..rkt)._generate-temporary))" style="color: inherit"&gt;generate-temporary&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt; &lt;span class="kd"&gt;#:wrap?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;-----------------------------------------------------&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;begin-&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/syntax/transformer-helpers.html#(def._((lib._syntax/transformer..rkt)._make-variable-like-transformer))" style="color: inherit"&gt;make-variable-like-transformer&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'x-&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-&lt;/span&gt; &lt;span class="nv"&gt;x-&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="nv"&gt;a-deep-dark-void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Void))" style="color: inherit"&gt;Void&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Let&amp;rsquo;s break it down.&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Create a new type, &lt;code&gt;Void&lt;/code&gt;, to assign definitions.&lt;/li&gt;
 &lt;li&gt;Create a constant to serve as the canonical value of type &lt;code&gt;Void&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Define a new typed form, &lt;code&gt;define&lt;/code&gt;, used as in &lt;code&gt;(define x e)&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Check the type of the expression &lt;code&gt;e&lt;/code&gt;, getting its  expansion &lt;code&gt;e-&lt;/code&gt; and type &lt;code&gt;τ&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Create a new name, &lt;code&gt;x-&lt;/code&gt;, and attach the type &lt;code&gt;τ&lt;/code&gt; as metadata.&lt;/li&gt;
 &lt;li&gt;Expand to Racket&amp;rsquo;s &lt;code&gt;begin&lt;/code&gt;. Unlike &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt; does not create a new  scope; definitions inside a &lt;code&gt;begin&lt;/code&gt; are also visible in the surrounding  context. That behavior is needed for scenarios like this one that expand to  multiple definitions.&lt;/li&gt;
 &lt;li&gt;Create a macro binding for &lt;code&gt;x&lt;/code&gt; that rewrites to &lt;code&gt;x-&lt;/code&gt;. By using a define-like  form, the macro has the same scoping rules as &lt;code&gt;define&lt;/code&gt;, so it will apply to  references to &lt;code&gt;x&lt;/code&gt; in the surrounding context&amp;mdash;exactly what we want. (We are  using &lt;code&gt;make-variable-like-transformer&lt;/code&gt; to avoid the special treatment the  expander gives to &lt;code&gt;rename-transformer&lt;/code&gt;s. The specifics are beyond the scope  of this post.)&lt;/li&gt;
 &lt;li&gt;Define &lt;code&gt;x-&lt;/code&gt; to refer to the supplied expression. Note that here &lt;code&gt;define-&lt;/code&gt; is  Racket&amp;rsquo;s &lt;code&gt;define&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Keep the result of evaluating this form in line with the type by yielding a  value of type &lt;code&gt;Void&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;This implementation of &lt;code&gt;define&lt;/code&gt; gets us pretty far. If we put definitions at the top-level of a module in our language, we can reference them within other terms in the module:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="c1"&gt;;; module top level&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;;=&amp;gt; 6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Unfortunately, we encounter a problem if we try to create &lt;em&gt;local&lt;/em&gt; definitions:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;add2&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&lt;a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._~ce~bb))" style="color: inherit"&gt;λ&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="c1"&gt;;;==&amp;gt; almost: unbound identifier...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Pointing to the reference on the final line. The problem is that our &lt;code&gt;define&lt;/code&gt; and &lt;code&gt;begin&lt;/code&gt; forms are not interacting in the way we might have hoped.&lt;/p&gt;

&lt;p&gt;When we expand the body of the function above, we associate &lt;code&gt;x&lt;/code&gt; with type &lt;code&gt;Int&lt;/code&gt; then start checking the body, wrapped in a &lt;code&gt;begin&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Consulting the definition of &lt;code&gt;begin&lt;/code&gt;, we see that it checks/expands each sub-expression in seqence. First in the sequence is a use of &lt;code&gt;define&lt;/code&gt;, yielding&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;begin-&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-&lt;/span&gt; &lt;span class="nv"&gt;almost-&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;a-deep-dark-void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Crucially, the expansion of our &lt;code&gt;define&lt;/code&gt; form &lt;strong&gt;stops&lt;/strong&gt; at this point, without examining the &lt;code&gt;begin-&lt;/code&gt; form and its contained definitions. The interface through which Turnstile invokes the macro expander, &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html?q=local-expand#%28def._%28%28quote._~23~25kernel%29._local-expand%29%29"&gt;&lt;code&gt;local-expand&lt;/code&gt;&lt;/a&gt;, takes a parameter referred to as the &lt;em&gt;stop list&lt;/em&gt; for stopping expansion at certain points. The stop list contains identifiers which, when encountered by the expander, halt expansion.&lt;/p&gt;

&lt;p&gt;The syntax output from typed forms created using Turnstile are wrapped with a particular macro, named &lt;code&gt;erased&lt;/code&gt;, that serves (only) to orchestrate stopping expansion. So, the output of our &lt;code&gt;define&lt;/code&gt; form actually looks like&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;erased&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;begin-&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-&lt;/span&gt; &lt;span class="nv"&gt;almost-&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;a-deep-dark-void&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;And since Turnstile includes &lt;code&gt;erased&lt;/code&gt; in the stop list for &lt;code&gt;local-expand&lt;/code&gt;, expansion stops before analyzing the rest of the output. The point of all this &lt;code&gt;erased&lt;/code&gt; business, if you are wondering, is to improve the performance of Turnstile languages by avoiding unnecessary re-expansions.&lt;/p&gt;

&lt;p&gt;Control returns to the &lt;code&gt;begin&lt;/code&gt; transformer, which turns to checking/expanding the subsequent &lt;code&gt;(+ almost 1)&lt;/code&gt;, where it will encounter the identifier &lt;code&gt;almost&lt;/code&gt; without a corresponding binding. Even though our &lt;code&gt;define&lt;/code&gt; form produced a binding as part of its output, the expander hasn&amp;rsquo;t actually analyzed it before reaching the reference in the next expression.&lt;/p&gt;

&lt;p&gt;The problem is a symptom of analyzing the sequence of forms using an ellipses, which corresponds to mapping the typechecking/expanding process over each individually. The mapping operation stipulates that checking each item is independent of checking the others. But when we add &lt;code&gt;define&lt;/code&gt; to the language that is no longer the case. A definition form influences how we typecheck its neighbors by introducing a new name and its type. This information must be communicated to the following forms in order to properly check references. That is, instead of setting up binding information and then checking, analyzing bindings must be interleaved with type checking. Unfortunately, Turnstile doesn&amp;rsquo;t provide a fold-like mechanism for threading binding information through the checking of a sequence of typed forms. We&amp;rsquo;re going to need to implement our own solution, requiring us to dive underneath the abstractions provided by Turnstile and get intimate with Racket&amp;rsquo;s syntax model.&lt;/p&gt;

&lt;h2 id="internal-definition-contexts"&gt;Internal Definition Contexts&lt;/h2&gt;

&lt;p&gt;In order for the &lt;code&gt;(+ almost 1)&lt;/code&gt; expression from above to successfully typecheck/expand, we need to be able to associate &lt;code&gt;almost&lt;/code&gt; with a suitable type. Turnstile provides a way to set up such an association, but as we saw before, Turnstile&amp;rsquo;s interface doesn&amp;rsquo;t suit this scenario.&lt;/p&gt;

&lt;p&gt;Racket has the notion of an &lt;a href="http://docs.racket-lang.org/reference/syntax-model.html?#%28tech._internal._definition._context%29"&gt;internal definition context&lt;/a&gt; that allows definitions to be mixed with expressions. The syntax system exposes tools for creating and manipulating such contexts programmatically, allowing macro writers a great deal of power for manipulating the bindings in a program.&lt;/p&gt;

&lt;p&gt;When using &lt;code&gt;local-expand&lt;/code&gt;, we can optionally pass in a definition context containing binding information. If we create a definition context for the body of the function and extend it with each definition, then &lt;code&gt;local-expand&lt;/code&gt;-ing references such as the above one should work out. Normally, Turnstile calls &lt;code&gt;local-expand&lt;/code&gt; internally in accordance with the type rules we write down, but in order to use our own definition context we&amp;rsquo;re going to have to call it ourselves.&lt;/p&gt;

&lt;p&gt;We can create a definition context with &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-make-definition-context%29%29"&gt;&lt;code&gt;syntax-local-make-definition-context&lt;/code&gt;&lt;/a&gt;, as in&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;def-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._syntax-local-make-definition-context))" style="color: inherit"&gt;syntax-local-make-definition-context&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;And then (imperatively) add bindings to &lt;code&gt;def-ctx&lt;/code&gt; with &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-bind-syntaxes%29%29"&gt;&lt;code&gt;syntax-local-bind-syntaxes&lt;/code&gt;&lt;/a&gt;. The first argument is a list of identifiers to bind; we will only be binding one identifier at a time, consequently only passing singleton lists. The second argument dictates what the given identifier &lt;em&gt;means&lt;/em&gt;. Passing &lt;code&gt;#f&lt;/code&gt; corresponds to a run-time/phase 0 binding, such as that of a procedure argument, &lt;code&gt;let&lt;/code&gt;, or &lt;code&gt;define&lt;/code&gt;; alternatively, we can provide syntax that evaluates to a function, establishing a transformer binding invoked on references to the identifier. Using both alternatives, we can define a renaming macro and give a meaning to the new name:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-for-syntax))" style="color: inherit"&gt;define-for-syntax&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;int-def-ctx-bind-type-rename!&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;x-&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._syntax-local-bind-syntaxes))" style="color: inherit"&gt;syntax-local-bind-syntaxes&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))" style="color: inherit"&gt;list&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                              &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/syntax/transformer-helpers.html#(def._((lib._syntax/transformer..rkt)._make-variable-like-transformer))" style="color: inherit"&gt;make-variable-like-transformer&lt;/a&gt;&lt;/span&gt;
                                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;assign-type&lt;/span&gt; &lt;span class="o"&gt;#'#,&lt;/span&gt;&lt;span class="nv"&gt;x-&lt;/span&gt; &lt;span class="o"&gt;#'#,&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="kd"&gt;#:wrap?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                              &lt;span class="nv"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._syntax-local-bind-syntaxes))" style="color: inherit"&gt;syntax-local-bind-syntaxes&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))" style="color: inherit"&gt;list&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="nv"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The first call binds &lt;code&gt;x&lt;/code&gt; to a transformer that renames to &lt;code&gt;x-&lt;/code&gt;; the second lets the expander know that we are taking care of making sure that &lt;code&gt;x-&lt;/code&gt; will actually be bound to something.&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;define&lt;/code&gt; form must communicate the information needed to call &lt;code&gt;int-def-ctx-bind-type-rename!&lt;/code&gt; back out to the surrounding context. One way to do this is to add an intermediate step to the expansion of &lt;code&gt;define&lt;/code&gt; that includes the necessary information as part of its syntax. Then, the surrounding context can analyze the expansion of each term, looking for that form.&lt;/p&gt;

&lt;p&gt;Concretely, &lt;code&gt;define&lt;/code&gt; will expand to &lt;code&gt;define/intermediate&lt;/code&gt;, which will in turn expand to what &lt;code&gt;define&lt;/code&gt; originally expanded to:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-typed-syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x:id&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="nv"&gt;x-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/syntax-util.html#(def._((lib._racket/syntax..rkt)._generate-temporary))" style="color: inherit"&gt;generate-temporary&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="nv"&gt;x+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._syntax-local-identifier-as-binding))" style="color: inherit"&gt;syntax-local-identifier-as-binding&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;--------------------------------------------------&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define/intermediate&lt;/span&gt; &lt;span class="nv"&gt;x+&lt;/span&gt; &lt;span class="nv"&gt;x-&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Void))" style="color: inherit"&gt;Void&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define/intermediate&lt;/span&gt; &lt;span class="nv"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#(form._((lib._syntax/parse..rkt)._syntax-parse))" style="color: inherit"&gt;syntax-parse&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;stx&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt).__))" style="color: inherit"&gt;_&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;x:id&lt;/span&gt; &lt;span class="nv"&gt;x-:id&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="nv"&gt;x-/&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;assign-type&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'x-&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt; &lt;span class="kd"&gt;#:wrap?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;begin-&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/syntax/transformer-helpers.html#(def._((lib._syntax/transformer..rkt)._make-variable-like-transformer))" style="color: inherit"&gt;make-variable-like-transformer&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'x-/&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-&lt;/span&gt; &lt;span class="nv"&gt;x-&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="nv"&gt;a-deep-dark-void&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;(The reason we create an &lt;code&gt;x+&lt;/code&gt; using &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-identifier-as-binding%29%29"&gt;&lt;code&gt;syntax-local-identifier-as-binding&lt;/code&gt;&lt;/a&gt; is &lt;a href="https://github.com/racket/racket/pull/2237"&gt;due to a bug in the expander&lt;/a&gt;. The explanation is rather involved and frankly I only barely understand what&amp;rsquo;s going on myself (if at all), so let&amp;rsquo;s just leave it at that and move on.)&lt;/p&gt;

&lt;p&gt;Then, for each form &lt;code&gt;e&lt;/code&gt; in a sequence, we can call &lt;code&gt;local-expand&lt;/code&gt; with &lt;code&gt;def-ctx&lt;/code&gt; and then check the expansion, &lt;code&gt;e-&lt;/code&gt;, for &lt;code&gt;define/intermediate&lt;/code&gt;. In those cases, we can use &lt;code&gt;int-def-ctx-bind-type-rename!&lt;/code&gt; to add it to the context. The procedure &lt;code&gt;add-bindings-to-ctx!&lt;/code&gt; performs this check on an expanded form &lt;code&gt;e-&lt;/code&gt; (remembering that Turnstile will wrap the output of &lt;code&gt;define&lt;/code&gt; in an &lt;code&gt;erased&lt;/code&gt; macro):&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-for-syntax))" style="color: inherit"&gt;define-for-syntax&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-bindings-to-ctx!&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt; &lt;span class="nv"&gt;def-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#(form._((lib._syntax/parse..rkt)._syntax-parse))" style="color: inherit"&gt;syntax-parse&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt;
        &lt;span class="kd"&gt;#:literals&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;erased&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;erased&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define/intermediate&lt;/span&gt; &lt;span class="nv"&gt;x:id&lt;/span&gt; &lt;span class="nv"&gt;x-:id&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;int-def-ctx-bind-type-rename!&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'x&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'x-&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt; &lt;span class="nv"&gt;def-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt).__))" style="color: inherit"&gt;_&lt;/a&gt;&lt;/span&gt;
         &lt;span class="c1"&gt;;; when e expands to something other than a definition there&amp;#39;s nothing to bind&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/void.html#(def._((quote._~23~25kernel)._void))" style="color: inherit"&gt;void&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;We now have the key ingredients to define a procedure, &lt;code&gt;walk/bind&lt;/code&gt;, that will serve as the primary vehicle to type check a sequence of forms, threading binding information through using a definition context. Processing sequences of defintions and expressions will iterate through them one at a time, and for each form &lt;code&gt;e&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;&lt;code&gt;local-expand&lt;/code&gt; using our internal definition context, resulting in an &lt;code&gt;e-&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Retrieve the type of &lt;code&gt;e&lt;/code&gt; from the metadata of &lt;code&gt;e-&lt;/code&gt; using Turnstile&amp;rsquo;s  &lt;a href="http://docs.racket-lang.org/turnstile/The_Turnstile_Reference.html?q=typeof#%28def._%28%28lib._turnstile%2Fmain..rkt%29._typeof%29%29"&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt; helper.&lt;/li&gt;
 &lt;li&gt;Check if &lt;code&gt;e&lt;/code&gt; defined a binding, in which case add it to the context.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Aggregating the expanded syntax and type of each form as we go along, we get&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-for-syntax))" style="color: inherit"&gt;define-for-syntax&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;walk/bind&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;def-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._syntax-local-make-definition-context))" style="color: inherit"&gt;syntax-local-make-definition-context&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;unique&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/symbols.html#(def._((quote._~23~25kernel)._gensym))" style="color: inherit"&gt;gensym&lt;/a&gt; &lt;/span&gt;&lt;span class="ss"&gt;'walk/bind&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((quote._~23~25kernel)._define-values))" style="color: inherit"&gt;define-values&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rev-e-&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;rev-&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/for.html#(form._((lib._racket/private/base..rkt)._for/fold))" style="color: inherit"&gt;for/fold&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;rev-e-&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
               &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;rev-&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()])&lt;/span&gt;
              &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nf"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/sequences.html#(def._((lib._racket/sequence..rkt)._in-syntax))" style="color: inherit"&gt;in-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;e-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._local-expand))" style="color: inherit"&gt;local-expand&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))" style="color: inherit"&gt;list&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;unique&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))" style="color: inherit"&gt;list&lt;/a&gt; &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'erased&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;def-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;typeof&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-bindings-to-ctx!&lt;/span&gt; &lt;span class="nv"&gt;e-&lt;/span&gt; &lt;span class="nv"&gt;def-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/values.html#(def._((quote._~23~25kernel)._values))" style="color: inherit"&gt;values&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))" style="color: inherit"&gt;cons&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;e-&lt;/span&gt; &lt;span class="nv"&gt;rev-e-&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))" style="color: inherit"&gt;cons&lt;/a&gt; &lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt; &lt;span class="nv"&gt;rev-&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/values.html#(def._((quote._~23~25kernel)._values))" style="color: inherit"&gt;values&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/list..rkt)._reverse))" style="color: inherit"&gt;reverse&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;rev-e-&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/list..rkt)._reverse))" style="color: inherit"&gt;reverse&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;rev-&lt;/span&gt;&lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The value &lt;code&gt;unique&lt;/code&gt; and its use as an argument is dictated by the documentation of &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html?q=local-expand#%28def._%28%28quote._~23~25kernel%29._local-expand%29%29"&gt;&lt;code&gt;local-expand&lt;/code&gt;&lt;/a&gt;: &amp;ldquo;For a particular internal-definition context, generate a unique value and put it into a list for context-v.&amp;rdquo; By using &lt;code&gt;#'erased&lt;/code&gt; in the stop list for &lt;code&gt;local-expand&lt;/code&gt;, we stop expansion at the same points that Turnstile does.&lt;/p&gt;

&lt;p&gt;Now we can implement &lt;code&gt;begin&lt;/code&gt; in terms of &lt;code&gt;walk/bind&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-typed-syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;≫&lt;/span&gt;
  &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((quote._~23~25kernel)._define-values))" style="color: inherit"&gt;define-values&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;e-&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;walk/bind&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;-final&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._last))" style="color: inherit"&gt;last&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;--------------------&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;⊢&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;begin-&lt;/span&gt; &lt;span class="o"&gt;#,@&lt;/span&gt;&lt;span class="nv"&gt;e-&lt;/span&gt;&lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;⇒&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="nv"&gt;-final&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;and voilà!&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add2&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;almost&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;;=&amp;gt; 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;h1 id="but-wait-theres-more"&gt;But Wait, There&amp;rsquo;s More&lt;/h1&gt;

&lt;p&gt;I believe this design is can be dropped in &amp;lsquo;as-is&amp;rsquo; and with a few extensions be useful for a wide variety of Turnstile languages. However, there are a few shortcomings (that I am aware of) that I will leave as exercises for the interested reader:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;The &lt;code&gt;define&lt;/code&gt; form here doesn&amp;rsquo;t provide the useful shorthand for creating  functions, &lt;code&gt;(define (f x) e ...)&lt;/code&gt;. Extending it to do so is relatively  straightforward.&lt;/li&gt;
 &lt;li&gt;Supporting &lt;em&gt;recursive&lt;/em&gt; (and mutually recursive) function definitions is a bit  more complicated, but shouldn&amp;rsquo;t require many changes to the above code.&lt;/li&gt;
 &lt;li&gt;There&amp;rsquo;s an extensibility issue&amp;mdash;macros that expand to multiple uses of  &lt;code&gt;define&lt;/code&gt; inside a &lt;code&gt;begin&lt;/code&gt; won&amp;rsquo;t work (why not?), such as&lt;/li&gt;&lt;/ul&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define/memo&lt;/span&gt; &lt;span class="nv"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#(form._((lib._syntax/parse..rkt)._syntax-parse))" style="color: inherit"&gt;syntax-parse&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;stx&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt).__))" style="color: inherit"&gt;_&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#(form._((lib._syntax/parse..rkt)._~7edatum))" style="color: inherit"&gt;~datum&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt;&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="nv"&gt;memo&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;memo&lt;/span&gt; &lt;span class="nv"&gt;table&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="err"&gt;τ&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;check&lt;/span&gt; &lt;span class="nv"&gt;memo&lt;/span&gt; &lt;span class="nv"&gt;table&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;
           &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Finally, there&amp;rsquo;s some question as to how to lift these ideas to an abstraction at the Turnstile level, so that future language authors don&amp;rsquo;t have to muck around with &lt;code&gt;syntax-local-bind-syntaxes&lt;/code&gt; and friends. If you have any ideas on this front, feel free to reach out.&lt;/p&gt;
&lt;!-- References--&gt;</content></entry>
 <entry>
  <title type="text">A Spectrum of Type Soundness and Performance</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/10/06/a-spectrum-of-type-soundness-and-performance/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-10-06-a-spectrum-of-type-soundness-and-performance</id>
  <published>2018-10-06T11:23:35Z</published>
  <updated>2018-10-06T11:23:35Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;The literature on mixed-typed languages presents (at least) three fundamentally different ways of thinking about the integrity of programs that combine  statically typed and dynamically typed code. Recently, we have been sorting them out.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: this post is an extended abstract for the paper &lt;em&gt;A Spectrum of Type  Soundness and Performance&lt;/em&gt; by Ben Greenman and Matthias Felleisen.  For the full paper, slides, code, and a video presentation, visit  &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gf-icfp-2018"&gt;http://www.ccs.neu.edu/home/types/publications/publications.html#gf-icfp-2018&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A dynamically-typed language runs any program that &amp;ldquo;looks good&amp;rdquo; (i.e.,  passes some basic syntactic criteria. In Python a program cannot mix  indentation levels. In Racket a program cannot refer to unbound variables). A statically-typed language runs any program that both &amp;ldquo;looks good&amp;rdquo; and  is well-typed according to a type checker.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;mixed-typed&lt;/em&gt; language allows some combination of static and dynamic typing. There are many languages that fall in the mixed-typed category; figure 1 lists  a few, roughly arranged left-to-right by the year they first provided a way to  mix.&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="/img/mixed-typed-systems-by-year.png" alt="Figure 1: Some mixed-typed languages" /&gt;
 &lt;p class="caption"&gt;Figure 1: Some mixed-typed languages&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;These languages all try to combine static and dynamic typing in a useful way,  but they take VERY different approaches. For example:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;strong&gt;MACLISP&lt;/strong&gt; defines a syntax for type annotations but does not say how a compiler  should interpret the types; see section 14.2 of the &lt;a href="http://www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf"&gt;Moonual&lt;/a&gt;.  For example, a compiler may use types to generate specialized code that assumes  the type annotations are correct (and has undefined behavior otherwise).&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Strongtalk&lt;/strong&gt; includes a static type checker and DOES NOT use types to change the  behavior of a program.  For rationale, see the &lt;a href="http://bracha.org/pluggableTypesPosition.pdf"&gt;Pluggable Type Systems&lt;/a&gt; position paper.&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Typed Racket&lt;/strong&gt; lets a program combine statically-typed modules and dynamically-typed  modules. The compiler inserts run-time checks at the boundaries between such  modules to detect any mismatches between the static types and incoming dynamically-typed  values.&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Thorn&lt;/strong&gt; requires that every value in a program has a type, but allows  dynamically-typed contexts to manipulate values. In other words, every Thorn  value is an instance of a statically-declared class and classes may contain  dynamically-typed methods.&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Reticulated&lt;/strong&gt; lets a program combine static and dynamic &lt;em&gt;expressions&lt;/em&gt; and  guarantees that the combination has a well-defined semantics (Vitousek, Swords, and Siek &lt;a href="https://dl.acm.org/citation.cfm?id=3009849"&gt;POPL 2017&lt;/a&gt;).&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;That makes five different systems. There are 15 other systems in the figure, and many more in the world. How can we make sense of this space? We claim: by understanding each system&amp;rsquo;s protocol for checking  dynamically-typed values at a &lt;em&gt;type boundary&lt;/em&gt; (between static and dynamic code).&lt;/p&gt;

&lt;h3 id="main-contribution"&gt;Main Contribution&lt;/h3&gt;

&lt;p&gt;In the paper &lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;&lt;em&gt;A Spectrum of Type Soundness and Performance&lt;/em&gt;&lt;/a&gt;,  we define a tiny mixed-typed language and show three ways to define the  behavior of programs &amp;mdash; based on three protocols for checking  dynamically-typed values that cross a boundary into statically-typed code.&lt;/p&gt;

&lt;p&gt;The three behaviors are inspired by existing languages. A &lt;strong&gt;higher order&lt;/strong&gt; behavior ensures that dynamically-typed  values match the static type at a boundary &amp;mdash; by checking the value when possible,  and by monitoring the value&amp;rsquo;s future interactions when necessary. A &lt;strong&gt;first order&lt;/strong&gt; behavior performs a yes-or-no check on dynamically-typed values  and never monitors their future behavior. An &lt;strong&gt;erasure&lt;/strong&gt; behavior does no checking whatsoever.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Example (monitors): if typed code expects a function from numbers to numbers and receives an untyped function &lt;code&gt;f&lt;/code&gt;, then one way to enforce the type boundary is to wrap &lt;code&gt;f&lt;/code&gt; in a proxy to assert that every future call to &lt;code&gt;f&lt;/code&gt; returns a number. In this case, the proxy monitors the behavior of &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Concretely, the paper defines three formal semantics with the same names. The &lt;strong&gt;higher-order&lt;/strong&gt; semantics enforces full types at the boundaries (Section 2.3). The &lt;strong&gt;first-order&lt;/strong&gt; semantics enforces type constructors at the boundaries, and  furthermore enforces type constructors on every &amp;ldquo;selector&amp;rdquo; operation in typed  code, e.g., function application, data structure access (Section 2.5). The &lt;strong&gt;erasure&lt;/strong&gt; semantics simply ignores the types (Section 2.4).&lt;/p&gt;

&lt;p&gt;Each semantics satisfies a &lt;em&gt;different&lt;/em&gt; notion of soundness for mixed-typed  programs, and each notion is slightly weaker than soundness for fully-typed  programs. The paper states these theorems (Section 2) and the  &lt;a href="https://repository.library.northeastern.edu/files/neu:cj82rk279"&gt;online supplement&lt;/a&gt;  gives full proofs.&lt;/p&gt;

&lt;p&gt;The paper has more to say about the meta-theory. See section 2 and section 4.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;To the best of our knowledge, this paper is the first to explicitly acknowledge that different approaches to a mixed-typed language lead to different notions of soundness. Other papers state type soundness theorems for &lt;a href="https://dl.acm.org/citation.cfm?id=2676971"&gt;subset of the language&lt;/a&gt; (in the spirit of &lt;a href="http://soundiness.org/"&gt;soundiness&lt;/a&gt;) or use the name &amp;ldquo;type soundness&amp;rdquo; to describe &lt;a href="https://dl.acm.org/citation.cfm?id=2676971"&gt;a different property&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Next, we used the three semantics as a guide to arrive at three compilers for  Typed Racket. The higher-order compiler is the standard Typed Racket. The first-order compiler is something we built, based on the semantics. The erasure compiler simply ignores the type annotations &amp;mdash; similar to Typed Racket&amp;rsquo;s  &lt;a href="http://docs.racket-lang.org/ts-reference/Typed_Racket_Syntax_Without_Type_Checking.html"&gt;no-check&lt;/a&gt; language.&lt;/p&gt;

&lt;p&gt;Using this set-up, we measured the performance of mixed-typed programs via  each compiler using the method suggested by Takikawa et. al (&lt;a href="https://www2.ccs.neu.edu/racket/pubs/popl16-tfgnvf.pdf"&gt;POPL 2016&lt;/a&gt;). The programs we measured are the non-object-oriented ones from our &lt;a href="http://docs.racket-lang.org/gtp-benchmarks/index.html"&gt;benchmark suite&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To some extent, the performance results confirm conjectures from the literature. The full results, however, include many surprises &amp;mdash; see section 3 of the paper,  section B of the &lt;a href="https://repository.library.northeastern.edu/files/neu:cj82rk279"&gt;supplement&lt;/a&gt;,  and/or the &lt;a href="http://www.ccs.neu.edu/home/types/publications/apples-to-apples/gf-icfp-2018-slides.pdf"&gt;slides&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="implications"&gt;Implications&lt;/h3&gt;

&lt;ol&gt;
 &lt;li&gt;The model in the paper is one way to understand the different approaches  to mixed-typed languages. See section 5 of the paper,  section D of the &lt;a href="https://repository.library.northeastern.edu/files/neu:cj82rk279"&gt;supplement&lt;/a&gt;,  or &lt;a href="http://www.ccs.neu.edu/home/types/publications/apples-to-apples/gf-icfp-2018-slides.pdf"&gt;slide 114&lt;/a&gt;.&lt;/li&gt;
 &lt;li&gt;Programmers using mixed-typed languages need to know what guarantees their  types provide.  (It is &lt;a href="https://twitter.com/jbandi/status/965005464638541825"&gt;not safe to assume that TypeScript types give the same guarantees as OCaml types&lt;/a&gt;!)  Section 4 of the paper contains many examples of how the different guarantees  may affect practice.&lt;/li&gt;
 &lt;li&gt;The relative performance of different approaches is more nuanced than the  literature suggests. Our paper gives a first systematic comparison based on  implementations that have clear areas for improvement. The question is:  can we find improvements that lead to asymptotic differences, or is it a  battle for constant factors?&lt;/li&gt;&lt;/ol&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: in this post, a &lt;em&gt;mixed-typed language&lt;/em&gt; is one that allows any combination of static and dynamic typing. A &lt;em&gt;gradually-typed language&lt;/em&gt; is one that allows a certain kind of mixing that satisfies properties defined by Siek, Vitousek, Cimini, and Boyland (&lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;SNAPL 2015&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;</content></entry>
 <entry>
  <title type="text">Sampling Gradual Typing Performance</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/05/08/sampling-gradual-typing-performance/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-05-08-sampling-gradual-typing-performance</id>
  <published>2018-05-08T15:37:37Z</published>
  <updated>2018-05-08T15:37:37Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;This post explains the sampling method introduced in the paper &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gm-pepm-2018"&gt;&lt;em&gt;On the Cost of Type-Tag Soundness&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="quick-reference-how-to-apply-the-method"&gt;Quick Reference: How to apply the method&lt;/h2&gt;

&lt;ol&gt;
 &lt;li&gt;Find an untyped program, measure its running time.&lt;/li&gt;
 &lt;li&gt;Define a &lt;em&gt;granularity&lt;/em&gt; for type annotations (by-function, by-module, by-program, &amp;hellip;.).&lt;/li&gt;
 &lt;li&gt;Define a sample size &lt;strong&gt;s&lt;/strong&gt; and number of samples &lt;strong&gt;r&lt;/strong&gt;.&lt;/li&gt;
 &lt;li&gt;Randomly select &lt;strong&gt;s&lt;/strong&gt; &lt;em&gt;configurations&lt;/em&gt; uniformly at random, measure their running time.&lt;/li&gt;
 &lt;li&gt;Repeat the previous step &lt;strong&gt;r&lt;/strong&gt; times.&lt;/li&gt;
 &lt;li&gt;Pick a positive real number &lt;strong&gt;D&lt;/strong&gt;.&lt;/li&gt;
 &lt;li&gt;Count the proportion of configurations in each sample with running time less-than-or-equal-to &lt;strong&gt;D&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;Build a 95% confidence interval for the &lt;strong&gt;r&lt;/strong&gt; proportions computed in the previous step&lt;/li&gt;
 &lt;li&gt;Conclusion: there is a good chance that your interval contains the true proportion of configurations with running time less-than-or-equal-to &lt;strong&gt;D&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;h2 id="background-what-to-measure"&gt;Background: what to measure&lt;/h2&gt;

&lt;p&gt;A migratory typing system adds static typing to a dynamically-typed (or, untyped) language. The recipe for &amp;ldquo;adding static typing&amp;rdquo; has a few steps:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;add a syntax for type annotations&lt;/li&gt;
 &lt;li&gt;add a static type checker&lt;/li&gt;
 &lt;li&gt;add a semantics for statically-typed parts of the program&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;If the semantics for statically-typed parts of the program is &lt;strong&gt;not&lt;/strong&gt; the same  as the semantics for dynamically-typed parts, then it is important to measure  performance.&lt;/p&gt;

&lt;p&gt;The key question is: how does adding type annotations affect the  running time of a working program? We do not know how to answer this question directly.&lt;/p&gt;

&lt;p&gt;An easier question, that we can answer, is: for a few programs each with  one full set of type annotations, how does adding or removing the chosen type  annotations affect the running time of these programs?&lt;/p&gt;

&lt;p&gt;The next two sections give two methods for answering this question.&lt;/p&gt;

&lt;h2 id="exhaustive-method"&gt;Exhaustive Method&lt;/h2&gt;

&lt;p&gt;One way to answer our easier question is to remove type annotations one  &amp;ldquo;unit&amp;rdquo; at a time and measure the running time of all these partially-typed  programs. We call the &amp;ldquo;unit&amp;rdquo; the &lt;em&gt;granularity&lt;/em&gt; of the performance evaluation. For example, some choices for granularity are to remove types one module  at a time, to remove types one function at a time, or to remove types  one variable at a time. We call the &amp;ldquo;partially-typed programs&amp;rdquo; the &lt;em&gt;configurations&lt;/em&gt; of the original  dynamically-typed program. Note that the number of configurations depends on the choice of granularity  &amp;mdash; I can&amp;rsquo;t just use the word &lt;em&gt;configurations&lt;/em&gt; without telling you the  granularity I have in mind.&lt;/p&gt;

&lt;p&gt;After measuring the running time of all configurations, we can summarize the  results. One way to summarize is to pick a number &lt;strong&gt;D&lt;/strong&gt; and count the number of configurations  that run at most &lt;strong&gt;D&lt;/strong&gt; times slower than the original dynamically-typed program. If this number is large, then the takeaway is:  if &lt;em&gt;you&lt;/em&gt; are willing to accept at most a &lt;strong&gt;D&lt;/strong&gt;x slowdown, and you add your  own type annotations to your own program, then there&amp;rsquo;s some hope that your  configuration runs at most &lt;strong&gt;D&lt;/strong&gt; times slower than your original program.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Credit for the exhaustive method: &lt;a href="https://www2.ccs.neu.edu/racket/pubs/popl16-tfgnvf.pdf"&gt;&lt;em&gt;Is Sound Gradual Typing Dead?&lt;/em&gt;&lt;/a&gt; and &lt;a href="https://www2.ccs.neu.edu/racket/pubs/ecoop2015-takikawa-et-al.pdf"&gt;&lt;em&gt;Toward Practical Gradual Typing&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id="simple-random-approximation-method"&gt;Simple Random Approximation Method&lt;/h2&gt;

&lt;p&gt;The method above does not scale to large programs or fine granularities  because it asks for an exponential number of measurements. E.g., if there are 20 units to add or remove types from, then there are 1 million  configurations to measure. Exponentials are bad.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gm-pepm-2018"&gt;&lt;em&gt;On the Cost of Type-Tag Soundness&lt;/em&gt;&lt;/a&gt;,  suggests a method based on simple random sampling that answers a similar question. Instead of measuring the true proportion of configurations that run at most  &lt;strong&gt;D&lt;/strong&gt; times slower than the original dynamically-typed program, we:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;pick a sample size &lt;strong&gt;s&lt;/strong&gt; (in the paper, we used &lt;strong&gt;s = 10M&lt;/strong&gt; where &lt;strong&gt;M&lt;/strong&gt; is the number of units),&lt;/li&gt;
 &lt;li&gt;pick a number of samples &lt;strong&gt;r&lt;/strong&gt; (in the paper, we used &lt;strong&gt;r = 10&lt;/strong&gt;),&lt;/li&gt;
 &lt;li&gt;and build a 95% confidence interval for the true proportion of configurations  that run at most &lt;strong&gt;D&lt;/strong&gt; times slower than the original program (from the  &lt;strong&gt;r&lt;/strong&gt; proportions of configurations that run at most &lt;strong&gt;D&lt;/strong&gt; times slower than the  original program in each of the &lt;strong&gt;r&lt;/strong&gt; samples).&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The method is outlined above, described in the paper, and validated in that paper&amp;rsquo;s appendix. Please let us know if you have more questions.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Maybe you&amp;rsquo;re wondering, &amp;ldquo;gee why do they keep writing out &amp;lsquo;configurations that  run at most &amp;hellip;.&amp;rsquo; instead of something shorter?&amp;rdquo;. Well, the short version is &lt;em&gt;&lt;strong&gt;D&lt;/strong&gt;-deliverable&lt;/em&gt; and it was introduced in the &lt;a href="https://www2.ccs.neu.edu/racket/pubs/popl16-tfgnvf.pdf"&gt;&lt;em&gt;Is Sound Gradual Typing Dead?&lt;/em&gt;&lt;/a&gt; paper. Unfortunately, (1) that paper instantiated &lt;strong&gt;D&lt;/strong&gt; to &lt;strong&gt;3&lt;/strong&gt;-deliverable in order to  explain a few graphs and (2) at least two published papers (&lt;a href="https://dl.acm.org/citation.cfm?id=3009849"&gt;paper 1&lt;/a&gt;, &lt;a href="https://dl.acm.org/citation.cfm?id=3133878"&gt;paper 2&lt;/a&gt;)  now cite us as saying &lt;strong&gt;3&lt;/strong&gt;x overhead is the cutoff between a good migratory  typing system and a bad one.&lt;/p&gt;
 &lt;p&gt;&amp;hellip;&lt;/p&gt;
 &lt;p&gt;If we can&amp;rsquo;t trust scientists to understand, then we &lt;em&gt;definitely&lt;/em&gt; can&amp;rsquo;t trust  you folks on the internet.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id="faq"&gt;FAQ&lt;/h2&gt;

&lt;h3 id="q-what-is-the-sampling-method-useful-for"&gt;Q. What is the sampling method useful for?&lt;/h3&gt;

&lt;ul&gt;
 &lt;li&gt;Making a confidence interval for the true proportion of configurations that  run at most &lt;strong&gt;D&lt;/strong&gt; times slower than some baseline, for your favorite value of &lt;strong&gt;D&lt;/strong&gt;.&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="q-what-is-the-sampling-method-not-useful-for"&gt;Q. What is the sampling method &lt;strong&gt;not&lt;/strong&gt; useful for?&lt;/h3&gt;

&lt;ul&gt;
 &lt;li&gt;Finding the slowest configuration.&lt;/li&gt;
 &lt;li&gt;Finding the average running time of all configurations.&lt;/li&gt;
 &lt;li&gt;Evaluations where &amp;ldquo;removing types&amp;rdquo; might involve changing &lt;strong&gt;List[Int]&lt;/strong&gt; to &lt;strong&gt;List[Dyn]&lt;/strong&gt;, etc.&lt;/li&gt;
 &lt;li&gt;Situations where its wrong to assume that a programmer will start from untyped and pick a configuration uniformly at random&lt;/li&gt;
 &lt;li&gt;&amp;hellip;. many more &amp;hellip;.&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="q-why-is-it-okay-to-choose-d-after-collecting-the-samples"&gt;Q. Why is it okay to choose &lt;strong&gt;D&lt;/strong&gt; after collecting the samples?&lt;/h3&gt;

&lt;p&gt;The &amp;ldquo;quick reference&amp;rdquo; at the top of this post suggests choosing a value for &lt;strong&gt;D&lt;/strong&gt;  (the cutoff between good and bad performance) after sampling configurations  and measuring their running time. This may sound strange, because (1) the value of &lt;strong&gt;D&lt;/strong&gt; affects our bottom-line  judgment about the proportion of configurations with good performance, and (2)  shouldn&amp;rsquo;t and value that affects the bottom line be fixed before taking samples? (To avoid accidental &lt;a href="https://en.wikipedia.org/wiki/Data_dredging"&gt;data dredging&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;The reason it is ok to pick &lt;strong&gt;D&lt;/strong&gt; after taking the sample is that the  running times in the sample are independent of the choice of &lt;strong&gt;D&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;For example, if one person chose &lt;strong&gt;D=3&lt;/strong&gt; and a second person chose &lt;strong&gt;D=9&lt;/strong&gt;,  both would follow the same protocol independent of &lt;strong&gt;D&lt;/strong&gt; to take samples.&lt;/p&gt;

&lt;h3 id="q-how-does-migratory-typing-relate-to-gradual-typing"&gt;Q. How does migratory typing relate to gradual typing?&lt;/h3&gt;

&lt;p&gt;Gradual typing is not just about adding a type system to an existing programming  language. See &lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;&lt;em&gt;Refined Criteria for Gradual Typing&lt;/em&gt;&lt;/a&gt;  and &lt;a href="http://drops.dagstuhl.de/opus/volltexte/2017/7120/"&gt;&lt;em&gt;Migratory Typing: 10 Years Later&lt;/em&gt;&lt;/a&gt;  for details.&lt;/p&gt;

&lt;h3 id="q-do-you-have-code-i-can-use-to-plot-sampling-data"&gt;Q. Do you have code I can use to plot sampling data?&lt;/h3&gt;

&lt;p&gt;Yes, start here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://docs.racket-lang.org/gtp-plot/index.html#%28def._%28%28lib._gtp-plot%2Fplot..rkt%29._samples-plot%29%29"&gt;http://docs.racket-lang.org/gtp-plot/index.html#%28def._%28%28lib._gtp-plot%2Fplot..rkt%29._samples-plot%29%29&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Please ask questions and open issues if you have trouble. The source is here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/bennn/gtp-plot"&gt;https://github.com/bennn/gtp-plot&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="q-where-is-code-for-the-sampling-paper"&gt;Q. Where is code for the sampling paper?&lt;/h3&gt;

&lt;p&gt;Start here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://pkgd.racket-lang.org/pkgn/package/gm-pepm-2018"&gt;https://pkgd.racket-lang.org/pkgn/package/gm-pepm-2018&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Source is here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/retic_performance"&gt;https://github.com/nuprl/retic_performance&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="closing-thoughts"&gt;Closing Thoughts&lt;/h2&gt;

&lt;p&gt;Statistics is easy to do wrong. Please let us know if you think our method is doing bad statistics.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">The Racket School 2018: Create your own language</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/04/27/the-racket-school-2018-create-your-own-language/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-04-27-the-racket-school-2018-create-your-own-language</id>
  <published>2018-04-27T21:35:22Z</published>
  <updated>2018-04-27T21:35:22Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;The Racket School 2018: Create your own language • 9–13 July • Salt Lake City&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;The Racket team has spent over thirty years developing and refining a coherent intellectual tradition for studying and building programming languages. This year’s school will introduce participants to Racket’s framework for language-oriented programming, which the summer school faculty recently spelled out in a a cover article in the &lt;a href="https://tinyurl.com/RacketCACM"&gt;Communications of the ACM&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Concretely, the 2018 Racket Summer School will cover the following topics:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;the spectrum of programming languages;&lt;/li&gt;
 &lt;li&gt;modules and syntax, or languages as libraries;&lt;/li&gt;
 &lt;li&gt;DrRacket’s support for language-oriented programming;&lt;/li&gt;
 &lt;li&gt;a domain-specific language for adding types to languages;&lt;/li&gt;
 &lt;li&gt;tools and techniques for implementing notational conveniences; and&lt;/li&gt;
 &lt;li&gt;research challenges in language-oriented programming.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;If these topics intrigue you, attend the Racket Summer School:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://summer-school.racket-lang.org/2018/"&gt;http://summer-school.racket-lang.org/2018/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;This is not your run-of-the-mill summer school. We will do our best to make it exciting, entertaining, and useful to a broad spectrum of attendees, both academic and industrial.&lt;/p&gt;

&lt;p&gt;P.S. We will send you your first problem set in June, a month before the summer school to whet your appetite.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">[How to prove a compiler fully abstract (cross-post)](https://dbp.io/essays/2018-04-19-how-to-prove-a-compiler-fully-abstract.html)</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/04/23/-how-to-prove-a-compiler-fully-abstract-cross-post-https-dbp-io-essays-2018-04-19-how-to-prove-a-compiler-fully-abstract-html/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-04-23-how-to-prove-a-compiler-fully-abstract-cross-post-https-dbp-io-essays-2018-04-19-how-to-prove-a-compiler-fully-abstract-html</id>
  <published>2018-04-23T10:07:48Z</published>
  <updated>2018-04-23T10:07:48Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html"></content></entry>
 <entry>
  <title type="text">[Making an IDE Plugin for DrRacket (cross-post)](https://lang.video/blog/2018/03/21/making-an-ide-plugin-for-drracket/)</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/04/12/-making-an-ide-plugin-for-drracket-cross-post-https-lang-video-blog-2018-03-21-making-an-ide-plugin-for-drracket/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-04-12-making-an-ide-plugin-for-drracket-cross-post-https-lang-video-blog-2018-03-21-making-an-ide-plugin-for-drracket</id>
  <published>2018-04-12T12:12:53Z</published>
  <updated>2018-04-12T12:12:53Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html"></content></entry>
 <entry>
  <title type="text">[Untyped Programs Don't Exist (cross-post)](https://williamjbowman.com/blog/2018/01/19/untyped-programs-don-t-exist/)</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/01/19/-untyped-programs-don-t-exist-cross-post-https-williamjbowman-com-blog-2018-01-19-untyped-programs-don-t-exist/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-01-19-untyped-programs-don-t-exist-cross-post-https-williamjbowman-com-blog-2018-01-19-untyped-programs-don-t-exist</id>
  <published>2018-01-19T17:05:00Z</published>
  <updated>2018-01-19T17:05:00Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html"></content></entry>
 <entry>
  <title type="text">[How to prove a compiler correct (cross-post)](https://dbp.io/essays/2018-01-16-how-to-prove-a-compiler-correct.html)</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/01/17/-how-to-prove-a-compiler-correct-cross-post-https-dbp-io-essays-2018-01-16-how-to-prove-a-compiler-correct-html/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-01-17-how-to-prove-a-compiler-correct-cross-post-https-dbp-io-essays-2018-01-16-how-to-prove-a-compiler-correct-html</id>
  <published>2018-01-17T20:58:48Z</published>
  <updated>2018-01-17T20:58:48Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html"></content></entry>
 <entry>
  <title type="text">Monotonicity Types: Towards A Type System for Eventual Consistency</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2017/10/22/monotonicity-types-towards-a-type-system-for-eventual-consistency/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2017-10-22-monotonicity-types-towards-a-type-system-for-eventual-consistency</id>
  <published>2017-10-22T11:59:06Z</published>
  <updated>2017-10-22T11:59:06Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;A few weeks back, we published a draft of an article entitled &lt;a href="https://infoscience.epfl.ch/record/231867"&gt;&lt;em&gt;Monotonicity Types&lt;/em&gt;&lt;/a&gt;. In it, we describe a type system which we hope can aid the design of distributed systems by tracking monotonicity with types.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;But first, what, precisely, do we mean by &lt;em&gt;monotonicity&lt;/em&gt;? Here&amp;rsquo;s a short definition:&lt;/p&gt;

&lt;p&gt;A partially ordered set is a set 
 &lt;script type="math/tex"&gt;P&lt;/script&gt; endowed with a relation 
 &lt;script type="math/tex"&gt;\leq&lt;/script&gt; such that for all 
 &lt;script type="math/tex"&gt;p, q, r \in P&lt;/script&gt; we have:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;script type="math/tex"&gt;p \leq p&lt;/script&gt; (reflexivity)&lt;/li&gt;
 &lt;li&gt;
  &lt;script type="math/tex"&gt;p \leq  q&lt;/script&gt; and 
  &lt;script type="math/tex"&gt;q \leq r&lt;/script&gt; implies 
  &lt;script type="math/tex"&gt;p \leq r&lt;/script&gt; (transitivity)&lt;/li&gt;
 &lt;li&gt;
  &lt;script type="math/tex"&gt;p \leq q&lt;/script&gt; and 
  &lt;script type="math/tex"&gt;q \leq p&lt;/script&gt; implies 
  &lt;script type="math/tex"&gt;p = q&lt;/script&gt; (anti-symmetry)&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;If 
 &lt;script type="math/tex"&gt;P&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt; are partially ordered sets, we say that a function 
 &lt;script type="math/tex"&gt;f : P \to Q&lt;/script&gt; between them is &lt;em&gt;monotone&lt;/em&gt; if for all 
 &lt;script type="math/tex"&gt;p_1, p_2 \in P&lt;/script&gt; with 
 &lt;script type="math/tex"&gt;p_1 \leq p_2&lt;/script&gt;, we have 
 &lt;script type="math/tex"&gt;f(p_1) \leq f(p_2)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;So, said another way, increasing the input to a monotone function causes an increase to its output.&lt;/p&gt;

&lt;p&gt;Particularly in the context of concurrent and distributed programming, monotonicity has arisen time and time again as an important property. Designers of languages for coordination-free distributed programming such as Lasp [&lt;a href="#ref1"&gt;Meiklejohn et al. (2015)&lt;/a&gt;] and BloomL [&lt;a href="#ref1"&gt;Conway et al. (2012)&lt;/a&gt;], as well as designers of data types and abstractions for eventual consistency or determinism such as CRDTs [&lt;a href="#ref3"&gt;Shapiro et al. (2011)&lt;/a&gt;] and LVars [&lt;a href="#ref4"&gt;Kuper et al. (2013)&lt;/a&gt;] have noticed that monotonic evolution of program state over time is a necessary property in their designs. Lasp and BloomL in particular require the use of monotone functions as primitives of program composition.&lt;/p&gt;

&lt;p&gt;Thus if a user would like to make use of such a language for concurrent and distributed programming, they&amp;rsquo;re required to write monotonic program functions, which can actually be quite tricky, in order to get the consistency or determinism guarantees that the given language/abstraction was designed to provide.&lt;/p&gt;

&lt;p&gt;To get a better idea of how monotonicity might be important in the context of data replicated over a distributed system, let&amp;rsquo;s look at an example. Suppose we need a function to determine whether a replicated counter&amp;rsquo;s current value is odd or even, and further suppose that this counter can only be incremented. To accomplish this, we might apply the following function to the counter&amp;rsquo;s value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun IsOdd(x : Nat) = x % 2 == 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the counter replica from which the argument x is obtained may not currently have an up-to-date count of the total number of increments performed in the entire system. We can&amp;rsquo;t rule out the possibility that exactly one remote increment has been performed, in which case IsOdd produces the wrong answer. With this in mind, the value returned by IsOdd does not seem to tell us anything useful. In contrast, consider an application of the following function to the same replicated counter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun MoreThanTen(x : Nat) = x &amp;gt; 10&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The boolean values 
 &lt;script type="math/tex"&gt;true&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;false&lt;/script&gt; form one of the simplest partially ordered sets of all. We consider 
 &lt;script type="math/tex"&gt;false \leq false&lt;/script&gt;, 
 &lt;script type="math/tex"&gt;false \leq true&lt;/script&gt;, and 
 &lt;script type="math/tex"&gt; true \leq true&lt;/script&gt;. Under this ordering, the MoreThanTen function is monotone: an increase in x can cause the value of 
 &lt;script type="math/tex"&gt;x &gt; 10&lt;/script&gt; to flip from false to true, but not vice versa. When we observe that the local counter replica P&amp;rsquo;s value is greater than 10, we don&amp;rsquo;t know that the same observation would be drawn from remote replicas. Nonetheless, we assume that all replicas in the system will eventually become aware of all increments that P is currently aware of, at which point their values will be greater than P&amp;rsquo;s current value. This is where MoreThanTen&amp;rsquo;s monotonicity becomes useful. At the point when all replicas have received P&amp;rsquo;s current information, every replica in the system will agree that MoreThanTen applied to the counter&amp;rsquo;s value returns true.&lt;/p&gt;

&lt;p&gt;We believe that a type system for proving functions monotone could push the development of coordination-free distributed and concurrent applications outside of the realm of distributed systems experts, by enabling customization and extension of such systems by non-experts.&lt;/p&gt;

&lt;p&gt;Towards this aim, we have been designing a typed lambda calculus in which types track monotonicity. Our approach allows the programmer to write a special kind of function definition, called an &lt;em&gt;sfun&lt;/em&gt;, the body of which is type checked using a richer type system, one which reasons about function composition rather than application. Such a function can be proven monotone by utilizing, among other principles, the fact that the composition of two monotone functions is itself monotone. Monotonicity is a relational property; that is, its a property involving multiple applications of the same function. Such properties are blind spot for traditional type systems, so our design requires some unusual and interesting features.&lt;/p&gt;

&lt;p&gt;Reasoning about pointwise orderings on function spaces seems a bit heavy-weight and hasn’t been necessary for any of my use cases. An sfun is therefore first order; that is, both its return type and all of its argument types must be data types rather than function types. We would like to be able to prove that a multi-argument function is monotone &lt;em&gt;separately&lt;/em&gt; in each of its arguments; that is, for 
 &lt;script type="math/tex"&gt;i \in 1..n&lt;/script&gt;, if 
 &lt;script type="math/tex"&gt;p_i \leq p_i'&lt;/script&gt; then 
 &lt;script type="math/tex"&gt;f(p_1, \ldots, p_i, \ldots, p_n) \leq f(p_1, \ldots p_i', \ldots p_n)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The monotonicity of an sfun is typically derived from the monotonicity of the primitives used to implement it, which are also sfuns. Here are some example sfun primitives, addition and subtraction on integers:&lt;/p&gt;

&lt;p&gt;1.) plus : 
 &lt;script type="math/tex"&gt; (x : Int, y : Int) \Rightarrow Int[\uparrow x, \uparrow y]&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;2.) minus : 
 &lt;script type="math/tex"&gt; (x : Int, y : Int) \Rightarrow Int[\uparrow x, \downarrow y]&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;sfun type&lt;/em&gt;, written with 
 &lt;script type="math/tex"&gt;\Rightarrow&lt;/script&gt; rather than 
 &lt;script type="math/tex"&gt;\rightarrow&lt;/script&gt;, names its formal arguments and also &lt;em&gt;qualifies&lt;/em&gt; each one. A qualifier is an argument-specific constraint on the behavior of the function. In the above types, the qualifier 
 &lt;script type="math/tex"&gt;\uparrow&lt;/script&gt; is associated with arguments that are separately monotone and 
 &lt;script type="math/tex"&gt;\downarrow&lt;/script&gt; is associated with arguments that are separately antitone. The second argument of a binary function 
 &lt;script type="math/tex"&gt;f&lt;/script&gt; is separately antitone if 
 &lt;script type="math/tex"&gt;p_2 \leq p_2'&lt;/script&gt; implies 
 &lt;script type="math/tex"&gt;f(p_1, p_2) \geq f(p_1, p_2')&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Terms outside of sfun abstractions are typed using a &lt;em&gt;global&lt;/em&gt; typing relation, which, aside from an sfun abstraction typing rule, is not different from the typing relations we are familiar with. A global typing judgment has the following form.&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex"&gt; \Gamma \vdash t : T&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;A typing judgment of the lifted type system, used to type check the body of an sfun, has the following form:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex"&gt; \Gamma;\Omega;\Phi \vdash t : T&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Here the &lt;em&gt;global type environment&lt;/em&gt; 
 &lt;script type="math/tex"&gt; \Gamma&lt;/script&gt; contains all of the variables bound outside of the sfun, the &lt;em&gt;ambient type environment&lt;/em&gt; 
 &lt;script type="math/tex"&gt; \Omega&lt;/script&gt; contains the list of the sfun’s formal arguments, and the &lt;em&gt;lifted type environment&lt;/em&gt; 
 &lt;script type="math/tex"&gt; \Phi&lt;/script&gt; contains those variables in 
 &lt;script type="math/tex"&gt; t&lt;/script&gt;’s context which are bound inside the sfun. Before getting into the significance of lifted typing judgments, let&amp;rsquo;s look at a specific application of the global typing rule for sfun abstractions, which uses a single lifted premise.&lt;/p&gt;

&lt;p&gt;$$\frac{\Gamma;x:Int;x:Int[=~x] \vdash plus(x,x) : Int[\uparrow~x]}  {\Gamma \vdash \tilde{\lambda} x : Int. plus(x,x) : ( x : Int ) \Rightarrow Int[\uparrow~x]}$$&lt;/p&gt;

&lt;p&gt;Here we type a single-argument sfun abstraction 
 &lt;script type="math/tex"&gt;\tilde{\lambda} x:Int. plus(x,x)&lt;/script&gt;. As you might have guessed, 
 &lt;script type="math/tex"&gt;\tilde{\lambda}&lt;/script&gt; is used rather that 
 &lt;script type="math/tex"&gt;\lambda&lt;/script&gt; to distinguish this as an sfun abstraction rather than a standard one. Examine the ambient and lifted type environments used in the premise. Perhaps surprisingly, the abstraction&amp;rsquo;s bound variable 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; is entered into both environments. When variables occur in types, they are considered references to formal arguments rather than actual arguments; that is, an occurrence of 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; in a type (for example 
 &lt;script type="math/tex"&gt;Int[\uparrow x]&lt;/script&gt;) does not refer to some integer, but instead a &amp;ldquo;slot&amp;rdquo; named 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; which expects to receive some integer from an external source. Inside the scope of the sfun abstraction, we would like the ability to refer to the abstraction&amp;rsquo;s formal argument 
 &lt;script type="math/tex"&gt;x&lt;/script&gt;, and therefore we add 
 &lt;script type="math/tex"&gt;x : Int&lt;/script&gt; to the ambient environment. We would also like to include occurrences of 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; as terms in the body of the abstraction; for these, we add the entry 
 &lt;script type="math/tex"&gt;x : Int[=~x]&lt;/script&gt; into the lifted type environment, to be used as a placeholder for the actual argument supplied to the formal argument 
 &lt;script type="math/tex"&gt;x&lt;/script&gt;. Because references to formal arguments occur only in types, and references to actual arguments occur only in terms, we can add entries with the same name to both the ambient and lifted environments without creating any ambiguity. In particular, this means that the occurrence of 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; in Int[
 &lt;script type="math/tex"&gt;\uparrow x&lt;/script&gt;] refers to the entry for 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; in the ambient type environment rather than the one in the lifted type environment.&lt;/p&gt;

&lt;p&gt;The premise of the above rule application includes the strange looking types 
 &lt;script type="math/tex"&gt;Int[=~x]&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;Int[\uparrow~x]&lt;/script&gt;. Normally, we would expect occurrences of x, which serve as placeholders for the actual argument of the the function, to have type 
 &lt;script type="math/tex"&gt;Int&lt;/script&gt;, and we would expect our abstraction&amp;rsquo;s body 
 &lt;script type="math/tex"&gt;plus(x,x)&lt;/script&gt; to have type 
 &lt;script type="math/tex"&gt;Int&lt;/script&gt; as well. This traditional approach to typing a function abstraction characterizes the operational behavior of a single function &lt;em&gt;after&lt;/em&gt; it has been applied. Unfortunately, this isn&amp;rsquo;t adequate for reasoning about properties such as monotonicity, which involve multiple calls to the same function. My approach instead takes the perspective of inside of a function, &lt;em&gt;before&lt;/em&gt; it has been applied. Lifted typing then characterizes the structure of a function as the composition of its constituent parts. In the above example, an occurrence of the variable 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; in the term 
 &lt;script type="math/tex"&gt;plus(x,x)&lt;/script&gt; has type 
 &lt;script type="math/tex"&gt;Int[=~x]&lt;/script&gt;, meaning that it is a function which takes the value provided to 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; (the enclosing sfun&amp;rsquo;s formal argument) as an input, and produces that value unchanged as a result. We ultimately care about the input/output relation of this function, and so the concrete values which inhabit this type are set-of-pairs function representations, called &lt;em&gt;ambient maps&lt;/em&gt;. The type 
 &lt;script type="math/tex"&gt;Int[=~x]&lt;/script&gt; happens to be a singleton type, containing the set of pairs 
 &lt;script type="math/tex"&gt;\{ (0,0), (1,1), (-1,-1), (2,2), (-2-2), \ldots \}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The sfun application 
 &lt;script type="math/tex"&gt;plus(x,x)&lt;/script&gt; is viewed as a function composition, where the outputs of the functions represented by the two occurrences of 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; are forwarded into the left and right arguments of the sfun 
 &lt;script type="math/tex"&gt;plus&lt;/script&gt;. The domain of this composite function matches the domain 
 &lt;script type="math/tex"&gt;x:Int&lt;/script&gt; of the enclosing sfun, which it inherits from the two occurrences of 
 &lt;script type="math/tex"&gt;x&lt;/script&gt;. Since 
 &lt;script type="math/tex"&gt;plus&lt;/script&gt; returns an 
 &lt;script type="math/tex"&gt;Int&lt;/script&gt;, so does the composite function 
 &lt;script type="math/tex"&gt;plus(x,x)&lt;/script&gt;. The premise of the above typing rule application tells us that 
 &lt;script type="math/tex"&gt;plus(x,x)&lt;/script&gt; has type 
 &lt;script type="math/tex"&gt;Int[\uparrow~x]&lt;/script&gt;, but this premise must be derived. We previously hinted that such a derivation may utilize the fact that the composition of two monotone functions is itself monotone, and indeed that is one aspect of the premise&amp;rsquo;s derivation, but a full treatment is outside the scope of this post.&lt;/p&gt;

&lt;p&gt;Since lifted typing is all about function composition, one might wonder how we treat occurrences of 
 &lt;script type="math/tex"&gt; \Gamma&lt;/script&gt;&amp;rsquo;s variables within the body of an sfun. Such a variable might have the type 
 &lt;script type="math/tex"&gt; Int&lt;/script&gt;, representing a data value rather than a function. In fact, a piece of data can be viewed as a degenerate, constant-valued function, which produces the same result regardless of which actual arguments any particular sfun is applied to. Subtyping rules enable the flexible use of terminal variables within the body of an sfun, permitting a variable of type 
 &lt;script type="math/tex"&gt; Int&lt;/script&gt;, for example, to occur in a context where terms of type 
 &lt;script type="math/tex"&gt; Int[ \uparrow x ]&lt;/script&gt; are expected. A constant function 
 &lt;script type="math/tex"&gt;f&lt;/script&gt;, after all, is monotone: 
 &lt;script type="math/tex"&gt; v_1 \leq v_2&lt;/script&gt; implies 
 &lt;script type="math/tex"&gt; f(v_1) = c \leq c = f(v_2)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re not building lifted typing derivations just for fun. Typically, a type system comes with a soundness theorem stating that whenever a typing judgment of the form 
 &lt;script type="math/tex"&gt; \Gamma \vdash t : T&lt;/script&gt; is derivable, the execution of the term 
 &lt;script type="math/tex"&gt;t&lt;/script&gt; (a program) under some well-defined model of computation (typically defined along with the type system) satisfies some desirable property. In our system, a terminal typing derivation 
 &lt;script type="math/tex"&gt; \Gamma \vdash t : T&lt;/script&gt; implies that when the free variables of t are substituted with appropriately-typed values, the execution of the term 
 &lt;script type="math/tex"&gt; t&lt;/script&gt; is guaranteed to terminate, producing a value of type 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; as its result. This is not a terribly unusual soundness guarantee. However, to provide semantics for lifted typing judgments, we introduced a new reduction relation (or &amp;ldquo;computation model&amp;rdquo;) which can be viewed in one of two ways:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;The simultaneous reduction of an sfun, under terminal reduction, when applied to all sets of arguments in its domain.&lt;/li&gt;
 &lt;li&gt;The composition of an sfun&amp;rsquo;s components, before the sfun is ever applied.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Point 1 is essentially the motivation for having lifted typing and lifted reduction in the first place. We want to know how the sfun behaves under terminal reduction, across multiple applications&amp;mdash;specifically two applications in the case of monotonicity. If the lifted reduction of an sfun&amp;rsquo;s body faithfully simulates the terminal reduction of all possible applications simultaneously, then the body of a well-typed sfun should normalize to an ambient map that is extensionally equivalent to the sfun&amp;rsquo;s applicative behavior under terminal reduction. Therefore, if our soundness theorem guarantees that the derivability of 
 &lt;script type="math/tex"&gt; \cdot;x:Int;x:Int[=~x] \vdash plus(x,x) : Int[\uparrow~x]&lt;/script&gt; implies that 
 &lt;script type="math/tex"&gt; plus(\{ (0,0), (1,1), \ldots \},\{ (0,0), (1,1), \ldots \} )&lt;/script&gt; normalizes under lifted reduction to a monotone ambient map, we then know that the sfun 
 &lt;script type="math/tex"&gt; \tilde{\lambda} x : Int. plus(x,x)&lt;/script&gt; behaves monotonically under terminal reduction. It&amp;rsquo;s important to note that our model never requires us to actually perform lifted reduction; lifted reduction matters because not because we actual want to perform it, but instead because lifted typing derivations guarantee the existence of certain lifted reduction sequences which have implications for terminal reduction.&lt;/p&gt;

&lt;p&gt;Point 2 inspires our lifted type system. If an sfun is composed of monotone functions, we can use facts about preservation of monotonicity across function composition to prove the sfun itself monotone. The difference between terminal reduction and lifted reduction is demonstrated by the two mathematical expressions 
 &lt;script type="math/tex"&gt; f(g(v))&lt;/script&gt; and 
 &lt;script type="math/tex"&gt; (f \circ g) (v)&lt;/script&gt;.  The expression 
 &lt;script type="math/tex"&gt; f(g(v))&lt;/script&gt; presents function composition as viewed by a standard type systems: to apply the composition of 
 &lt;script type="math/tex"&gt;f&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;g&lt;/script&gt; to a value 
 &lt;script type="math/tex"&gt;v&lt;/script&gt;, we first apply 
 &lt;script type="math/tex"&gt;g&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;v&lt;/script&gt;, and then apply 
 &lt;script type="math/tex"&gt;f&lt;/script&gt; to the result. This isn&amp;rsquo;t wrong, but if 
 &lt;script type="math/tex"&gt; f&lt;/script&gt; and 
 &lt;script type="math/tex"&gt; g&lt;/script&gt; are both monotone, the monotonicity of the composite function as a whole becomes self-evident if we first perform the &amp;ldquo;lifted reduction step&amp;rdquo; 
 &lt;script type="math/tex"&gt; f(g(v)) \to (f \circ g) (v)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll leave you with an aspirational example, which demonstrates the need for a type system, rather than a more monolithic form of analysis, for proving functions monotone. Recall our replicated counter example from the introduction. It isn&amp;rsquo;t sufficient to store this counter as an integer. The problem is that replicas cannot synchronize properly without knowing which how many increments were performed at each replica. Suppose that replicas X and Y each start with a count of zero. The following actions are then performed:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;X increments, resulting in a count of 1&lt;/li&gt;
 &lt;li&gt;X sends a synchronization message to Y, containing X&amp;rsquo;s count 1&lt;/li&gt;
 &lt;li&gt;X receives a synchronization message from Y containing a count of 1&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;At stage 3, X does not know if the received message was sent from Y before or after Y received the synchronization message from stage 2. Replica X therefore does not know whether to set its count to 1 or 2. To avoid this problem, a replicated counter is commonly represented as a map, which maps each replica identifier (a natural number) to the number of increments that replica has performed (also a natural number). It is assumed that any replica id not contained in the map&amp;rsquo;s finite representation maps to 0. Such counters are called GCounters, and described in detail by [&lt;a href="#ref3"&gt;Shapiro et al. (2011)&lt;/a&gt;].&lt;/p&gt;

&lt;p&gt;GCounters are partially ordered componentwise. We write 
 &lt;script type="math/tex"&gt; v[a]&lt;/script&gt; for the natural number to which the GCounter 
 &lt;script type="math/tex"&gt;v&lt;/script&gt; maps the replica identifier 
 &lt;script type="math/tex"&gt;a&lt;/script&gt;, and we write 
 &lt;script type="math/tex"&gt; \leq&lt;/script&gt; for the standard ordering on natural numbers. The partial order 
 &lt;script type="math/tex"&gt; \leq'&lt;/script&gt; on GCounters is then defined such that 
 &lt;script type="math/tex"&gt; v \leq' w&lt;/script&gt; whenever for all replica identifiers 
 &lt;script type="math/tex"&gt;a&lt;/script&gt; we have 
 &lt;script type="math/tex"&gt; v[a] \leq w[a]&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;[&lt;a href="#ref1"&gt;Meiklejohn et al. (2015)&lt;/a&gt;] motivates combinators for replicated data types such as the GCounter, but requires that such combinators are monotone separately in each argument. Below is psuedocode for a monotone GCounter addition combinator, annotated with monotonicity types. NatMap is used as the type of maps from natural numbers to natural numbers. Several primitives are defined for working with NatMap. getAt retrieves the kth element of a NatMap m. joinAt returns a new NatMap which is equal to the argument m, except that it maps k to the maximum of m[k] and n. span returns the greatest key mapping to a non-zero value. emptyMap is a NatMap which maps every natural number to 0. + and &amp;gt; are standard arithmetic operators for working with natural numbers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getAt :: (m : NatMap, k : Nat) ⇒ Nat[↑ m, ? k]
joinAt :: (m : NatMap, k : Nat, n : Nat) ⇒ NatMap[↑ m, ? k, ↑ n]
span :: (m:NatMap) ⇒ Nat[↑ m]
max :: (a : Nat, b : Nat) ⇒ Nat[↑ a, ↑ b]
emptyMap :: NatMap
+ :: (x:Nat, y:Nat) ⇒ Nat[↑ x, ↑ y]
&amp;gt; :: (x:Nat, y:Nat) ⇒ Bool[↑ x, ↓ y]

type GCounter = { map : NatMap }

sfun sumCounters(x : GCounter, y : GCounter) 
 : GCounter[↑ x, ↑ y] =
 let xMap : NatMap[↑ x, ↑ y] = x.map
 let yMap : NatMap[↑ x, ↑ y] = y.map
 let maxSpan : Nat[↑ x, ↑ y] = max (span xMap) (span yMap)
 fun sumCell(k : Nat, acc : NatMap[↑ x, ↑ y]) 
  : NatMap[↑ x, ↑ y] =
  let cond : Bool[↑ x, ↓ y] = k &amp;gt; maxSpan
   if cond then
    acc
   else
    let acc' = joinAt acc k ((getAt xMap k) + (getAt yMap k))
    sumCell (k+1) acc'
 let initMap : IntArray[↑ x, ↑ y] = emptyMap
 GCounter { map = sumCell 0 initMap }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While our system can handle much of this example, it can&amp;rsquo;t handle everything yet, for several reasons. First, it involves an if condition which depends on the arguments of the enclosing sfun. To handle this, we would need to incorporate the notion of domain restriction into lifted reduction. Second, it involves recursion. This is problematic for us, because our system utilizes the fact that all well-typed programs terminate. We could partially address this by adding terminating fixpoint combinators, which allow recursion given some well-founded termination metric, as in [&lt;a href="#ref5"&gt;Vazou et al. (2014)&lt;/a&gt;]. However, that would not be adequate for this particular function. Since it could require arbitrarily many levels of recursion depending on which values are supplied as arguments, lifted reduction, which simulates an application to all arguments simultaneously, would diverge.&lt;/p&gt;

&lt;p&gt;So there&amp;rsquo;s still much to do! If you&amp;rsquo;re interested in more details behind the type system, have a look at Kevin&amp;rsquo;s blog article, &lt;a href="https://kevinclancy.github.io/2017/11/09/monotonicity-through-types.html"&gt;Monotonicity Through Types&lt;/a&gt;, or have a look at the full &lt;a href="https://infoscience.epfl.ch/record/231867"&gt;Monotonicity Types&lt;/a&gt; preprint for more.&lt;/p&gt;

&lt;h3 id="references"&gt;References&lt;/h3&gt;

&lt;p&gt;&lt;span id="ref1"&gt;C. Meiklejohn and P. Van Roy. &lt;em&gt;Lasp: A language for distributed, coordination-free programming.&lt;/em&gt; In Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming, PPDP ’15, pages 184–195, New York, NY, USA, 2015. ACM.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span id="ref2"&gt;N. Conway, W. R. Marczak, P. Alvaro, J. M. Hellerstein, and D. Maier. &lt;em&gt;Logic and lattices for distributed programming&lt;/em&gt;. In Proceedings of the Third ACM Symposium on Cloud Computing, SoCC ’12, pages 1:1–1:14, New York, NY, USA, 2012. ACM.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span id="ref3"&gt;M. Shapiro, N. Preguiça, C. Baquero, and M. Zawirski. &lt;em&gt;Conflict-Free replicated data types&lt;/em&gt;. In Stabilization, Safety, and Security of Distributed Systems, Lecture Notes in Computer Science, pages 386–400. Springer, Berlin, Heidelberg, Oct. 2011.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class="ref4"&gt;L. Kuper and R. R. Newton. &lt;em&gt;LVars: Lattice-based data structures for deterministic parallelism&lt;/em&gt;. In Proceedings of the 2nd ACM SIGPLAN Workshop on Functional High-performance Computing, FHPC ’13, pages 71–84, New York, NY, USA, 2013. ACM.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class="ref5"&gt;N. Vazou, E. L. Seidel, R. Jhala, D. Vytiniotis, and S. Peyton-Jones. &lt;em&gt;Refinement types for Haskell&lt;/em&gt;. SIGPLAN Not. 49, 9 (August 2014), 269&amp;ndash;282.&lt;/span&gt;&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Final Algebra Semantics is Observational Equivalence</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2017/09/27/final-algebra-semantics-is-observational-equivalence/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2017-09-27-final-algebra-semantics-is-observational-equivalence</id>
  <published>2017-09-27T15:44:57Z</published>
  <updated>2017-09-27T15:44:57Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;Recently, &amp;ldquo;final encodings&amp;rdquo; and &amp;ldquo;finally tagless style&amp;rdquo; have become popular techniques for defining embedded languages in functional languages. In a recent discussion in the Northeastern PRL lab, &lt;a href="https://github.com/michaelballantyne"&gt;Michael Ballantyne&lt;/a&gt;, &lt;a href="http://ccs.neu.edu/home/ryanc"&gt;Ryan Culpepper&lt;/a&gt; and I asked &amp;ldquo;in what category are these actually final objects&amp;rdquo;? As it turns out our very own &lt;a href="http://www.ccs.neu.edu/home/wand/"&gt;Mitch Wand&lt;/a&gt; wrote one of the first papers to make exactly this idea precise, so I read it &lt;a href="https://www.cs.indiana.edu/ftp/techreports/TR65.pdf"&gt;available here&lt;/a&gt; and was pleasantly surprised to see that the definition of a final algebra there is essentially equivalent to the definition of observational equivalence.&lt;/p&gt;

&lt;p&gt;In this post, I&amp;rsquo;ll go over some of the results of that paper and explain the connection to observational equivalence. In the process we&amp;rsquo;ll learn a bit about categorical logic, and I&amp;rsquo;ll reformulate some of the category theory in that paper to be a bit more modern in presentation, cleaning some things up in the process.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="intuition-implementing-a-signature"&gt;Intuition: Implementing a Signature&lt;/h1&gt;

&lt;p&gt;As a running example, say we wanted to implement a datatype of finite maps whose keys and values are both integers, i.e., finite multisets of integers.&lt;/p&gt;

&lt;p&gt;We could specify such a datatype by specifying a little language of numbers and finite multisets. We&amp;rsquo;ll have two &amp;ldquo;sorts&amp;rdquo; &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;multiset&lt;/code&gt;, a constant for every integer, and an addition function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;'n : () -&amp;gt; num;
add : (num, num) -&amp;gt; num&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subject to the silly-looking equation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add('n,'m) = '(n + m)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and some operations on multisets&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;empty : () -&amp;gt; multiset;
singleton : (num) -&amp;gt; multiset;
union : (multiset, multiset) -&amp;gt; multiset;
remove : (num, multiset) -&amp;gt; multiset;
count : (num, multiset) -&amp;gt; num&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subject to the computational equations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count('n, empty) = '0
count('n, singleton('n)) = '1
count('n, singleton('m)) = '0
count('n, union(s,t)) = add(count('n,s), count('n, t))
count('n, remove('n,s)) = '0
count('n, remove('m,s)) = count('n,s)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are &amp;ldquo;all&amp;rdquo; of the equations we need to actually run our programs and get a number out, but not all the equations we intuitively &lt;em&gt;want&lt;/em&gt; for reasoning about our programs. For instance, clearly &lt;code&gt;union&lt;/code&gt; should be commutative, and &lt;code&gt;remove&lt;/code&gt; should be idempotent, but it&amp;rsquo;s impossible to prove that with just the equations specified. In fact, we can make a model of this theory that refutes them by constructing the &amp;ldquo;initial algebra&amp;rdquo;. In Haskell, we could say&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;data MultiSet = Empty 
  | Singleton Integer
  | Union MultiSet MultiSet
  | Remove Integer MultiSet
  deriving (Eq)

count :: Integer -&amp;gt; MultiSet -&amp;gt; Integer
count n Empty = 0
count n (Singleton m) | n == m = 1
count n (Singleton m) | n /= m = 0
count n (Union s t) = (count n s) + (count n t)
count n (Remove m s) | n == m = 0
count n (Remove m s) | n /= m = count n s
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Then it is completely obvious that all of our equations hold, but then &lt;code&gt;Union&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; commutative, as ghci will tell us:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&amp;gt; (Singleton 1 `Union` Singleton 2) == (Singleton 2 `Union` Singleton 1) 
False
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;However, there is another encoding that will give us that &lt;code&gt;union&lt;/code&gt; is commutative and &lt;code&gt;remove n&lt;/code&gt; is idempotent and actually every equation we could possibly want! It&amp;rsquo;s called the &amp;ldquo;final encoding&amp;rdquo; or &amp;ldquo;final algebra&amp;rdquo;. In Haskell, this looks like:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;data MultiSet&amp;#39; = MultiSet&amp;#39; { _count :: Integer -&amp;gt; Integer }

count&amp;#39; :: Integer -&amp;gt; MultiSet&amp;#39; -&amp;gt; Integer
count&amp;#39; n m = _count m n

empty :: MultiSet&amp;#39;
empty = MultiSet&amp;#39; { _count = \n -&amp;gt; 0 }

singleton :: Integer -&amp;gt; MultiSet&amp;#39;
singleton n = MultiSet&amp;#39; { _count = \m -&amp;gt; if n == m
                                         then 1
                                         else 0 }

union :: MultiSet&amp;#39; -&amp;gt; MultiSet&amp;#39; -&amp;gt; MultiSet&amp;#39;
union s t = MultiSet&amp;#39; { _count = \n -&amp;gt; (count&amp;#39; n s) + (count&amp;#39; n t) }

remove :: Integer -&amp;gt; MultiSet&amp;#39; -&amp;gt; MultiSet&amp;#39;
remove n s = MultiSet&amp;#39; { _count = \m -&amp;gt; if n == m
                                        then 0
                                        else count&amp;#39; n s }

test&amp;#39; = and [ count&amp;#39; n s == count&amp;#39; n t | n &amp;lt;- [0..1000]]
s = singleton 1 `union` singleton 2
t = singleton 2 `union` singleton 1
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Now we can verify that &lt;code&gt;union&lt;/code&gt; is commutative because&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;union s t = MultiSet&amp;#39; { _count = \n -&amp;gt; (count&amp;#39; n s) + (count&amp;#39; n t) }
          = MultiSet&amp;#39; { _count = \n -&amp;gt; (count&amp;#39; n t) + (count&amp;#39; n s) }
		  = union t s
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;since &lt;code&gt;+&lt;/code&gt; is commutative. Equality isn&amp;rsquo;t decidable anymore so I can&amp;rsquo;t give you a simple piece of code to witness this, but we can test our example before and we won&amp;rsquo;t be able to distinguish them, no surprise:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&amp;gt; let s = singleton 1 `union` singleton 2
&amp;gt; let t = singleton 2 `union` singleton 1
&amp;gt; and [ count&amp;#39; n s == count&amp;#39; n t | n &amp;lt;- [0..1000]]
True
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;How do we know this is the &amp;ldquo;best&amp;rdquo; or at least &amp;ldquo;most canonical&amp;rdquo; implementation of our datatype? The intuition is that we really don&amp;rsquo;t care at all &lt;em&gt;how&lt;/em&gt; our multisets are implemented as long as they behave the right way with respect to &lt;code&gt;count&lt;/code&gt; since &lt;code&gt;count&lt;/code&gt; returns an &lt;code&gt;Integer&lt;/code&gt;, a type we do understand. Our encoding accomplishes this by representing a multiset &lt;code&gt;s&lt;/code&gt; by the partially applied function &lt;code&gt;\n -&amp;gt; count n s&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The formal name for this idea is &lt;em&gt;observational equivalence&lt;/em&gt;. We say that two closed terms &lt;code&gt;s,t&lt;/code&gt; of sort &lt;code&gt;multiset&lt;/code&gt; are &lt;em&gt;observationally equivalent&lt;/em&gt; if for any term &lt;code&gt;C&lt;/code&gt; of type &lt;code&gt;num&lt;/code&gt; that has &lt;code&gt;s&lt;/code&gt; as a subterm, we can swap &lt;code&gt;t&lt;/code&gt; in for &lt;code&gt;s&lt;/code&gt; and prove that the two terms are equal. For instance &lt;code&gt;C&lt;/code&gt; might be &lt;code&gt;count(3, union(s, singleton(3)))&lt;/code&gt; or &lt;code&gt;add(4,remove(5,s))&lt;/code&gt;. Then we&amp;rsquo;ve reduced the possibly complicated equality for &lt;code&gt;multiset&lt;/code&gt; to the simple equality of &lt;code&gt;num&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Proving that the final encoding above satisfies all observational equivalences is beyond the scope of this blog post (see &lt;a href="https://hal.inria.fr/inria-00076514/document"&gt;here&lt;/a&gt;), but let&amp;rsquo;s see what all this talk about &amp;ldquo;algebras&amp;rdquo;, initial or final is all about.&lt;/p&gt;

&lt;h1 id="formalization-attempt-1-algebras-of-a-theory"&gt;Formalization Attempt 1: Algebras of a Theory&lt;/h1&gt;

&lt;p&gt;First, our little language of numbers and multisets is called a &lt;em&gt;theory&lt;/em&gt;. The specific category gadget that we&amp;rsquo;ll use to describe it is a &lt;em&gt;multi-sorted Lawvere theory&lt;/em&gt;, or just &lt;em&gt;Lawvere theory&lt;/em&gt; for short.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;Lawvere theory&lt;/em&gt; is a category with finite products all of whose objects are finite products of a collection of &lt;em&gt;sorts&lt;/em&gt; 
 &lt;script type="math/tex"&gt;S&lt;/script&gt;. We can construct this category from our little language above by making the objects be &lt;em&gt;contexts&lt;/em&gt; 
 &lt;script type="math/tex"&gt;x:num,y:multiset,...&lt;/script&gt; and morphisms 
 &lt;script type="math/tex"&gt;\Gamma \to
x_1:s_1,...,x_n:s_n&lt;/script&gt; to be 
 &lt;script type="math/tex"&gt;n&lt;/script&gt;-tuples of terms 
 &lt;script type="math/tex"&gt;\Gamma \vdash t_1 : s_1,...,
\Gamma \vdash t_n :  s_n&lt;/script&gt; &lt;em&gt;modulo&lt;/em&gt; the equations we&amp;rsquo;ve specified. We&amp;rsquo;ll use the letter 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; to mean a Lawvere theory.&lt;/p&gt;

&lt;p&gt;Then a &lt;em&gt;
  &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebra&lt;/em&gt; is a denotational semantics of our theory 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;, i.e., a product preserving functor 
 &lt;script type="math/tex"&gt;A : T \to Set&lt;/script&gt;. This means for every sort we get a set 
 &lt;script type="math/tex"&gt;A(s)&lt;/script&gt; and for every term 
 &lt;script type="math/tex"&gt;x_1:s_1,...,x_n:s_n
\vdash t : s&lt;/script&gt; a function 
 &lt;script type="math/tex"&gt;A(t) : A(s_1)\times\cdots \times A(s_n) \to
A(s)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Finally a &lt;em&gt;morphism of 
  &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebras&lt;/em&gt; from 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;B&lt;/script&gt; is a way to translate one algebra into another. Briefly, it is a natural transformation from 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;B&lt;/script&gt;, but concretely this means for every sort 
 &lt;script type="math/tex"&gt;s&lt;/script&gt; we get a function 
 &lt;script type="math/tex"&gt;\alpha_s : A(s) \to B(s)&lt;/script&gt; that translates 
 &lt;script type="math/tex"&gt;A&lt;/script&gt;s interpretation of 
 &lt;script type="math/tex"&gt;s&lt;/script&gt; as a set into 
 &lt;script type="math/tex"&gt;B&lt;/script&gt;s. The key property that we want is that the operations according to 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;B&lt;/script&gt; do the same thing as determined by 
 &lt;script type="math/tex"&gt;\alpha&lt;/script&gt;. Specifically, for any term 
 &lt;script type="math/tex"&gt;x_1:s_1,...,x_n:s_n \vdash t :
s&lt;/script&gt;, and inputs 
 &lt;script type="math/tex"&gt;x_1 \in A(s_1),...,x_n \in A(s_n)&lt;/script&gt; we should get the same result if we evaluate 
 &lt;script type="math/tex"&gt;A(t)(x_1,\ldots,x_n)&lt;/script&gt; and then apply 
 &lt;script type="math/tex"&gt;\alpha_s&lt;/script&gt; as if we first translate 
 &lt;script type="math/tex"&gt;x_1,\ldots,x_n&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;B(s_1),\ldots,B(s_n)&lt;/script&gt; and then apply 
 &lt;script type="math/tex"&gt;B(t)&lt;/script&gt;. If you unwind the definitions, this is exactly what naturality says.&lt;/p&gt;

&lt;p&gt;Then we have a category we&amp;rsquo;ll call 
 &lt;script type="math/tex"&gt;T-Alg&lt;/script&gt; of 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebras and we can ask if there are initial or final algebra. It turns out that both of them &lt;em&gt;always&lt;/em&gt; exist.&lt;/p&gt;

&lt;p&gt;The initial algebra is most famous here, we define for each sort 
 &lt;script type="math/tex"&gt;In(T)(s) = \cdot \vdash s&lt;/script&gt;, the closed terms of that sort modulo the equivalence of the theory, and 
 &lt;script type="math/tex"&gt;In(T)(s_1,\ldots,s_n) =
In(T)(s_1)\times\ldots,In(T)(s_n)&lt;/script&gt;. Then the terms are just interpreted as the functions you get by plugging closed inputs into them. Then if we look at what what a morphism of 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebras from 
 &lt;script type="math/tex"&gt;In(T) \to A&lt;/script&gt; is, we see that we don&amp;rsquo;t have any choice, the only one is the one that maps 
 &lt;script type="math/tex"&gt;\cdot \vdash t : s&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;A(t)&lt;/script&gt; and this makes all the right diagrams to commute. This is pretty similar to our definition of &amp;ldquo;initial algebra&amp;rdquo; before, except that this time we defined &lt;code&gt;count&lt;/code&gt; as a function, not just a case of an ADT, but that was just an easy way to satisfy the computational equations for &lt;code&gt;count&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, an egregious flaw presents itself when we look at what the &lt;em&gt;final&lt;/em&gt; algebra is. It&amp;rsquo;s completely trivial! We can define 
 &lt;script type="math/tex"&gt;Fin(T)&lt;/script&gt; to take every sort to a one element set 
 &lt;script type="math/tex"&gt;Fin(T)(s) = \{*\}&lt;/script&gt; and every term to the trivial function 
 &lt;script type="math/tex"&gt;\{*\}^n \to \{*\}&lt;/script&gt;. What the hell? This interprets numbers and multisets as trivial one-element sets. To rule this one out, we need to add some conditions to our algebras.&lt;/p&gt;

&lt;h1 id="formalization-algebras-of-a-theory-extension"&gt;Formalization: Algebras of a Theory Extension&lt;/h1&gt;

&lt;p&gt;To rule out these boring algebras, and get a nice final algebra, we have to recognize that the sorts &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;multiset&lt;/code&gt; in our theory are not really on equal footing. While we are not sure how multisets should be defined, we know &lt;em&gt;exactly&lt;/em&gt; what numbers are!&lt;/p&gt;

&lt;p&gt;To formalize this we&amp;rsquo;ll call the full theory 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; and the theory with just numbers 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt;. Then there should be a map from 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; that is the inclusion of theories. We&amp;rsquo;ll formalize this as a &lt;em&gt;morphism of theories&lt;/em&gt;. A morphism of theories is a &lt;em&gt;strict&lt;/em&gt; product-preserving functor from one theory to another. The strictness ensures that we don&amp;rsquo;t mix up our sorts and our contexts, a morphim of theories has to map sorts to sorts, whereas a non-strict functor could map a sort to a context with two sorts it&amp;rsquo;s equivalent to. What this really amounts to is a translation of one theory into another. It maps sorts to sorts and terms to terms of the appropriate sorts in a compositional way. However, we don&amp;rsquo;t want to consider &lt;em&gt;all&lt;/em&gt; such morphisms, only the ones that are &amp;ldquo;conservative extensions&amp;rdquo;, which means&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;there are no new closed terms at old types&lt;/li&gt;
 &lt;li&gt;closed terms that were different before remain different.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;In our example (1) ensures that we don&amp;rsquo;t add any new exotic numbers like &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;∞&lt;/code&gt;, and (2) ensures that we keep 
 &lt;script type="math/tex"&gt;0&lt;/script&gt; different from 
 &lt;script type="math/tex"&gt;1&lt;/script&gt;, like the final algebra did before by having all numbers have the same interpreation 
 &lt;script type="math/tex"&gt;*&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We can formalize this in the following way. Note that any morphism of Lawvere theories 
 &lt;script type="math/tex"&gt;m : T \to S&lt;/script&gt; induces a &lt;em&gt;functor&lt;/em&gt; on the category of algebras 
 &lt;script type="math/tex"&gt;m^* : S-Alg \to T-Alg&lt;/script&gt; by just composing functors. An 
 &lt;script type="math/tex"&gt;S&lt;/script&gt;-algebra is a functor from 
 &lt;script type="math/tex"&gt;S&lt;/script&gt; to sets, and 
 &lt;script type="math/tex"&gt;m&lt;/script&gt; is a functor from 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;S&lt;/script&gt; so we can compose to get 
 &lt;script type="math/tex"&gt;m^*(A)(t) = A(m(t))&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Now, we can express the idea of a conservative extension by saying that the canonical arrow from 
 &lt;script type="math/tex"&gt;In(T)&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;m^*(In(S))&lt;/script&gt; is an isomorphism. Recalling the definition of initial algebras, this says exactly that the closed terms in 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; up to 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;-equivalence are isomorphic to the closed terms of the type provided by 
 &lt;script type="math/tex"&gt;m&lt;/script&gt; in 
 &lt;script type="math/tex"&gt;S&lt;/script&gt; up to 
 &lt;script type="math/tex"&gt;S&lt;/script&gt;-equivalence. This is an equivalent formulation to the definition in Mitch&amp;rsquo;s paper, but there it is separated into two properties fullness and faithfulness, and doesn&amp;rsquo;t use the initial algebras and 
 &lt;script type="math/tex"&gt;m^*&lt;/script&gt; explicitly.&lt;/p&gt;

&lt;p&gt;Now we can verify that the inclusion 
 &lt;script type="math/tex"&gt;i : T_0 \to T_1&lt;/script&gt; of the number theory into the number-multiset theory is an extension in this sense.&lt;/p&gt;

&lt;p&gt;Finally we can define our notion of 
 &lt;script type="math/tex"&gt;i&lt;/script&gt;-algebra, which will be our correct notion of algebra. An 
 &lt;script type="math/tex"&gt;i&lt;/script&gt;-algebra is a 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; algebra 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; such that&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;The canonical algebra map 
  &lt;script type="math/tex"&gt;! : In(T_0) \to m^*A&lt;/script&gt; is an isomorphism.&lt;/li&gt;
 &lt;li&gt;The canonical algebra map 
  &lt;script type="math/tex"&gt;! : In(T_1) \to A&lt;/script&gt; is surjective i.e.,  for each sort 
  &lt;script type="math/tex"&gt;s, !_s&lt;/script&gt; is surjective.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The first condition says again that we have a conservative extension of 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt;, but the second is more interesting. It says that every denotation given by 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; is represented by some term in 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt;. In fact what it really ensures is that 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; determines a &lt;em&gt;congruence relation&lt;/em&gt; on 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; given by 
 &lt;script type="math/tex"&gt;t1 \equiv_A t2&lt;/script&gt; if 
 &lt;script type="math/tex"&gt;A(t1) = A(t2)&lt;/script&gt;. In light of this, the first condition could be called &lt;em&gt;adequacy&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Furthermore, the surjectivity condition ensures that any morphism of 
 &lt;script type="math/tex"&gt;i&lt;/script&gt; algebras, i.e., a map as 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt;-algebras is also surjective, so a morphism 
 &lt;script type="math/tex"&gt;A \to B&lt;/script&gt; is a witness to the fact that 
 &lt;script type="math/tex"&gt;B&lt;/script&gt; determines a &lt;em&gt;stronger&lt;/em&gt; congruence relation on 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; than 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; does: 
 &lt;script type="math/tex"&gt;t1 \equiv_B t2
\implies t1 \equiv_A t2&lt;/script&gt;. Then asking for a final algebra is asking for exactly the:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Strongest adequate congruence relation&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;which is exactly the definition of observational equivalence you will find in, say Pitt&amp;rsquo;s chapter of &lt;a href="https://www.cis.upenn.edu/~bcpierce/attapl/"&gt;Advanced TAPL&lt;/a&gt;. There is a difference in the meaning of &lt;em&gt;adequacy&lt;/em&gt;, though. Usually adequacy is defined in terms of an operational semantics, but here everything is based on an axiomatic notion of equality, but I think they play the same role in the two settings, so I think it&amp;rsquo;s reasonable to use the same word. On thing I like about this formulation is very nice though since it makes obvious that &lt;em&gt;adequacy&lt;/em&gt; is not a predetermined concept, we have to pick 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;i&lt;/script&gt; in order to know what adequacy means.&lt;/p&gt;

&lt;h1 id="conclusion-tying-it-back-to-final-encodings"&gt;Conclusion: Tying it back to Final Encodings&lt;/h1&gt;

&lt;p&gt;So now we&amp;rsquo;ve seen that&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Final algebras are equivalent to initial algebras modulo observational equivalence&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Of course we haven&amp;rsquo;t precisely gotten back to where we started: we were talking about denotational semantics in terms of sets and functions, but what we really want are implementations in our favorite programming languages. Fortunately, we didn&amp;rsquo;t use very many properties of sets in our definition, so it&amp;rsquo;s pretty easy to swap out the category of Sets for some category built out of the terms of our programming language. We can also swap out sets for some much cooler category of denotations like domains or metric spaces or time-varying values.&lt;/p&gt;

&lt;p&gt;Another question is how to implement this when we have a proper &lt;em&gt;type theory&lt;/em&gt; and not just some boring sorts. In particular, if we have function types, then we won&amp;rsquo;t be able to get functions from functions in our term model to functions in our denotations due to contravariance. Perhaps logical relations are the solution?&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">PLT Redex FAQ</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2017/09/25/plt-redex-faq/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2017-09-25-plt-redex-faq</id>
  <published>2017-09-25T23:39:16Z</published>
  <updated>2017-09-25T23:39:16Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;A short guide to Redex concepts, conventions, and common mistakes.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;To contribute to this FAQ, submit issues and pull requests to:  &lt;a href="https://github.com/nuprl/website/"&gt;https://github.com/nuprl/website/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id="q-what-is-redex-useful-for"&gt;Q. What is Redex useful for?&lt;/h3&gt;

&lt;ol&gt;
 &lt;li&gt;declaring &lt;a href="https://en.wikipedia.org/wiki/Regular_tree_grammar"&gt;regular tree grammars&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;defining &lt;em&gt;pattern&lt;/em&gt;-based judgments and relations on &lt;em&gt;terms&lt;/em&gt;&lt;/li&gt;
 &lt;li&gt;testing properties of the above&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;More generally, Redex is helpful for experimenting with a programming language  design, and helping you decide what you might want to prove about a language.&lt;/p&gt;

&lt;h3 id="q-what-is-redex-not-useful-for"&gt;Q. What is Redex &lt;strong&gt;not&lt;/strong&gt; useful for?&lt;/h3&gt;

&lt;p&gt;Proving theorems about a grammar, judgment, or relation.&lt;/p&gt;

&lt;h3 id="q-what-is-a-term"&gt;Q. What is a &lt;em&gt;term&lt;/em&gt;?&lt;/h3&gt;

&lt;p&gt;Informally, a term is:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;a Redex &amp;ldquo;atom&amp;rdquo;, or&lt;/li&gt;
 &lt;li&gt;an object that represents a sequence of characters.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;More formally, a term is the result of evaluating &lt;strong&gt;(term X)&lt;/strong&gt;, where &lt;strong&gt;X&lt;/strong&gt; is  any syntactically-correct Racket expression.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.10.0.3.
&amp;gt; (require redex/reduction-semantics)
&amp;gt; (term 42)
42
&amp;gt; (term (+ 2 2))
'(+ 2 2)
&amp;gt; (term ("hello" world (#false)))
'("hello" world (#f))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some terms may look strange. That&amp;rsquo;s OK, because a term by itself has no meaning.&lt;/p&gt;

&lt;p&gt;Terms can refer to previously-defined values using the &lt;strong&gt;unquote&lt;/strong&gt; escape.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; (define x (term 42))
&amp;gt; (term (+ 2 x))
'(+ 2 x)
&amp;gt; (term (+ ,x (unquote x)))
'(+ 42 42)&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-is-a-redex-model"&gt;Q. What is a &lt;em&gt;Redex model&lt;/em&gt;?&lt;/h3&gt;

&lt;p&gt;A Redex model is collection of tools for working with terms. The tools may include:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;em&gt;languages&lt;/em&gt;, to define a grammar for terms&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;judgments&lt;/em&gt;, to describe properties of terms or relations between terms&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;metafunctions&lt;/em&gt;, to transform terms&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;reduction relations&lt;/em&gt;, to define a term rewriting system&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The goal of these tools is to encode a &amp;ldquo;real thing&amp;rdquo; (maybe, a programming language)  using Redex terms.&lt;/p&gt;

&lt;h3 id="q-what-is-a-language"&gt;Q. What is a language?&lt;/h3&gt;

&lt;p&gt;A Redex &lt;em&gt;language&lt;/em&gt; is a named set of non-terminals, &lt;em&gt;patterns&lt;/em&gt;, and &lt;em&gt;binding forms&lt;/em&gt;. For example, a Redex model of the natural numbers might start with this language:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language nat
  [N ::= Zero
         (Plus1 N)])&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
 &lt;li&gt;the name of the language is &lt;strong&gt;nat&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;the non-terminal &lt;strong&gt;N&lt;/strong&gt; is associated with two patterns: &lt;strong&gt;Zero&lt;/strong&gt; and &lt;strong&gt;(Plus1 N)&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;there are no &lt;em&gt;binding forms&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Each pattern describes a syntactic category of terms. Each non-terminal gives a name to the union of the patterns that follow it.&lt;/p&gt;

&lt;p&gt;The non-terminal &lt;strong&gt;N&lt;/strong&gt; describes all terms that are either:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;the symbol &lt;strong&gt;Zero&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;lists of the form &lt;strong&gt;(Plus1 N)&lt;/strong&gt;, where &lt;strong&gt;N&lt;/strong&gt; is either &lt;strong&gt;Zero&lt;/strong&gt; or another &amp;ldquo;Plus1&amp;rdquo;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(term Zero)
(term (Plus1 Zero))
(term (Plus1 (Plus1 Zero)))
(term (Plus1 (Plus1 (Plus1 Zero))))
;; .... and so on&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a language has binding forms, then some terms can introduce names. See the question on &lt;em&gt;binding forms&lt;/em&gt; (below) for an example.&lt;/p&gt;

&lt;h3 id="q-what-is-a-pattern"&gt;Q. What is a pattern?&lt;/h3&gt;

&lt;p&gt;A pattern is a sequence of characters and variables. If you have: (1) a language, and (2) a pattern that contains &lt;em&gt;named non-terminals&lt;/em&gt; from the language,  then you can ask whether a Redex term matches the pattern.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;named non-terminal&lt;/em&gt; for a language &lt;strong&gt;L&lt;/strong&gt; is an identifier made of:  (1) a non-terminal from &lt;strong&gt;L&lt;/strong&gt;, (2) an underscore (&lt;strong&gt;_&lt;/strong&gt;), and (3) any other identifier. See the FAQ entry below.&lt;/p&gt;

&lt;p&gt;For example, &lt;strong&gt;(redex-match? L p t)&lt;/strong&gt; returns &lt;strong&gt;#true&lt;/strong&gt; if the term &lt;strong&gt;t&lt;/strong&gt; matches  the pattern &lt;strong&gt;p&lt;/strong&gt; relative to the language &lt;strong&gt;L&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language nat
  [N ::= Zero (Plus1 N)])

(redex-match? nat N_some-name (term Zero))
;; #true
(redex-match? nat (Plus1 N_a) (term Zero))
;; #false
(redex-match? nat (Plus1 N_0) (term (Plus1 (Plus1 Zero))))
;; #true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;strong&gt;(redex-match? L p t)&lt;/strong&gt; is &lt;strong&gt;#true&lt;/strong&gt;, then &lt;strong&gt;(redex-match L p t)&lt;/strong&gt; shows how  named non-terminals in the pattern bind to subterms of &lt;strong&gt;t&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(redex-match nat N_0 (term Zero))
;; (list (match (list (bind 'N_0 'Zero))))
(redex-match nat (Plus1 N_0) (term Zero))
;; #f
(redex-match nat (Plus1 N_0) (term (Plus1 (Plus1 Zero))))
;; (list (match (list (bind 'N_0 '(Plus1 Zero)))))&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-is-a-named-non-terminal"&gt;Q. What is a named non-terminal?&lt;/h3&gt;

&lt;p&gt;A named non-terminal in a language &lt;strong&gt;L&lt;/strong&gt; is an identifier of the form &lt;strong&gt;X_Y&lt;/strong&gt;, where:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; is a non-terminal from &lt;strong&gt;L&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Y&lt;/strong&gt; is any identifier&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The name helps when one pattern contains multiple occurrences of the same non-terminal. If you want the two occurrences to bind the same term, then use the same name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language trees
  [binary-tree ::= Leaf
                   (Node binary-tree binary-tree)])

(redex-match trees
  (Node binary-tree_left binary-tree_right)
  (term (Node Leaf (Node Leaf Leaf))))
;; (list
;;  (match
;;   (list (bind 'binary-tree_left 'Leaf)
;;         (bind 'binary-tree_right '(Node Leaf Leaf)))))&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-else-can-patterns-express"&gt;Q. What else can patterns express?&lt;/h3&gt;

&lt;p&gt;Redex patterns may contain special identifiers to guide pattern-matching. For instance:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;The &lt;strong&gt;_&lt;/strong&gt; pattern matches any term (and does not bind).&lt;/li&gt;
 &lt;li&gt;A pattern &lt;strong&gt;(p &amp;hellip;)&lt;/strong&gt; matches any sequence whose elements match the pattern &lt;strong&gt;p&lt;/strong&gt;.  If the pattern &lt;strong&gt;p&lt;/strong&gt; is a named non-terminal, then the non-terminal binds  a sequence of subterms.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(redex-match? nat (Plus1 _) (term (Plus1 9)))
;; #true
(redex-match? nat (N_0 ...) (term ()))
;; #true
(redex-match? nat (N_0 ...) (term (Zero)))
;; #true
(redex-match nat (N_0 ...) (term (Zero Zero Zero)))
;; (list (match (list (bind 'N_0 '(Zero Zero Zero)))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28tech._pattern%29"&gt;the Redex reference&lt;/a&gt; for the full pattern language,  including the &lt;em&gt;named and unique non-terminals&lt;/em&gt; of the form &lt;strong&gt;X_!_Y&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id="q-what-can-patterns-not-express"&gt;Q. What can patterns &lt;strong&gt;not&lt;/strong&gt; express?&lt;/h3&gt;

&lt;ul&gt;
 &lt;li&gt;Disjunctions of patterns, e.g., &amp;ldquo;number or boolean&amp;rdquo;.  (Use a language non-terminal.)&lt;/li&gt;
 &lt;li&gt;Negations of patterns. (Compose &lt;strong&gt;not&lt;/strong&gt; with &lt;strong&gt;redex-match?&lt;/strong&gt;.)&lt;/li&gt;
 &lt;li&gt;Some non-regular patterns. (Named  dots &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28tech._pattern%29"&gt;&lt;code&gt;..._N&lt;/code&gt;&lt;/a&gt;  or &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28form._%28%28lib._redex%2Freduction-semantics..rkt%29._define-language%29%29"&gt;&lt;code&gt;define-language&lt;/code&gt;&lt;/a&gt;  with a side condition may be able to help.)&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="q-what-is-a-judgment"&gt;Q. What is a judgment?&lt;/h3&gt;

&lt;p&gt;A Redex &lt;em&gt;judgment&lt;/em&gt; form defines a relation on terms. The relation is defined by a set of inference rules.&lt;/p&gt;

&lt;p&gt;Programming languages papers use inference rules all the time. Redex can express many of the judgments in papers; for example:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;well-formedness conditions (i.e., whether a term contains free variables)&lt;/li&gt;
 &lt;li&gt;type checking rules&lt;/li&gt;
 &lt;li&gt;type inference rules&lt;/li&gt;
 &lt;li&gt;evaluation relations&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Every judgment needs (1) a language (2) a mode (3) a contract (4) a set of inference rules. For example, the following judgment defines an equality relation on natural numbers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language nat
  [N ::= Zero (Plus1 N)])

(define-judgment-form nat
  #:mode (N= I I)
  #:contract (N= N N)
  [
   --- Zero=
   (N= Zero Zero)]
  [
   (where (Plus1 N_0--) N_0)
   (where (Plus1 N_1--) N_1)
   (N= N_0-- N_1--)
   --- Plus1=
   (N= N_0 N_1)])&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
 &lt;li&gt;the language is &lt;strong&gt;nat&lt;/strong&gt;; Redex uses the language to interpret patterns&lt;/li&gt;
 &lt;li&gt;the mode is &lt;strong&gt;(N= I I)&lt;/strong&gt;; this means &lt;strong&gt;N=&lt;/strong&gt; is the name of a judgment that  expects two input terms (or, &lt;strong&gt;N=&lt;/strong&gt; is a binary relation on terms)&lt;/li&gt;
 &lt;li&gt;the contract is &lt;strong&gt;(N= N N)&lt;/strong&gt;; in other words, &lt;strong&gt;N=&lt;/strong&gt; expects two terms that  match the &lt;strong&gt;N&lt;/strong&gt; non-terminal from the &lt;strong&gt;nat&lt;/strong&gt; language&lt;/li&gt;
 &lt;li&gt;there are two inference rules, named &lt;strong&gt;Zero=&lt;/strong&gt; and &lt;strong&gt;Plus1=&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;the &lt;strong&gt;Zero=&lt;/strong&gt; rule states that &lt;strong&gt;(N= Zero Zero)&lt;/strong&gt; always holds&lt;/li&gt;
 &lt;li&gt;the &lt;strong&gt;Plus1=&lt;/strong&gt; rule states that &lt;strong&gt;(N= N_0 N_1)&lt;/strong&gt; holds if &lt;strong&gt;N_0&lt;/strong&gt; and &lt;strong&gt;N_1&lt;/strong&gt;  are both &lt;strong&gt;Plus1&lt;/strong&gt; terms whose contents are related by &lt;strong&gt;N=&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The &lt;strong&gt;where&lt;/strong&gt; clauses are &lt;em&gt;guards&lt;/em&gt;. When Redex tries to apply a rule with premises of the form  &lt;strong&gt;(where pattern term)&lt;/strong&gt;, it checks that each pattern matches the corresponding term. If not, Redex stops applying the rule. See &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28form._%28%28lib._redex%2Freduction-semantics..rkt%29._define-judgment-form%29%29"&gt;the Redex reference&lt;/a&gt; for more.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(judgment-holds (N= Zero Zero))
;; #true
(judgment-holds (N= (Plus1 (Plus1 Zero)) (Plus1 (Plus1 Zero))))
;; #false
(judgment-holds (N= (Plus1 Zero) (Plus1 (Plus1 Zero))))
;; #true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: the inference rules form a &lt;em&gt;set&lt;/em&gt;, not a &lt;em&gt;sequence&lt;/em&gt;. So when you ask Redex whether &lt;strong&gt;(judgment-holds (N= Zero Zero))&lt;/strong&gt;, it applies  all rules that match &lt;strong&gt;(N= Zero Zero)&lt;/strong&gt;. For &lt;strong&gt;N=&lt;/strong&gt; this is just one rule, but in general it could be many rules.&lt;/p&gt;

&lt;h3 id="q-what-is-a-judgment-form-mode"&gt;Q. What is a judgment form &lt;strong&gt;#:mode&lt;/strong&gt;?&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;#:mode&lt;/strong&gt; declaration expects a list of the form &lt;strong&gt;(id pos-use &amp;hellip;)&lt;/strong&gt;,  where &lt;strong&gt;id&lt;/strong&gt; is an identifier and each &lt;strong&gt;pos-use&lt;/strong&gt; is either  &lt;strong&gt;I&lt;/strong&gt; or &lt;strong&gt;O&lt;/strong&gt;. These declarations say four things:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; is the name of a new judgment form&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; expects &lt;strong&gt;N&lt;/strong&gt; arguments, where &lt;strong&gt;N&lt;/strong&gt; is the number of &lt;strong&gt;pos-use&lt;/strong&gt; symbols&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; expects an &lt;em&gt;input&lt;/em&gt; at each position where the mode contains an &lt;strong&gt;I&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; produces an &lt;em&gt;output&lt;/em&gt; at each position where the mode contains an &lt;strong&gt;O&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For example, a type inference judgment may take an expression as input and output a type. Here&amp;rsquo;s a fast and easy type inference judgment for arithmetic expressions. Given any term &lt;strong&gt;e_0&lt;/strong&gt;, the judgment outputs the type &lt;strong&gt;Int&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language Arith
  (e ::= integer (e + e))
  (τ ::= Int))

(define-judgment-form Arith
  #:mode (infer-type I O)
  #:contract (infer-type e τ)
  [
   --- T-Int
   (infer-type e_0 Int)])&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-can-judgments-not-express"&gt;Q. What can judgments &lt;strong&gt;not&lt;/strong&gt; express?&lt;/h3&gt;

&lt;p&gt;Redex does not support inference rules that require guessing.&lt;/p&gt;

&lt;p&gt;One example of this is a transitivity rule: "&lt;strong&gt;τ_0&lt;/strong&gt; is related to &lt;strong&gt;τ_2&lt;/strong&gt;  if there exists a &lt;strong&gt;τ_1&lt;/strong&gt; such that &lt;strong&gt;τ_0&lt;/strong&gt; is related to &lt;strong&gt;τ_1&lt;/strong&gt; and &lt;strong&gt;τ_1&lt;/strong&gt; is  related to &lt;strong&gt;τ_2&lt;/strong&gt;". The following example tries to define a transitive subtyping (&lt;strong&gt;&amp;lt;:&lt;/strong&gt;) relation,  but Redex rejects the &lt;strong&gt;S-Trans&lt;/strong&gt; rule.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language SomeTypes
  (τ ::= (→ τ τ) Integer))

(define-judgment-form SomeTypes
  #:mode (&amp;lt;: I I)
  #:contract (&amp;lt;: τ τ)
  [
   (&amp;lt;: τ_0 τ_1)
   (&amp;lt;: τ_1 τ_2)
   --- S-Trans
   (&amp;lt;: τ_0 τ_2)]
  [
   --- S-Refl
   (&amp;lt;: τ_0 τ_0)]
  [
   (&amp;lt;: τ_dom-1 τ_dom-0)
   (&amp;lt;: τ_cod-0 τ_cod-1)
   --- S-Arrow
   (&amp;lt;: (→ τ_dom-0 τ_cod-0) (→ τ_dom-1 τ_cod-1))])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The error is that in the rule &lt;strong&gt;S-Trans&lt;/strong&gt;,  the named non-terminal &lt;strong&gt;τ_1&lt;/strong&gt; appears in an input position but is not bound to a term.&lt;/p&gt;

&lt;h3 id="q-what-is-a-metafunction"&gt;Q. What is a metafunction?&lt;/h3&gt;

&lt;p&gt;A metafunction is a term-level function on terms.&lt;/p&gt;

&lt;p&gt;Every metafunction needs: (1) a language (2) a name (3) a contract (4) a sequence of guarded input/output cases.&lt;/p&gt;

&lt;p&gt;Here is a metafunction that returns &lt;strong&gt;#true&lt;/strong&gt; when given two equal natural numbers. The definition is similar to the &lt;strong&gt;N=&lt;/strong&gt; judgment form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-metafunction nat
  N=? : N N -&amp;gt; boolean
  [(N=? Zero Zero)
   #true]
  [(N=? N_0 N_1)
   (N=? N_0-- N_1--)
   (where (Plus1 N_0--) N_0)
   (where (Plus1 N_1--) N_1)]
  [(N=? N_0 N_1)
   #false])&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
 &lt;li&gt;the metafunction is named &lt;strong&gt;N=?&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;its contract is &lt;strong&gt;N N -&amp;gt; boolean&lt;/strong&gt;, this means &lt;strong&gt;N=?&lt;/strong&gt; expects 2 terms that  match the &lt;strong&gt;N&lt;/strong&gt; pattern and returns a term that matches the pattern &lt;strong&gt;boolean&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;there are three cases; the second case is guarded by two &lt;strong&gt;where&lt;/strong&gt; clauses&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Any occurrence of &lt;strong&gt;(N=? &amp;hellip;.)&lt;/strong&gt; in any term is evaluated.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(term (N=? (Plus1 (Plus1 Zero)) (Plus1 (Plus1 Zero))))
;; #true
(term ((N=? Zero Zero) Zero))
;; '(#true Zero)
(term (N=? (Plus1 Zero) (Plus1 (Plus1 Zero))))
;; #false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any occurrence of &lt;strong&gt;N=?&lt;/strong&gt; outside a &lt;strong&gt;term&lt;/strong&gt; is an error.&lt;/p&gt;

&lt;p&gt;Metafunction &lt;strong&gt;where&lt;/strong&gt;-clauses are analogous to judgment form &lt;strong&gt;where&lt;/strong&gt;-clauses. See &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28tech._metafunction%29"&gt;the Redex reference&lt;/a&gt; for more.&lt;/p&gt;

&lt;p&gt;Note: the cases in a metafunction form a &lt;em&gt;sequence&lt;/em&gt;, not a &lt;em&gt;set&lt;/em&gt;. To evaluate a metafunction application, Redex tries each case in order  and returns the result of the first case that (1) matches the call-site (2)  for which all guards succeed.&lt;/p&gt;

&lt;h3 id="q-should-i-use-a-metafunction-or-a-judgment-form"&gt;Q. Should I use a metafunction or a judgment form?&lt;/h3&gt;

&lt;p&gt;Use a judgment form.&lt;/p&gt;

&lt;p&gt;Metafunctions are handy, but judgments are easier to read and debug and maintain.&lt;/p&gt;

&lt;h3 id="q-what-is-a-reduction-relation"&gt;Q. What is a reduction relation?&lt;/h3&gt;

&lt;p&gt;A reduction relation is a set of term-rewriting rules.&lt;/p&gt;

&lt;p&gt;Every reduction relation needs: (1) a language (2) a domain (3) a set of rewrite rules.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;The language tells Redex how to interpret patterns.&lt;/li&gt;
 &lt;li&gt;The domain is a pattern.  Input to the reduction relation must match the pattern,  and output from the reduction relation must match the pattern.&lt;/li&gt;
 &lt;li&gt;The rewrite rules have the form &lt;strong&gt;(&amp;mdash;&amp;gt; term term guard &amp;hellip;)&lt;/strong&gt;.  The term on the left is the input, the term on the right is the output.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;See &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28form._%28%28lib._redex%2Freduction-semantics..rkt%29._reduction-relation%29%29"&gt;the Redex reference&lt;/a&gt; for a full description of the guards.&lt;/p&gt;

&lt;p&gt;The preferred way to define a reduction relation is to define a language that includes three non-terminals:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;a non-terminal for the domain of the reduction relation&lt;/li&gt;
 &lt;li&gt;a non-terminal for a &lt;em&gt;subset&lt;/em&gt; of the domain that cannot reduce further&lt;/li&gt;
 &lt;li&gt;a non-terminal for evaluation contexts&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;An evaluation context is a term that contains a &lt;strong&gt;hole&lt;/strong&gt;. A reduction relation can match a term against an evaluation context to find  a sub-term to rewrite &amp;mdash; in particular, the sub-term that matches the &lt;strong&gt;hole&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In the following example, &lt;strong&gt;bexp&lt;/strong&gt; is the domain of a reduction relation. A &lt;strong&gt;bexp&lt;/strong&gt; term represents a boolean expression, which can be &lt;strong&gt;#true&lt;/strong&gt; or  &lt;strong&gt;#false&lt;/strong&gt; or a conjunction of expressions or a disjunction of expressions. The boolean expressions &lt;strong&gt;#true&lt;/strong&gt; and &lt;strong&gt;#false&lt;/strong&gt; are also values (&lt;strong&gt;val&lt;/strong&gt;);  these cannot reduce further. The non-terminal &lt;strong&gt;E&lt;/strong&gt; is for evaluation contexts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language Bool
  (bexp ::= #true #false (bexp ∧ bexp) (bexp ∨ bexp))
  (val ::= #true #false)
  (E ::= hole (E ∧ bexp) (val ∧ E) (E ∨ bexp) (val ∨ E)))

(define step
  (reduction-relation Bool
    #:domain bexp
    [--&amp;gt; (in-hole E (val_lhs ∧ val_rhs))
         (in-hole E val_new)
         ∧-step
         (where val_new ,(and (term val_lhs) (term val_rhs)))]
    [--&amp;gt; (in-hole E (val_lhs ∨ val_rhs))
         (in-hole E val_new)
         ∨-step
         (where val_new ,(or (term val_lhs) (term val_rhs)))]))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function &lt;strong&gt;apply-reduction-relation&lt;/strong&gt; applies a reduction relation to a  term and returns a list of ways that the term can step.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(apply-reduction-relation step (term #true))
;; '()
(apply-reduction-relation step (term (#true ∧ #true)))
;; '(#true)
(apply-reduction-relation step (term (#true ∧ #false)))
;; '(#false)
(apply-reduction-relation step (term ((#true ∨ #false) ∧ #true)))
;; '((#true ∧ #true))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three things about the reduction relation &lt;strong&gt;step&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Using &lt;strong&gt;in-hole&lt;/strong&gt; on the first argument of &lt;strong&gt;&amp;mdash;&amp;gt;&lt;/strong&gt; searches a term  for a subterm that Redex can apply a reduction rule to.&lt;/li&gt;
 &lt;li&gt;Using &lt;strong&gt;in-hole&lt;/strong&gt; on the second argument of &lt;strong&gt;&amp;mdash;&amp;gt;&lt;/strong&gt; puts a new value  back into the &lt;strong&gt;hole&lt;/strong&gt; in the evaluation context.&lt;/li&gt;
 &lt;li&gt;The unquote operator (&lt;strong&gt;,&lt;/strong&gt;) escapes to &amp;ldquo;Racket mode&amp;rdquo; (see below) to evaluate  a conjunction or disjunction.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;A judgment or metafunction is a formal alternative to &amp;ldquo;escaping to Racket&amp;rdquo;,  but escaping can be convenient.&lt;/p&gt;

&lt;p&gt;Note: the cases in a reduction relation form a &lt;em&gt;set&lt;/em&gt;, not a &lt;em&gt;sequence&lt;/em&gt;. If more than one case matches, Redex applies them all.&lt;/p&gt;

&lt;h3 id="q-what-is-racket-mode-what-is-redex-mode"&gt;Q. What is &amp;ldquo;Racket mode&amp;rdquo;? What is &amp;ldquo;Redex mode&amp;rdquo;?&lt;/h3&gt;

&lt;p&gt;Code in a Redex model is sometimes evaluated in &amp;ldquo;Racket mode&amp;rdquo; and  sometimes evaluated in &amp;ldquo;Redex mode&amp;rdquo;. Racket mode evaluates Racket syntax to Racket values. Redex mode evaluates Racket syntax (possibly containing metafunction names) to terms.&lt;/p&gt;

&lt;p&gt;Key points:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;A Redex program starts in Racket mode.&lt;/li&gt;
 &lt;li&gt;The &lt;strong&gt;X&lt;/strong&gt; in &lt;strong&gt;(term X)&lt;/strong&gt; is evaluated in Redex mode &amp;hellip;&lt;/li&gt;
 &lt;li&gt;&amp;hellip; unless &lt;strong&gt;X&lt;/strong&gt; contains unquoted sub-expressions. Unquoting escapes to Racket mode &amp;hellip;&lt;/li&gt;
 &lt;li&gt;&amp;hellip; and &lt;strong&gt;term&lt;/strong&gt;s inside an unquoted sub-expression are evaluated in Redex mode.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;In other words, &lt;strong&gt;term&lt;/strong&gt; enters Redex mode and &lt;strong&gt;unquote&lt;/strong&gt; (&lt;strong&gt;,&lt;/strong&gt;) escapes back to Racket.&lt;/p&gt;

&lt;p&gt;Redex implicitly switches to Redex mode in a few other places, for example:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;the right-side of a &lt;strong&gt;where&lt;/strong&gt; clause is in Redex mode&lt;/li&gt;
 &lt;li&gt;the result of a metafunction is in Redex mode&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;When in doubt, try using an &lt;strong&gt;unquote&lt;/strong&gt;. Redex will raise an exception if it finds an unquote in Racket mode.&lt;/p&gt;

&lt;h3 id="q-are-side-conditions-evaluated-in-racket-mode-or-redex-mode"&gt;Q. Are &lt;strong&gt;side-condition&lt;/strong&gt;s evaluated in &amp;ldquo;Racket mode&amp;rdquo; or &amp;ldquo;Redex mode&amp;rdquo;?&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;(side-condition e)&lt;/strong&gt; sometimes evaluates &lt;strong&gt;e&lt;/strong&gt; as a Racket expression  and sometimes evaluates &lt;strong&gt;e&lt;/strong&gt; as a Redex expression.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;reduction relations and metafunctions expect a &lt;strong&gt;Racket&lt;/strong&gt; expression&lt;/li&gt;
 &lt;li&gt;judgments expect a &lt;strong&gt;Redex&lt;/strong&gt; expression&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="q-what-is-a-binding-form"&gt;Q. What is a binding form?&lt;/h3&gt;

&lt;p&gt;In the lambda calculus, &lt;strong&gt;λ&lt;/strong&gt;-terms bind variables. A term &lt;strong&gt;(λ x M)&lt;/strong&gt; means that any free occurrence of &lt;strong&gt;x&lt;/strong&gt; in the sub-term &lt;strong&gt;M&lt;/strong&gt;  refers to the &lt;strong&gt;x&lt;/strong&gt; from the &lt;strong&gt;λ&lt;/strong&gt;-term.&lt;/p&gt;

&lt;p&gt;Redex can express this idea with a binding form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language Λ
  [e ::= (e e) x (λ x e)]
  [x ::= variable-not-otherwise-mentioned]
  #:binding-forms
  (λ x_0 e_0 #:refers-to x_0))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: all the non-terminals in a language must be defined before the &lt;strong&gt;#:binding-forms&lt;/strong&gt; keyword. If a non-terminal definition appears after the &lt;strong&gt;#:binding-forms&lt;/strong&gt; keyword, then Redex will interpret the &amp;ldquo;definition&amp;rdquo; as a binding form.&lt;/p&gt;

&lt;p&gt;Binding forms work together with Redex&amp;rsquo;s functions for substitution and  alphabetic equivalence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(alpha-equivalent? Λ
  (term (λ x x))
  (term (λ y y))))
;; #true

(define-metafunction Λ
  test-substitute : e -&amp;gt; e
  [(test-substitute (λ x_0 e_0))
   (substitute e_0 x_0 y)])
(term (test-substitute (λ z (z z))))
;; '(y y)&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-is--what-is-"&gt;Q. What is &lt;strong&gt;&amp;hellip;&lt;/strong&gt;? What is &lt;strong&gt;&amp;hellip;.&lt;/strong&gt;?&lt;/h3&gt;

&lt;p&gt;Three dots (&lt;strong&gt;&amp;hellip;&lt;/strong&gt;) is for building patterns. If &lt;strong&gt;p&lt;/strong&gt; is a pattern then &lt;strong&gt;(p &amp;hellip;)&lt;/strong&gt; matches any list whose elements all  match &lt;strong&gt;p&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language L)
(redex-match? L (number ... boolean ...) (term (1 2 #true #true)))
;; #true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Four dots (&lt;strong&gt;&amp;hellip;.&lt;/strong&gt;) may be used in &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28form._%28%28lib._redex%2Freduction-semantics..rkt%29._define-extended-language%29%29"&gt;&lt;strong&gt;define-extended-language&lt;/strong&gt;&lt;/a&gt;  to extend a previosly-defined non-terminal.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language C
  (keyword ::= auto break case))
(define-extended-language C++
  C
  (keyword ::= .... class))

(redex-match? C keyword (term auto))
;; #true
(redex-match? C keyword (term class))
;; #false
(redex-match? C++ keyword (term auto))
;; #true
(redex-match? C++ keyword (term class))
;; #true&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-where-to-learn-more-about-redex"&gt;Q. Where to learn more about Redex?&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Critical path&amp;rdquo; resources:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Redex documentation: &lt;a href="http://docs.racket-lang.org/redex/index.html"&gt;http://docs.racket-lang.org/redex/index.html&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;A longer tutorial: &lt;a href="https://dvanhorn.github.io/redex-aam-tutorial/"&gt;https://dvanhorn.github.io/redex-aam-tutorial/&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;Source code for this post: &lt;a href="https://github.com/nuprl/website/blob/master/blog/static/redex-faq.rkt"&gt;https://github.com/nuprl/website/blob/master/blog/static/redex-faq.rkt&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;Redex source code (see &lt;code&gt;redex-lib/&lt;/code&gt;): &lt;a href="https://github.com/racket/redex"&gt;https://github.com/racket/redex&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;Procrastination&amp;rdquo; resources:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Tree Automata: &lt;a href="http://tata.gforge.inria.fr/"&gt;http://tata.gforge.inria.fr/&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;Should your Specification Language be Typed?&lt;/em&gt;: &lt;a href="http://lamport.azurewebsites.net/pubs/lamport-types.pdf"&gt;http://lamport.azurewebsites.net/pubs/lamport-types.pdf&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;Source code for this post: &lt;a href="https://github.com/nuprl/website/blob/master/blog/_src/posts/2017-09-25-redex-faq.md"&gt;https://github.com/nuprl/website/blob/master/blog/_src/posts/2017-09-25-redex-faq.md&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry></feed>