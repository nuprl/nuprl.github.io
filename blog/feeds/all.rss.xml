<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>PRL Blog: PRL Blog</title>
  <description>PRL Blog: PRL Blog</description>
  <link>http://prl.ccs.neu.edu/blog/index.html</link>
  <lastBuildDate>Fri, 19 Jan 2018 17:05:00 UT</lastBuildDate>
  <pubDate>Fri, 19 Jan 2018 17:05:00 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>[Untyped Programs Don't Exist (cross-post)](https://williamjbowman.com/blog/2018/01/19/untyped-programs-don-t-exist/)</title>
   <link>http://prl.ccs.neu.edu/blog/2018/01/19/-untyped-programs-don-t-exist-cross-post-https-williamjbowman-com-blog-2018-01-19-untyped-programs-don-t-exist?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2018-01-19-untyped-programs-don-t-exist-cross-post-https-williamjbowman-com-blog-2018-01-19-untyped-programs-don-t-exist</guid>
   <pubDate>Fri, 19 Jan 2018 17:05:00 UT</pubDate>
   <author>PRL</author>
   <description></description></item>
  <item>
   <title>[How to prove a compiler correct (cross-post)](https://dbp.io/essays/2018-01-16-how-to-prove-a-compiler-correct.html)</title>
   <link>http://prl.ccs.neu.edu/blog/2018/01/17/-how-to-prove-a-compiler-correct-cross-post-https-dbp-io-essays-2018-01-16-how-to-prove-a-compiler-correct-html?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2018-01-17-how-to-prove-a-compiler-correct-cross-post-https-dbp-io-essays-2018-01-16-how-to-prove-a-compiler-correct-html</guid>
   <pubDate>Wed, 17 Jan 2018 20:58:48 UT</pubDate>
   <author>PRL</author>
   <description></description></item>
  <item>
   <title>Monotonicity Types: Towards A Type System for Eventual Consistency</title>
   <link>http://prl.ccs.neu.edu/blog/2017/10/22/monotonicity-types-towards-a-type-system-for-eventual-consistency?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-10-22-monotonicity-types-towards-a-type-system-for-eventual-consistency</guid>
   <pubDate>Sun, 22 Oct 2017 11:59:06 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;A few weeks back, we published a draft of an article entitled &lt;a href="https://infoscience.epfl.ch/record/231867"&gt;&lt;em&gt;Monotonicity Types&lt;/em&gt;&lt;/a&gt;. In it, we describe a type system which we hope can aid the design of distributed systems by tracking monotonicity with types.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;But first, what, precisely, do we mean by &lt;em&gt;monotonicity&lt;/em&gt;? Here&amp;rsquo;s a short definition:&lt;/p&gt;

&lt;p&gt;A partially ordered set is a set 
 &lt;script type="math/tex"&gt;P&lt;/script&gt; endowed with a relation 
 &lt;script type="math/tex"&gt;\leq&lt;/script&gt; such that for all 
 &lt;script type="math/tex"&gt;p, q, r \in P&lt;/script&gt; we have:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;script type="math/tex"&gt;p \leq p&lt;/script&gt; (reflexivity)&lt;/li&gt;
 &lt;li&gt;
  &lt;script type="math/tex"&gt;p \leq  q&lt;/script&gt; and 
  &lt;script type="math/tex"&gt;q \leq r&lt;/script&gt; implies 
  &lt;script type="math/tex"&gt;p \leq r&lt;/script&gt; (transitivity)&lt;/li&gt;
 &lt;li&gt;
  &lt;script type="math/tex"&gt;p \leq q&lt;/script&gt; and 
  &lt;script type="math/tex"&gt;q \leq p&lt;/script&gt; implies 
  &lt;script type="math/tex"&gt;p = q&lt;/script&gt; (anti-symmetry)&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;If 
 &lt;script type="math/tex"&gt;P&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt; are partially ordered sets, we say that a function 
 &lt;script type="math/tex"&gt;f : P \to Q&lt;/script&gt; between them is &lt;em&gt;monotone&lt;/em&gt; if for all 
 &lt;script type="math/tex"&gt;p_1, p_2 \in P&lt;/script&gt; with 
 &lt;script type="math/tex"&gt;p_1 \leq p_2&lt;/script&gt;, we have 
 &lt;script type="math/tex"&gt;f(p_1) \leq f(p_2)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;So, said another way, increasing the input to a monotone function causes an increase to its output.&lt;/p&gt;

&lt;p&gt;Particularly in the context of concurrent and distributed programming, monotonicity has arisen time and time again as an important property. Designers of languages for coordination-free distributed programming such as Lasp [&lt;a href="#ref1"&gt;Meiklejohn et al. (2015)&lt;/a&gt;] and BloomL [&lt;a href="#ref1"&gt;Conway et al. (2012)&lt;/a&gt;], as well as designers of data types and abstractions for eventual consistency or determinism such as CRDTs [&lt;a href="#ref3"&gt;Shapiro et al. (2011)&lt;/a&gt;] and LVars [&lt;a href="#ref4"&gt;Kuper et al. (2013)&lt;/a&gt;] have noticed that monotonic evolution of program state over time is a necessary property in their designs. Lasp and BloomL in particular require the use of monotone functions as primitives of program composition.&lt;/p&gt;

&lt;p&gt;Thus if a user would like to make use of such a language for concurrent and distributed programming, they&amp;rsquo;re required to write monotonic program functions, which can actually be quite tricky, in order to get the consistency or determinism guarantees that the given language/abstraction was designed to provide.&lt;/p&gt;

&lt;p&gt;To get a better idea of how monotonicity might be important in the context of data replicated over a distributed system, let&amp;rsquo;s look at an example. Suppose we need a function to determine whether a replicated counter&amp;rsquo;s current value is odd or even, and further suppose that this counter can only be incremented. To accomplish this, we might apply the following function to the counter&amp;rsquo;s value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun IsOdd(x : Nat) = x % 2 == 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the counter replica from which the argument x is obtained may not currently have an up-to-date count of the total number of increments performed in the entire system. We can&amp;rsquo;t rule out the possibility that exactly one remote increment has been performed, in which case IsOdd produces the wrong answer. With this in mind, the value returned by IsOdd does not seem to tell us anything useful. In contrast, consider an application of the following function to the same replicated counter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun MoreThanTen(x : Nat) = x &amp;gt; 10&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The boolean values 
 &lt;script type="math/tex"&gt;true&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;false&lt;/script&gt; form one of the simplest partially ordered sets of all. We consider 
 &lt;script type="math/tex"&gt;false \leq false&lt;/script&gt;, 
 &lt;script type="math/tex"&gt;false \leq true&lt;/script&gt;, and 
 &lt;script type="math/tex"&gt; true \leq true&lt;/script&gt;. Under this ordering, the MoreThanTen function is monotone: an increase in x can cause the value of 
 &lt;script type="math/tex"&gt;x &gt; 10&lt;/script&gt; to flip from false to true, but not vice versa. When we observe that the local counter replica P&amp;rsquo;s value is greater than 10, we don&amp;rsquo;t know that the same observation would be drawn from remote replicas. Nonetheless, we assume that all replicas in the system will eventually become aware of all increments that P is currently aware of, at which point their values will be greater than P&amp;rsquo;s current value. This is where MoreThanTen&amp;rsquo;s monotonicity becomes useful. At the point when all replicas have received P&amp;rsquo;s current information, every replica in the system will agree that MoreThanTen applied to the counter&amp;rsquo;s value returns true.&lt;/p&gt;

&lt;p&gt;We believe that a type system for proving functions monotone could push the development of coordination-free distributed and concurrent applications outside of the realm of distributed systems experts, by enabling customization and extension of such systems by non-experts.&lt;/p&gt;

&lt;p&gt;Towards this aim, we have been designing a typed lambda calculus in which types track monotonicity. Our approach allows the programmer to write a special kind of function definition, called an &lt;em&gt;sfun&lt;/em&gt;, the body of which is type checked using a richer type system, one which reasons about function composition rather than application. Such a function can be proven monotone by utilizing, among other principles, the fact that the composition of two monotone functions is itself monotone. Monotonicity is a relational property; that is, its a property involving multiple applications of the same function. Such properties are blind spot for traditional type systems, so our design requires some unusual and interesting features.&lt;/p&gt;

&lt;p&gt;Reasoning about pointwise orderings on function spaces seems a bit heavy-weight and hasn’t been necessary for any of my use cases. An sfun is therefore first order; that is, both its return type and all of its argument types must be data types rather than function types. We would like to be able to prove that a multi-argument function is monotone &lt;em&gt;separately&lt;/em&gt; in each of its arguments; that is, for 
 &lt;script type="math/tex"&gt;i \in 1..n&lt;/script&gt;, if 
 &lt;script type="math/tex"&gt;p_i \leq p_i'&lt;/script&gt; then 
 &lt;script type="math/tex"&gt;f(p_1, \ldots, p_i, \ldots, p_n) \leq f(p_1, \ldots p_i', \ldots p_n)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The monotonicity of an sfun is typically derived from the monotonicity of the primitives used to implement it, which are also sfuns. Here are some example sfun primitives, addition and subtraction on integers:&lt;/p&gt;

&lt;p&gt;1.) plus : 
 &lt;script type="math/tex"&gt; (x : Int, y : Int) \Rightarrow Int[\uparrow x, \uparrow y]&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;2.) minus : 
 &lt;script type="math/tex"&gt; (x : Int, y : Int) \Rightarrow Int[\uparrow x, \downarrow y]&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;sfun type&lt;/em&gt;, written with 
 &lt;script type="math/tex"&gt;\Rightarrow&lt;/script&gt; rather than 
 &lt;script type="math/tex"&gt;\rightarrow&lt;/script&gt;, names its formal arguments and also &lt;em&gt;qualifies&lt;/em&gt; each one. A qualifier is an argument-specific constraint on the behavior of the function. In the above types, the qualifier 
 &lt;script type="math/tex"&gt;\uparrow&lt;/script&gt; is associated with arguments that are separately monotone and 
 &lt;script type="math/tex"&gt;\downarrow&lt;/script&gt; is associated with arguments that are separately antitone. The second argument of a binary function 
 &lt;script type="math/tex"&gt;f&lt;/script&gt; is separately antitone if 
 &lt;script type="math/tex"&gt;p_2 \leq p_2'&lt;/script&gt; implies 
 &lt;script type="math/tex"&gt;f(p_1, p_2) \geq f(p_1, p_2')&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Terms outside of sfun abstractions are typed using a &lt;em&gt;global&lt;/em&gt; typing relation, which, aside from an sfun abstraction typing rule, is not different from the typing relations we are familiar with. A global typing judgment has the following form.&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex"&gt; \Gamma \vdash t : T&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;A typing judgment of the lifted type system, used to type check the body of an sfun, has the following form:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex"&gt; \Gamma;\Omega;\Phi \vdash t : T&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Here the &lt;em&gt;global type environment&lt;/em&gt; 
 &lt;script type="math/tex"&gt; \Gamma&lt;/script&gt; contains all of the variables bound outside of the sfun, the &lt;em&gt;ambient type environment&lt;/em&gt; 
 &lt;script type="math/tex"&gt; \Omega&lt;/script&gt; contains the list of the sfun’s formal arguments, and the &lt;em&gt;lifted type environment&lt;/em&gt; 
 &lt;script type="math/tex"&gt; \Phi&lt;/script&gt; contains those variables in 
 &lt;script type="math/tex"&gt; t&lt;/script&gt;’s context which are bound inside the sfun. Before getting into the significance of lifted typing judgments, let&amp;rsquo;s look at a specific application of the global typing rule for sfun abstractions, which uses a single lifted premise.&lt;/p&gt;

&lt;p&gt;$$\frac{\Gamma;x:Int;x:Int[=~x] \vdash plus(x,x) : Int[\uparrow~x]}  {\Gamma \vdash \tilde{\lambda} x : Int. plus(x,x) : ( x : Int ) \Rightarrow Int[\uparrow~x]}$$&lt;/p&gt;

&lt;p&gt;Here we type a single-argument sfun abstraction 
 &lt;script type="math/tex"&gt;\tilde{\lambda} x:Int. plus(x,x)&lt;/script&gt;. As you might have guessed, 
 &lt;script type="math/tex"&gt;\tilde{\lambda}&lt;/script&gt; is used rather that 
 &lt;script type="math/tex"&gt;\lambda&lt;/script&gt; to distinguish this as an sfun abstraction rather than a standard one. Examine the ambient and lifted type environments used in the premise. Perhaps surprisingly, the abstraction&amp;rsquo;s bound variable 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; is entered into both environments. When variables occur in types, they are considered references to formal arguments rather than actual arguments; that is, an occurrence of 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; in a type (for example 
 &lt;script type="math/tex"&gt;Int[\uparrow x]&lt;/script&gt;) does not refer to some integer, but instead a &amp;ldquo;slot&amp;rdquo; named 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; which expects to receive some integer from an external source. Inside the scope of the sfun abstraction, we would like the ability to refer to the abstraction&amp;rsquo;s formal argument 
 &lt;script type="math/tex"&gt;x&lt;/script&gt;, and therefore we add 
 &lt;script type="math/tex"&gt;x : Int&lt;/script&gt; to the ambient environment. We would also like to include occurrences of 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; as terms in the body of the abstraction; for these, we add the entry 
 &lt;script type="math/tex"&gt;x : Int[=~x]&lt;/script&gt; into the lifted type environment, to be used as a placeholder for the actual argument supplied to the formal argument 
 &lt;script type="math/tex"&gt;x&lt;/script&gt;. Because references to formal arguments occur only in types, and references to actual arguments occur only in terms, we can add entries with the same name to both the ambient and lifted environments without creating any ambiguity. In particular, this means that the occurrence of 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; in Int[
 &lt;script type="math/tex"&gt;\uparrow x&lt;/script&gt;] refers to the entry for 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; in the ambient type environment rather than the one in the lifted type environment.&lt;/p&gt;

&lt;p&gt;The premise of the above rule application includes the strange looking types 
 &lt;script type="math/tex"&gt;Int[=~x]&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;Int[\uparrow~x]&lt;/script&gt;. Normally, we would expect occurrences of x, which serve as placeholders for the actual argument of the the function, to have type 
 &lt;script type="math/tex"&gt;Int&lt;/script&gt;, and we would expect our abstraction&amp;rsquo;s body 
 &lt;script type="math/tex"&gt;plus(x,x)&lt;/script&gt; to have type 
 &lt;script type="math/tex"&gt;Int&lt;/script&gt; as well. This traditional approach to typing a function abstraction characterizes the operational behavior of a single function &lt;em&gt;after&lt;/em&gt; it has been applied. Unfortunately, this isn&amp;rsquo;t adequate for reasoning about properties such as monotonicity, which involve multiple calls to the same function. My approach instead takes the perspective of inside of a function, &lt;em&gt;before&lt;/em&gt; it has been applied. Lifted typing then characterizes the structure of a function as the composition of its constituent parts. In the above example, an occurrence of the variable 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; in the term 
 &lt;script type="math/tex"&gt;plus(x,x)&lt;/script&gt; has type 
 &lt;script type="math/tex"&gt;Int[=~x]&lt;/script&gt;, meaning that it is a function which takes the value provided to 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; (the enclosing sfun&amp;rsquo;s formal argument) as an input, and produces that value unchanged as a result. We ultimately care about the input/output relation of this function, and so the concrete values which inhabit this type are set-of-pairs function representations, called &lt;em&gt;ambient maps&lt;/em&gt;. The type 
 &lt;script type="math/tex"&gt;Int[=~x]&lt;/script&gt; happens to be a singleton type, containing the set of pairs 
 &lt;script type="math/tex"&gt;\{ (0,0), (1,1), (-1,-1), (2,2), (-2-2), \ldots \}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The sfun application 
 &lt;script type="math/tex"&gt;plus(x,x)&lt;/script&gt; is viewed as a function composition, where the outputs of the functions represented by the two occurrences of 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; are forwarded into the left and right arguments of the sfun 
 &lt;script type="math/tex"&gt;plus&lt;/script&gt;. The domain of this composite function matches the domain 
 &lt;script type="math/tex"&gt;x:Int&lt;/script&gt; of the enclosing sfun, which it inherits from the two occurrences of 
 &lt;script type="math/tex"&gt;x&lt;/script&gt;. Since 
 &lt;script type="math/tex"&gt;plus&lt;/script&gt; returns an 
 &lt;script type="math/tex"&gt;Int&lt;/script&gt;, so does the composite function 
 &lt;script type="math/tex"&gt;plus(x,x)&lt;/script&gt;. The premise of the above typing rule application tells us that 
 &lt;script type="math/tex"&gt;plus(x,x)&lt;/script&gt; has type 
 &lt;script type="math/tex"&gt;Int[\uparrow~x]&lt;/script&gt;, but this premise must be derived. We previously hinted that such a derivation may utilize the fact that the composition of two monotone functions is itself monotone, and indeed that is one aspect of the premise&amp;rsquo;s derivation, but a full treatment is outside the scope of this post.&lt;/p&gt;

&lt;p&gt;Since lifted typing is all about function composition, one might wonder how we treat occurrences of 
 &lt;script type="math/tex"&gt; \Gamma&lt;/script&gt;&amp;rsquo;s variables within the body of an sfun. Such a variable might have the type 
 &lt;script type="math/tex"&gt; Int&lt;/script&gt;, representing a data value rather than a function. In fact, a piece of data can be viewed as a degenerate, constant-valued function, which produces the same result regardless of which actual arguments any particular sfun is applied to. Subtyping rules enable the flexible use of terminal variables within the body of an sfun, permitting a variable of type 
 &lt;script type="math/tex"&gt; Int&lt;/script&gt;, for example, to occur in a context where terms of type 
 &lt;script type="math/tex"&gt; Int[ \uparrow x ]&lt;/script&gt; are expected. A constant function 
 &lt;script type="math/tex"&gt;f&lt;/script&gt;, after all, is monotone: 
 &lt;script type="math/tex"&gt; v_1 \leq v_2&lt;/script&gt; implies 
 &lt;script type="math/tex"&gt; f(v_1) = c \leq c = f(v_2)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re not building lifted typing derivations just for fun. Typically, a type system comes with a soundness theorem stating that whenever a typing judgment of the form 
 &lt;script type="math/tex"&gt; \Gamma \vdash t : T&lt;/script&gt; is derivable, the execution of the term 
 &lt;script type="math/tex"&gt;t&lt;/script&gt; (a program) under some well-defined model of computation (typically defined along with the type system) satisfies some desirable property. In our system, a terminal typing derivation 
 &lt;script type="math/tex"&gt; \Gamma \vdash t : T&lt;/script&gt; implies that when the free variables of t are substituted with appropriately-typed values, the execution of the term 
 &lt;script type="math/tex"&gt; t&lt;/script&gt; is guaranteed to terminate, producing a value of type 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; as its result. This is not a terribly unusual soundness guarantee. However, to provide semantics for lifted typing judgments, we introduced a new reduction relation (or &amp;ldquo;computation model&amp;rdquo;) which can be viewed in one of two ways:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;The simultaneous reduction of an sfun, under terminal reduction, when applied to all sets of arguments in its domain.&lt;/li&gt;
 &lt;li&gt;The composition of an sfun&amp;rsquo;s components, before the sfun is ever applied.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Point 1 is essentially the motivation for having lifted typing and lifted reduction in the first place. We want to know how the sfun behaves under terminal reduction, across multiple applications&amp;mdash;specifically two applications in the case of monotonicity. If the lifted reduction of an sfun&amp;rsquo;s body faithfully simulates the terminal reduction of all possible applications simultaneously, then the body of a well-typed sfun should normalize to an ambient map that is extensionally equivalent to the sfun&amp;rsquo;s applicative behavior under terminal reduction. Therefore, if our soundness theorem guarantees that the derivability of 
 &lt;script type="math/tex"&gt; \cdot;x:Int;x:Int[=~x] \vdash plus(x,x) : Int[\uparrow~x]&lt;/script&gt; implies that 
 &lt;script type="math/tex"&gt; plus(\{ (0,0), (1,1), \ldots \},\{ (0,0), (1,1), \ldots \} )&lt;/script&gt; normalizes under lifted reduction to a monotone ambient map, we then know that the sfun 
 &lt;script type="math/tex"&gt; \tilde{\lambda} x : Int. plus(x,x)&lt;/script&gt; behaves monotonically under terminal reduction. It&amp;rsquo;s important to note that our model never requires us to actually perform lifted reduction; lifted reduction matters because not because we actual want to perform it, but instead because lifted typing derivations guarantee the existence of certain lifted reduction sequences which have implications for terminal reduction.&lt;/p&gt;

&lt;p&gt;Point 2 inspires our lifted type system. If an sfun is composed of monotone functions, we can use facts about preservation of monotonicity across function composition to prove the sfun itself monotone. The difference between terminal reduction and lifted reduction is demonstrated by the two mathematical expressions 
 &lt;script type="math/tex"&gt; f(g(v))&lt;/script&gt; and 
 &lt;script type="math/tex"&gt; (f \circ g) (v)&lt;/script&gt;.  The expression 
 &lt;script type="math/tex"&gt; f(g(v))&lt;/script&gt; presents function composition as viewed by a standard type systems: to apply the composition of 
 &lt;script type="math/tex"&gt;f&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;g&lt;/script&gt; to a value 
 &lt;script type="math/tex"&gt;v&lt;/script&gt;, we first apply 
 &lt;script type="math/tex"&gt;g&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;v&lt;/script&gt;, and then apply 
 &lt;script type="math/tex"&gt;f&lt;/script&gt; to the result. This isn&amp;rsquo;t wrong, but if 
 &lt;script type="math/tex"&gt; f&lt;/script&gt; and 
 &lt;script type="math/tex"&gt; g&lt;/script&gt; are both monotone, the monotonicity of the composite function as a whole becomes self-evident if we first perform the &amp;ldquo;lifted reduction step&amp;rdquo; 
 &lt;script type="math/tex"&gt; f(g(v)) \to (f \circ g) (v)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll leave you with an aspirational example, which demonstrates the need for a type system, rather than a more monolithic form of analysis, for proving functions monotone. Recall our replicated counter example from the introduction. It isn&amp;rsquo;t sufficient to store this counter as an integer. The problem is that replicas cannot synchronize properly without knowing which how many increments were performed at each replica. Suppose that replicas X and Y each start with a count of zero. The following actions are then performed:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;X increments, resulting in a count of 1&lt;/li&gt;
 &lt;li&gt;X sends a synchronization message to Y, containing X&amp;rsquo;s count 1&lt;/li&gt;
 &lt;li&gt;X receives a synchronization message from Y containing a count of 1&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;At stage 3, X does not know if the received message was sent from Y before or after Y received the synchronization message from stage 2. Replica X therefore does not know whether to set its count to 1 or 2. To avoid this problem, a replicated counter is commonly represented as a map, which maps each replica identifier (a natural number) to the number of increments that replica has performed (also a natural number). It is assumed that any replica id not contained in the map&amp;rsquo;s finite representation maps to 0. Such counters are called GCounters, and described in detail by [&lt;a href="#ref3"&gt;Shapiro et al. (2011)&lt;/a&gt;].&lt;/p&gt;

&lt;p&gt;GCounters are partially ordered componentwise. We write 
 &lt;script type="math/tex"&gt; v[a]&lt;/script&gt; for the natural number to which the GCounter 
 &lt;script type="math/tex"&gt;v&lt;/script&gt; maps the replica identifier 
 &lt;script type="math/tex"&gt;a&lt;/script&gt;, and we write 
 &lt;script type="math/tex"&gt; \leq&lt;/script&gt; for the standard ordering on natural numbers. The partial order 
 &lt;script type="math/tex"&gt; \leq'&lt;/script&gt; on GCounters is then defined such that 
 &lt;script type="math/tex"&gt; v \leq' w&lt;/script&gt; whenever for all replica identifiers 
 &lt;script type="math/tex"&gt;a&lt;/script&gt; we have 
 &lt;script type="math/tex"&gt; v[a] \leq w[a]&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;[&lt;a href="#ref1"&gt;Meiklejohn et al. (2015)&lt;/a&gt;] motivates combinators for replicated data types such as the GCounter, but requires that such combinators are monotone separately in each argument. Below is psuedocode for a monotone GCounter addition combinator, annotated with monotonicity types. NatMap is used as the type of maps from natural numbers to natural numbers. Several primitives are defined for working with NatMap. getAt retrieves the kth element of a NatMap m. joinAt returns a new NatMap which is equal to the argument m, except that it maps k to the maximum of m[k] and n. span returns the greatest key mapping to a non-zero value. emptyMap is a NatMap which maps every natural number to 0. + and &amp;gt; are standard arithmetic operators for working with natural numbers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getAt :: (m : NatMap, k : Nat) ⇒ Nat[↑ m, ? k]
joinAt :: (m : NatMap, k : Nat, n : Nat) ⇒ NatMap[↑ m, ? k, ↑ n]
span :: (m:NatMap) ⇒ Nat[↑ m]
max :: (a : Nat, b : Nat) ⇒ Nat[↑ a, ↑ b]
emptyMap :: NatMap
+ :: (x:Nat, y:Nat) ⇒ Nat[↑ x, ↑ y]
&amp;gt; :: (x:Nat, y:Nat) ⇒ Bool[↑ x, ↓ y]

type GCounter = { map : NatMap }

sfun sumCounters(x : GCounter, y : GCounter) 
 : GCounter[↑ x, ↑ y] =
 let xMap : NatMap[↑ x, ↑ y] = x.map
 let yMap : NatMap[↑ x, ↑ y] = y.map
 let maxSpan : Nat[↑ x, ↑ y] = max (span xMap) (span yMap)
 fun sumCell(k : Nat, acc : NatMap[↑ x, ↑ y]) 
  : NatMap[↑ x, ↑ y] =
  let cond : Bool[↑ x, ↓ y] = k &amp;gt; maxSpan
   if cond then
    acc
   else
    let acc' = joinAt acc k ((getAt xMap k) + (getAt yMap k))
    sumCell (k+1) acc'
 let initMap : IntArray[↑ x, ↑ y] = emptyMap
 GCounter { map = sumCell 0 initMap }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While our system can handle much of this example, it can&amp;rsquo;t handle everything yet, for several reasons. First, it involves an if condition which depends on the arguments of the enclosing sfun. To handle this, we would need to incorporate the notion of domain restriction into lifted reduction. Second, it involves recursion. This is problematic for us, because our system utilizes the fact that all well-typed programs terminate. We could partially address this by adding terminating fixpoint combinators, which allow recursion given some well-founded termination metric, as in [&lt;a href="#ref5"&gt;Vazou et al. (2014)&lt;/a&gt;]. However, that would not be adequate for this particular function. Since it could require arbitrarily many levels of recursion depending on which values are supplied as arguments, lifted reduction, which simulates an application to all arguments simultaneously, would diverge.&lt;/p&gt;

&lt;p&gt;So there&amp;rsquo;s still much to do! If you&amp;rsquo;re interested in more details behind the type system, have a look at Kevin&amp;rsquo;s blog article, &lt;a href="https://kevinclancy.github.io/2017/11/09/monotonicity-through-types.html"&gt;Monotonicity Through Types&lt;/a&gt;, or have a look at the full &lt;a href="https://infoscience.epfl.ch/record/231867"&gt;Monotonicity Types&lt;/a&gt; preprint for more.&lt;/p&gt;

&lt;h3 id="references"&gt;References&lt;/h3&gt;

&lt;p&gt;&lt;span id="ref1"&gt;C. Meiklejohn and P. Van Roy. &lt;em&gt;Lasp: A language for distributed, coordination-free programming.&lt;/em&gt; In Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming, PPDP ’15, pages 184–195, New York, NY, USA, 2015. ACM.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span id="ref2"&gt;N. Conway, W. R. Marczak, P. Alvaro, J. M. Hellerstein, and D. Maier. &lt;em&gt;Logic and lattices for distributed programming&lt;/em&gt;. In Proceedings of the Third ACM Symposium on Cloud Computing, SoCC ’12, pages 1:1–1:14, New York, NY, USA, 2012. ACM.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span id="ref3"&gt;M. Shapiro, N. Preguiça, C. Baquero, and M. Zawirski. &lt;em&gt;Conflict-Free replicated data types&lt;/em&gt;. In Stabilization, Safety, and Security of Distributed Systems, Lecture Notes in Computer Science, pages 386–400. Springer, Berlin, Heidelberg, Oct. 2011.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class="ref4"&gt;L. Kuper and R. R. Newton. &lt;em&gt;LVars: Lattice-based data structures for deterministic parallelism&lt;/em&gt;. In Proceedings of the 2nd ACM SIGPLAN Workshop on Functional High-performance Computing, FHPC ’13, pages 71–84, New York, NY, USA, 2013. ACM.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class="ref5"&gt;N. Vazou, E. L. Seidel, R. Jhala, D. Vytiniotis, and S. Peyton-Jones. &lt;em&gt;Refinement types for Haskell&lt;/em&gt;. SIGPLAN Not. 49, 9 (August 2014), 269&amp;ndash;282.&lt;/span&gt;&lt;/p&gt;</description></item>
  <item>
   <title>Final Algebra Semantics is Observational Equivalence</title>
   <link>http://prl.ccs.neu.edu/blog/2017/09/27/final-algebra-semantics-is-observational-equivalence?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-09-27-final-algebra-semantics-is-observational-equivalence</guid>
   <pubDate>Wed, 27 Sep 2017 15:44:57 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;Recently, &amp;ldquo;final encodings&amp;rdquo; and &amp;ldquo;finally tagless style&amp;rdquo; have become popular techniques for defining embedded languages in functional languages. In a recent discussion in the Northeastern PRL lab, &lt;a href="https://github.com/michaelballantyne"&gt;Michael Ballantyne&lt;/a&gt;, &lt;a href="http://ccs.neu.edu/home/ryanc"&gt;Ryan Culpepper&lt;/a&gt; and I asked &amp;ldquo;in what category are these actually final objects&amp;rdquo;? As it turns out our very own &lt;a href="http://www.ccs.neu.edu/home/wand/"&gt;Mitch Wand&lt;/a&gt; wrote one of the first papers to make exactly this idea precise, so I read it &lt;a href="https://www.cs.indiana.edu/ftp/techreports/TR65.pdf"&gt;available here&lt;/a&gt; and was pleasantly surprised to see that the definition of a final algebra there is essentially equivalent to the definition of observational equivalence.&lt;/p&gt;

&lt;p&gt;In this post, I&amp;rsquo;ll go over some of the results of that paper and explain the connection to observational equivalence. In the process we&amp;rsquo;ll learn a bit about categorical logic, and I&amp;rsquo;ll reformulate some of the category theory in that paper to be a bit more modern in presentation, cleaning some things up in the process.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="intuition-implementing-a-signature"&gt;Intuition: Implementing a Signature&lt;/h1&gt;

&lt;p&gt;As a running example, say we wanted to implement a datatype of finite maps whose keys and values are both integers, i.e., finite multisets of integers.&lt;/p&gt;

&lt;p&gt;We could specify such a datatype by specifying a little language of numbers and finite multisets. We&amp;rsquo;ll have two &amp;ldquo;sorts&amp;rdquo; &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;multiset&lt;/code&gt;, a constant for every integer, and an addition function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;'n : () -&amp;gt; num;
add : (num, num) -&amp;gt; num&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subject to the silly-looking equation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add('n,'m) = '(n + m)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and some operations on multisets&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;empty : () -&amp;gt; multiset;
singleton : (num) -&amp;gt; multiset;
union : (multiset, multiset) -&amp;gt; multiset;
remove : (num, multiset) -&amp;gt; multiset;
count : (num, multiset) -&amp;gt; num&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subject to the computational equations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count('n, empty) = '0
count('n, singleton('n)) = '1
count('n, singleton('m)) = '0
count('n, union(s,t)) = add(count('n,s), count('n, t))
count('n, remove('n,s)) = '0
count('n, remove('m,s)) = count('n,s)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are &amp;ldquo;all&amp;rdquo; of the equations we need to actually run our programs and get a number out, but not all the equations we intuitively &lt;em&gt;want&lt;/em&gt; for reasoning about our programs. For instance, clearly &lt;code&gt;union&lt;/code&gt; should be commutative, and &lt;code&gt;remove&lt;/code&gt; should be idempotent, but it&amp;rsquo;s impossible to prove that with just the equations specified. In fact, we can make a model of this theory that refutes them by constructing the &amp;ldquo;initial algebra&amp;rdquo;. In Haskell, we could say&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;data MultiSet = Empty 
  | Singleton Integer
  | Union MultiSet MultiSet
  | Remove Integer MultiSet
  deriving (Eq)

count :: Integer -&amp;gt; MultiSet -&amp;gt; Integer
count n Empty = 0
count n (Singleton m) | n == m = 1
count n (Singleton m) | n /= m = 0
count n (Union s t) = (count n s) + (count n t)
count n (Remove m s) | n == m = 0
count n (Remove m s) | n /= m = count n s
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Then it is completely obvious that all of our equations hold, but then &lt;code&gt;Union&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; commutative, as ghci will tell us:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&amp;gt; (Singleton 1 `Union` Singleton 2) == (Singleton 2 `Union` Singleton 1) 
False
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;However, there is another encoding that will give us that &lt;code&gt;union&lt;/code&gt; is commutative and &lt;code&gt;remove n&lt;/code&gt; is idempotent and actually every equation we could possibly want! It&amp;rsquo;s called the &amp;ldquo;final encoding&amp;rdquo; or &amp;ldquo;final algebra&amp;rdquo;. In Haskell, this looks like:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;data MultiSet&amp;#39; = MultiSet&amp;#39; { _count :: Integer -&amp;gt; Integer }

count&amp;#39; :: Integer -&amp;gt; MultiSet&amp;#39; -&amp;gt; Integer
count&amp;#39; n m = _count m n

empty :: MultiSet&amp;#39;
empty = MultiSet&amp;#39; { _count = \n -&amp;gt; 0 }

singleton :: Integer -&amp;gt; MultiSet&amp;#39;
singleton n = MultiSet&amp;#39; { _count = \m -&amp;gt; if n == m
                                         then 1
                                         else 0 }

union :: MultiSet&amp;#39; -&amp;gt; MultiSet&amp;#39; -&amp;gt; MultiSet&amp;#39;
union s t = MultiSet&amp;#39; { _count = \n -&amp;gt; (count&amp;#39; n s) + (count&amp;#39; n t) }

remove :: Integer -&amp;gt; MultiSet&amp;#39; -&amp;gt; MultiSet&amp;#39;
remove n s = MultiSet&amp;#39; { _count = \m -&amp;gt; if n == m
                                        then 0
                                        else count&amp;#39; n s }

test&amp;#39; = and [ count&amp;#39; n s == count&amp;#39; n t | n &amp;lt;- [0..1000]]
s = singleton 1 `union` singleton 2
t = singleton 2 `union` singleton 1
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Now we can verify that &lt;code&gt;union&lt;/code&gt; is commutative because&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;union s t = MultiSet&amp;#39; { _count = \n -&amp;gt; (count&amp;#39; n s) + (count&amp;#39; n t) }
          = MultiSet&amp;#39; { _count = \n -&amp;gt; (count&amp;#39; n t) + (count&amp;#39; n s) }
		  = union t s
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;since &lt;code&gt;+&lt;/code&gt; is commutative. Equality isn&amp;rsquo;t decidable anymore so I can&amp;rsquo;t give you a simple piece of code to witness this, but we can test our example before and we won&amp;rsquo;t be able to distinguish them, no surprise:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&amp;gt; let s = singleton 1 `union` singleton 2
&amp;gt; let t = singleton 2 `union` singleton 1
&amp;gt; and [ count&amp;#39; n s == count&amp;#39; n t | n &amp;lt;- [0..1000]]
True
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;How do we know this is the &amp;ldquo;best&amp;rdquo; or at least &amp;ldquo;most canonical&amp;rdquo; implementation of our datatype? The intuition is that we really don&amp;rsquo;t care at all &lt;em&gt;how&lt;/em&gt; our multisets are implemented as long as they behave the right way with respect to &lt;code&gt;count&lt;/code&gt; since &lt;code&gt;count&lt;/code&gt; returns an &lt;code&gt;Integer&lt;/code&gt;, a type we do understand. Our encoding accomplishes this by representing a multiset &lt;code&gt;s&lt;/code&gt; by the partially applied function &lt;code&gt;\n -&amp;gt; count n s&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The formal name for this idea is &lt;em&gt;observational equivalence&lt;/em&gt;. We say that two closed terms &lt;code&gt;s,t&lt;/code&gt; of sort &lt;code&gt;multiset&lt;/code&gt; are &lt;em&gt;observationally equivalent&lt;/em&gt; if for any term &lt;code&gt;C&lt;/code&gt; of type &lt;code&gt;num&lt;/code&gt; that has &lt;code&gt;s&lt;/code&gt; as a subterm, we can swap &lt;code&gt;t&lt;/code&gt; in for &lt;code&gt;s&lt;/code&gt; and prove that the two terms are equal. For instance &lt;code&gt;C&lt;/code&gt; might be &lt;code&gt;count(3, union(s, singleton(3)))&lt;/code&gt; or &lt;code&gt;add(4,remove(5,s))&lt;/code&gt;. Then we&amp;rsquo;ve reduced the possibly complicated equality for &lt;code&gt;multiset&lt;/code&gt; to the simple equality of &lt;code&gt;num&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Proving that the final encoding above satisfies all observational equivalences is beyond the scope of this blog post (see &lt;a href="https://hal.inria.fr/inria-00076514/document"&gt;here&lt;/a&gt;), but let&amp;rsquo;s see what all this talk about &amp;ldquo;algebras&amp;rdquo;, initial or final is all about.&lt;/p&gt;

&lt;h1 id="formalization-attempt-1-algebras-of-a-theory"&gt;Formalization Attempt 1: Algebras of a Theory&lt;/h1&gt;

&lt;p&gt;First, our little language of numbers and multisets is called a &lt;em&gt;theory&lt;/em&gt;. The specific category gadget that we&amp;rsquo;ll use to describe it is a &lt;em&gt;multi-sorted Lawvere theory&lt;/em&gt;, or just &lt;em&gt;Lawvere theory&lt;/em&gt; for short.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;Lawvere theory&lt;/em&gt; is a category with finite products all of whose objects are finite products of a collection of &lt;em&gt;sorts&lt;/em&gt; 
 &lt;script type="math/tex"&gt;S&lt;/script&gt;. We can construct this category from our little language above by making the objects be &lt;em&gt;contexts&lt;/em&gt; 
 &lt;script type="math/tex"&gt;x:num,y:multiset,...&lt;/script&gt; and morphisms 
 &lt;script type="math/tex"&gt;\Gamma \to
x_1:s_1,...,x_n:s_n&lt;/script&gt; to be 
 &lt;script type="math/tex"&gt;n&lt;/script&gt;-tuples of terms 
 &lt;script type="math/tex"&gt;\Gamma \vdash t_1 : s_1,...,
\Gamma \vdash t_n :  s_n&lt;/script&gt; &lt;em&gt;modulo&lt;/em&gt; the equations we&amp;rsquo;ve specified. We&amp;rsquo;ll use the letter 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; to mean a Lawvere theory.&lt;/p&gt;

&lt;p&gt;Then a &lt;em&gt;
  &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebra&lt;/em&gt; is a denotational semantics of our theory 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;, i.e., a product preserving functor 
 &lt;script type="math/tex"&gt;A : T \to Set&lt;/script&gt;. This means for every sort we get a set 
 &lt;script type="math/tex"&gt;A(s)&lt;/script&gt; and for every term 
 &lt;script type="math/tex"&gt;x_1:s_1,...,x_n:s_n
\vdash t : s&lt;/script&gt; a function 
 &lt;script type="math/tex"&gt;A(t) : A(s_1)\times\cdots \times A(s_n) \to
A(s)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Finally a &lt;em&gt;morphism of 
  &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebras&lt;/em&gt; from 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;B&lt;/script&gt; is a way to translate one algebra into another. Briefly, it is a natural transformation from 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;B&lt;/script&gt;, but concretely this means for every sort 
 &lt;script type="math/tex"&gt;s&lt;/script&gt; we get a function 
 &lt;script type="math/tex"&gt;\alpha_s : A(s) \to B(s)&lt;/script&gt; that translates 
 &lt;script type="math/tex"&gt;A&lt;/script&gt;s interpretation of 
 &lt;script type="math/tex"&gt;s&lt;/script&gt; as a set into 
 &lt;script type="math/tex"&gt;B&lt;/script&gt;s. The key property that we want is that the operations according to 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;B&lt;/script&gt; do the same thing as determined by 
 &lt;script type="math/tex"&gt;\alpha&lt;/script&gt;. Specifically, for any term 
 &lt;script type="math/tex"&gt;x_1:s_1,...,x_n:s_n \vdash t :
s&lt;/script&gt;, and inputs 
 &lt;script type="math/tex"&gt;x_1 \in A(s_1),...,x_n \in A(s_n)&lt;/script&gt; we should get the same result if we evaluate 
 &lt;script type="math/tex"&gt;A(t)(x_1,\ldots,x_n)&lt;/script&gt; and then apply 
 &lt;script type="math/tex"&gt;\alpha_s&lt;/script&gt; as if we first translate 
 &lt;script type="math/tex"&gt;x_1,\ldots,x_n&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;B(s_1),\ldots,B(s_n)&lt;/script&gt; and then apply 
 &lt;script type="math/tex"&gt;B(t)&lt;/script&gt;. If you unwind the definitions, this is exactly what naturality says.&lt;/p&gt;

&lt;p&gt;Then we have a category we&amp;rsquo;ll call 
 &lt;script type="math/tex"&gt;T-Alg&lt;/script&gt; of 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebras and we can ask if there are initial or final algebra. It turns out that both of them &lt;em&gt;always&lt;/em&gt; exist.&lt;/p&gt;

&lt;p&gt;The initial algebra is most famous here, we define for each sort 
 &lt;script type="math/tex"&gt;In(T)(s) = \cdot \vdash s&lt;/script&gt;, the closed terms of that sort modulo the equivalence of the theory, and 
 &lt;script type="math/tex"&gt;In(T)(s_1,\ldots,s_n) =
In(T)(s_1)\times\ldots,In(T)(s_n)&lt;/script&gt;. Then the terms are just interpreted as the functions you get by plugging closed inputs into them. Then if we look at what what a morphism of 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebras from 
 &lt;script type="math/tex"&gt;In(T) \to A&lt;/script&gt; is, we see that we don&amp;rsquo;t have any choice, the only one is the one that maps 
 &lt;script type="math/tex"&gt;\cdot \vdash t : s&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;A(t)&lt;/script&gt; and this makes all the right diagrams to commute. This is pretty similar to our definition of &amp;ldquo;initial algebra&amp;rdquo; before, except that this time we defined &lt;code&gt;count&lt;/code&gt; as a function, not just a case of an ADT, but that was just an easy way to satisfy the computational equations for &lt;code&gt;count&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, an egregious flaw presents itself when we look at what the &lt;em&gt;final&lt;/em&gt; algebra is. It&amp;rsquo;s completely trivial! We can define 
 &lt;script type="math/tex"&gt;Fin(T)&lt;/script&gt; to take every sort to a one element set 
 &lt;script type="math/tex"&gt;Fin(T)(s) = \{*\}&lt;/script&gt; and every term to the trivial function 
 &lt;script type="math/tex"&gt;\{*\}^n \to \{*\}&lt;/script&gt;. What the hell? This interprets numbers and multisets as trivial one-element sets. To rule this one out, we need to add some conditions to our algebras.&lt;/p&gt;

&lt;h1 id="formalization-algebras-of-a-theory-extension"&gt;Formalization: Algebras of a Theory Extension&lt;/h1&gt;

&lt;p&gt;To rule out these boring algebras, and get a nice final algebra, we have to recognize that the sorts &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;multiset&lt;/code&gt; in our theory are not really on equal footing. While we are not sure how multisets should be defined, we know &lt;em&gt;exactly&lt;/em&gt; what numbers are!&lt;/p&gt;

&lt;p&gt;To formalize this we&amp;rsquo;ll call the full theory 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; and the theory with just numbers 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt;. Then there should be a map from 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; that is the inclusion of theories. We&amp;rsquo;ll formalize this as a &lt;em&gt;morphism of theories&lt;/em&gt;. A morphism of theories is a &lt;em&gt;strict&lt;/em&gt; product-preserving functor from one theory to another. The strictness ensures that we don&amp;rsquo;t mix up our sorts and our contexts, a morphim of theories has to map sorts to sorts, whereas a non-strict functor could map a sort to a context with two sorts it&amp;rsquo;s equivalent to. What this really amounts to is a translation of one theory into another. It maps sorts to sorts and terms to terms of the appropriate sorts in a compositional way. However, we don&amp;rsquo;t want to consider &lt;em&gt;all&lt;/em&gt; such morphisms, only the ones that are &amp;ldquo;conservative extensions&amp;rdquo;, which means&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;there are no new closed terms at old types&lt;/li&gt;
 &lt;li&gt;closed terms that were different before remain different.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;In our example (1) ensures that we don&amp;rsquo;t add any new exotic numbers like &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;∞&lt;/code&gt;, and (2) ensures that we keep 
 &lt;script type="math/tex"&gt;0&lt;/script&gt; different from 
 &lt;script type="math/tex"&gt;1&lt;/script&gt;, like the final algebra did before by having all numbers have the same interpreation 
 &lt;script type="math/tex"&gt;*&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We can formalize this in the following way. Note that any morphism of Lawvere theories 
 &lt;script type="math/tex"&gt;m : T \to S&lt;/script&gt; induces a &lt;em&gt;functor&lt;/em&gt; on the category of algebras 
 &lt;script type="math/tex"&gt;m^* : S-Alg \to T-Alg&lt;/script&gt; by just composing functors. An 
 &lt;script type="math/tex"&gt;S&lt;/script&gt;-algebra is a functor from 
 &lt;script type="math/tex"&gt;S&lt;/script&gt; to sets, and 
 &lt;script type="math/tex"&gt;m&lt;/script&gt; is a functor from 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;S&lt;/script&gt; so we can compose to get 
 &lt;script type="math/tex"&gt;m^*(A)(t) = A(m(t))&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Now, we can express the idea of a conservative extension by saying that the canonical arrow from 
 &lt;script type="math/tex"&gt;In(T)&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;m^*(In(S))&lt;/script&gt; is an isomorphism. Recalling the definition of initial algebras, this says exactly that the closed terms in 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; up to 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;-equivalence are isomorphic to the closed terms of the type provided by 
 &lt;script type="math/tex"&gt;m&lt;/script&gt; in 
 &lt;script type="math/tex"&gt;S&lt;/script&gt; up to 
 &lt;script type="math/tex"&gt;S&lt;/script&gt;-equivalence. This is an equivalent formulation to the definition in Mitch&amp;rsquo;s paper, but there it is separated into two properties fullness and faithfulness, and doesn&amp;rsquo;t use the initial algebras and 
 &lt;script type="math/tex"&gt;m^*&lt;/script&gt; explicitly.&lt;/p&gt;

&lt;p&gt;Now we can verify that the inclusion 
 &lt;script type="math/tex"&gt;i : T_0 \to T_1&lt;/script&gt; of the number theory into the number-multiset theory is an extension in this sense.&lt;/p&gt;

&lt;p&gt;Finally we can define our notion of 
 &lt;script type="math/tex"&gt;i&lt;/script&gt;-algebra, which will be our correct notion of algebra. An 
 &lt;script type="math/tex"&gt;i&lt;/script&gt;-algebra is a 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; algebra 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; such that&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;The canonical algebra map 
  &lt;script type="math/tex"&gt;! : In(T_0) \to m^*A&lt;/script&gt; is an isomorphism.&lt;/li&gt;
 &lt;li&gt;The canonical algebra map 
  &lt;script type="math/tex"&gt;! : In(T_1) \to A&lt;/script&gt; is surjective i.e.,  for each sort 
  &lt;script type="math/tex"&gt;s, !_s&lt;/script&gt; is surjective.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The first condition says again that we have a conservative extension of 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt;, but the second is more interesting. It says that every denotation given by 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; is represented by some term in 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt;. In fact what it really ensures is that 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; determines a &lt;em&gt;congruence relation&lt;/em&gt; on 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; given by 
 &lt;script type="math/tex"&gt;t1 \equiv_A t2&lt;/script&gt; if 
 &lt;script type="math/tex"&gt;A(t1) = A(t2)&lt;/script&gt;. In light of this, the first condition could be called &lt;em&gt;adequacy&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Furthermore, the surjectivity condition ensures that any morphism of 
 &lt;script type="math/tex"&gt;i&lt;/script&gt; algebras, i.e., a map as 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt;-algebras is also surjective, so a morphism 
 &lt;script type="math/tex"&gt;A \to B&lt;/script&gt; is a witness to the fact that 
 &lt;script type="math/tex"&gt;B&lt;/script&gt; determines a &lt;em&gt;stronger&lt;/em&gt; congruence relation on 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; than 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; does: 
 &lt;script type="math/tex"&gt;t1 \equiv_B t2
\implies t1 \equiv_A t2&lt;/script&gt;. Then asking for a final algebra is asking for exactly the:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Strongest adequate congruence relation&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;which is exactly the definition of observational equivalence you will find in, say Pitt&amp;rsquo;s chapter of &lt;a href="https://www.cis.upenn.edu/~bcpierce/attapl/"&gt;Advanced TAPL&lt;/a&gt;. There is a difference in the meaning of &lt;em&gt;adequacy&lt;/em&gt;, though. Usually adequacy is defined in terms of an operational semantics, but here everything is based on an axiomatic notion of equality, but I think they play the same role in the two settings, so I think it&amp;rsquo;s reasonable to use the same word. On thing I like about this formulation is very nice though since it makes obvious that &lt;em&gt;adequacy&lt;/em&gt; is not a predetermined concept, we have to pick 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;i&lt;/script&gt; in order to know what adequacy means.&lt;/p&gt;

&lt;h1 id="conclusion-tying-it-back-to-final-encodings"&gt;Conclusion: Tying it back to Final Encodings&lt;/h1&gt;

&lt;p&gt;So now we&amp;rsquo;ve seen that&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Final algebras are equivalent to initial algebras modulo observational equivalence&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Of course we haven&amp;rsquo;t precisely gotten back to where we started: we were talking about denotational semantics in terms of sets and functions, but what we really want are implementations in our favorite programming languages. Fortunately, we didn&amp;rsquo;t use very many properties of sets in our definition, so it&amp;rsquo;s pretty easy to swap out the category of Sets for some category built out of the terms of our programming language. We can also swap out sets for some much cooler category of denotations like domains or metric spaces or time-varying values.&lt;/p&gt;

&lt;p&gt;Another question is how to implement this when we have a proper &lt;em&gt;type theory&lt;/em&gt; and not just some boring sorts. In particular, if we have function types, then we won&amp;rsquo;t be able to get functions from functions in our term model to functions in our denotations due to contravariance. Perhaps logical relations are the solution?&lt;/p&gt;</description></item>
  <item>
   <title>PLT Redex FAQ</title>
   <link>http://prl.ccs.neu.edu/blog/2017/09/25/plt-redex-faq?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-09-25-plt-redex-faq</guid>
   <pubDate>Mon, 25 Sep 2017 23:39:16 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;A short guide to Redex concepts, conventions, and common mistakes.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;To contribute to this FAQ, submit issues and pull requests to:  &lt;a href="https://github.com/nuprl/website/"&gt;https://github.com/nuprl/website/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id="q-what-is-redex-useful-for"&gt;Q. What is Redex useful for?&lt;/h3&gt;

&lt;ol&gt;
 &lt;li&gt;declaring &lt;a href="https://en.wikipedia.org/wiki/Regular_tree_grammar"&gt;regular tree grammars&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;defining &lt;em&gt;pattern&lt;/em&gt;-based judgments and relations on &lt;em&gt;terms&lt;/em&gt;&lt;/li&gt;
 &lt;li&gt;testing properties of the above&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;More generally, Redex is helpful for experimenting with a programming language  design, and helping you decide what you might want to prove about a language.&lt;/p&gt;

&lt;h3 id="q-what-is-redex-not-useful-for"&gt;Q. What is Redex &lt;strong&gt;not&lt;/strong&gt; useful for?&lt;/h3&gt;

&lt;p&gt;Proving theorems about a grammar, judgment, or relation.&lt;/p&gt;

&lt;h3 id="q-what-is-a-term"&gt;Q. What is a &lt;em&gt;term&lt;/em&gt;?&lt;/h3&gt;

&lt;p&gt;Informally, a term is:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;a Redex &amp;ldquo;atom&amp;rdquo;, or&lt;/li&gt;
 &lt;li&gt;an object that represents a sequence of characters.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;More formally, a term is the result of evaluating &lt;strong&gt;(term X)&lt;/strong&gt;, where &lt;strong&gt;X&lt;/strong&gt; is  any syntactically-correct Racket expression.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.10.0.3.
&amp;gt; (require redex/reduction-semantics)
&amp;gt; (term 42)
42
&amp;gt; (term (+ 2 2))
'(+ 2 2)
&amp;gt; (term ("hello" world (#false)))
'("hello" world (#f))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some terms may look strange. That&amp;rsquo;s OK, because a term by itself has no meaning.&lt;/p&gt;

&lt;p&gt;Terms can refer to previously-defined values using the &lt;strong&gt;unquote&lt;/strong&gt; escape.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; (define x (term 42))
&amp;gt; (term (+ 2 x))
'(+ 2 x)
&amp;gt; (term (+ ,x (unquote x)))
'(+ 42 42)&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-is-a-redex-model"&gt;Q. What is a &lt;em&gt;Redex model&lt;/em&gt;?&lt;/h3&gt;

&lt;p&gt;A Redex model is collection of tools for working with terms. The tools may include:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;em&gt;languages&lt;/em&gt;, to define a grammar for terms&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;judgments&lt;/em&gt;, to describe properties of terms or relations between terms&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;metafunctions&lt;/em&gt;, to transform terms&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;reduction relations&lt;/em&gt;, to defining a term rewriting system&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The goal of these tools is to encode a &amp;ldquo;real thing&amp;rdquo; (maybe, a programming language)  using Redex terms.&lt;/p&gt;

&lt;h3 id="q-what-is-a-language"&gt;Q. What is a language?&lt;/h3&gt;

&lt;p&gt;A Redex &lt;em&gt;language&lt;/em&gt; is a named set of non-terminals, &lt;em&gt;patterns&lt;/em&gt;, and &lt;em&gt;binding forms&lt;/em&gt;. For example, a Redex model of the natural numbers might start with this language:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language nat
  [N ::= Zero
         (Plus1 N)])&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
 &lt;li&gt;the name of the language is &lt;strong&gt;nat&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;the non-terminal &lt;strong&gt;N&lt;/strong&gt; is associated with two patterns: &lt;strong&gt;Zero&lt;/strong&gt; and &lt;strong&gt;(Plus1 N)&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;there are no &lt;em&gt;binding forms&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Each pattern describes a syntactic category of terms. Each non-terminal gives a name to the union of the patterns that follow it.&lt;/p&gt;

&lt;p&gt;The non-terminal &lt;strong&gt;N&lt;/strong&gt; describes all terms that are either:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;the symbol &lt;strong&gt;Zero&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;lists of the form &lt;strong&gt;(Plus1 N)&lt;/strong&gt;, where &lt;strong&gt;N&lt;/strong&gt; is either &lt;strong&gt;Zero&lt;/strong&gt; or another &amp;ldquo;Plus1&amp;rdquo;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(term Zero)
(term (Plus1 Zero))
(term (Plus1 (Plus1 Zero)))
(term (Plus1 (Plus1 (Plus1 Zero))))
;; .... and so on&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a language has binding forms, then some terms can introduce names. See the question on &lt;em&gt;binding forms&lt;/em&gt; (below) for an example.&lt;/p&gt;

&lt;h3 id="q-what-is-a-pattern"&gt;Q. What is a pattern?&lt;/h3&gt;

&lt;p&gt;A pattern is a sequence of characters and variables. If you have: (1) a language, and (2) a pattern that contains &lt;em&gt;named non-terminals&lt;/em&gt; from the language,  then you can ask whether a Redex term matches the pattern.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;named non-terminal&lt;/em&gt; for a language &lt;strong&gt;L&lt;/strong&gt; is an identifier made of:  (1) a non-terminal from &lt;strong&gt;L&lt;/strong&gt;, (2) an underscore (&lt;strong&gt;_&lt;/strong&gt;), and (3) any other identifier. See the FAQ entry below.&lt;/p&gt;

&lt;p&gt;For example, &lt;strong&gt;(redex-match? L p t)&lt;/strong&gt; returns &lt;strong&gt;#true&lt;/strong&gt; if the term &lt;strong&gt;t&lt;/strong&gt; matches  the pattern &lt;strong&gt;p&lt;/strong&gt; relative to the language &lt;strong&gt;L&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language nat
  [N ::= Zero (Plus1 N)])

(redex-match? nat N_some-name (term Zero))
;; #true
(redex-match? nat (Plus1 N_a) (term Zero))
;; #false
(redex-match? nat (Plus1 N_0) (term (Plus1 (Plus1 Zero))))
;; #true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;strong&gt;(redex-match? L p t)&lt;/strong&gt; is &lt;strong&gt;#true&lt;/strong&gt;, then &lt;strong&gt;(redex-match L p t)&lt;/strong&gt; shows how  named non-terminals in the pattern bind to subterms of &lt;strong&gt;t&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(redex-match nat N_0 (term Zero))
;; (list (match (list (bind 'N_0 'Zero))))
(redex-match nat (Plus1 N_0) (term Zero))
;; #f
(redex-match nat (Plus1 N_0) (term (Plus1 (Plus1 Zero))))
;; (list (match (list (bind 'N_0 '(Plus1 Zero)))))&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-is-a-named-non-terminal"&gt;Q. What is a named non-terminal?&lt;/h3&gt;

&lt;p&gt;A named non-terminal in a language &lt;strong&gt;L&lt;/strong&gt; is an identifier of the form &lt;strong&gt;X_Y&lt;/strong&gt;, where:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; is a non-terminal from &lt;strong&gt;L&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Y&lt;/strong&gt; is any identifier&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The name helps when one pattern contains multiple occurrences of the same non-terminal. If you want the two occurrences to bind the same term, then use the same name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language trees
  [binary-tree ::= Leaf
                   (Node binary-tree binary-tree)])

(redex-match trees
  (Node binary-tree_left binary-tree_right)
  (term (Node Leaf (Node Leaf Leaf))))
;; (list
;;  (match
;;   (list (bind 'binary-tree_left 'Leaf)
;;         (bind 'binary-tree_right '(Node Leaf Leaf)))))&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-else-can-patterns-express"&gt;Q. What else can patterns express?&lt;/h3&gt;

&lt;p&gt;Redex patterns may contain special identifiers to guide pattern-matching. For instance:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;The &lt;strong&gt;_&lt;/strong&gt; pattern matches any term (and does not bind).&lt;/li&gt;
 &lt;li&gt;A pattern &lt;strong&gt;(p &amp;hellip;)&lt;/strong&gt; matches any sequence whose elements match the pattern &lt;strong&gt;p&lt;/strong&gt;.  If the pattern &lt;strong&gt;p&lt;/strong&gt; is a named non-terminal, then the non-terminal binds  a sequence of subterms.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(redex-match? nat (Plus1 _) (term (Plus1 9)))
;; #true
(redex-match? nat (N_0 ...) (term ()))
;; #true
(redex-match? nat (N_0 ...) (term (Zero)))
;; #true
(redex-match nat (N_0 ...) (term (Zero Zero Zero)))
;; (list (match (list (bind 'N_0 '(Zero Zero Zero)))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28tech._pattern%29"&gt;the Redex reference&lt;/a&gt; for the full pattern language,  including the &lt;em&gt;named and unique non-terminals&lt;/em&gt; of the form &lt;strong&gt;X_!_Y&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id="q-what-can-patterns-not-express"&gt;Q. What can patterns &lt;strong&gt;not&lt;/strong&gt; express?&lt;/h3&gt;

&lt;ul&gt;
 &lt;li&gt;Disjunctions of patterns, e.g., &amp;ldquo;number or boolean&amp;rdquo;.  (Use a language non-terminal.)&lt;/li&gt;
 &lt;li&gt;Negations of patterns. (Compose &lt;strong&gt;not&lt;/strong&gt; with &lt;strong&gt;redex-match?&lt;/strong&gt;.)&lt;/li&gt;
 &lt;li&gt;Non-regular patterns. For example, one non-regular pattern is &amp;ldquo;all lists  that contain some number of integers followed by the same number of strings&amp;rdquo;.&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="q-what-is-a-judgment"&gt;Q. What is a judgment?&lt;/h3&gt;

&lt;p&gt;A Redex &lt;em&gt;judgment&lt;/em&gt; form defines a relation on terms. The relation is defined by a set of inference rules.&lt;/p&gt;

&lt;p&gt;Programming languages papers use inference rules all the time. Redex can express many of the judgments in papers; for example:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;well-formedness conditions (i.e., whether a term contains free variables)&lt;/li&gt;
 &lt;li&gt;type checking rules&lt;/li&gt;
 &lt;li&gt;type inference rules&lt;/li&gt;
 &lt;li&gt;evaluation relations&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Every judgment needs (1) a language (2) a mode (3) a contract (4) a set of inference rules. For example, the following judgment defines an equality relation on natural numbers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language nat
  [N ::= Zero (Plus1 N)])

(define-judgment-form nat
  #:mode (N= I I)
  #:contract (N= N N)
  [
   --- Zero=
   (N= Zero Zero)]
  [
   (where (Plus1 N_0--) N_0)
   (where (Plus1 N_1--) N_1)
   (N= N_0-- N_1--)
   --- Plus1=
   (N= N_0 N_1)])&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
 &lt;li&gt;the language is &lt;strong&gt;nat&lt;/strong&gt;; Redex uses the language to interpret patterns&lt;/li&gt;
 &lt;li&gt;the mode is &lt;strong&gt;(N= I I)&lt;/strong&gt;; this means &lt;strong&gt;N=&lt;/strong&gt; is the name of a judgment that  expects two input terms (or, &lt;strong&gt;N=&lt;/strong&gt; is a binary relation on terms)&lt;/li&gt;
 &lt;li&gt;the contract is &lt;strong&gt;(N= N N)&lt;/strong&gt;; in other words, &lt;strong&gt;N=&lt;/strong&gt; expects two terms that  match the &lt;strong&gt;N&lt;/strong&gt; non-terminal from the &lt;strong&gt;nat&lt;/strong&gt; language&lt;/li&gt;
 &lt;li&gt;there are two inference rules, named &lt;strong&gt;Zero=&lt;/strong&gt; and &lt;strong&gt;Plus1=&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;the &lt;strong&gt;Zero=&lt;/strong&gt; rule states that &lt;strong&gt;(N= Zero Zero)&lt;/strong&gt; always holds&lt;/li&gt;
 &lt;li&gt;the &lt;strong&gt;Plus1=&lt;/strong&gt; rule states that &lt;strong&gt;(N= N_0 N_1)&lt;/strong&gt; holds if &lt;strong&gt;N_0&lt;/strong&gt; and &lt;strong&gt;N_1&lt;/strong&gt;  are both &lt;strong&gt;Plus1&lt;/strong&gt; terms whose contents are related by &lt;strong&gt;N=&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The &lt;strong&gt;where&lt;/strong&gt; clauses are &lt;em&gt;guards&lt;/em&gt;. When Redex tries to apply a rule with premises of the form  &lt;strong&gt;(where pattern term)&lt;/strong&gt;, it checks that each pattern matches the corresponding term. If not, Redex stops applying the rule. See &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28form._%28%28lib._redex%2Freduction-semantics..rkt%29._define-judgment-form%29%29"&gt;the Redex reference&lt;/a&gt; for more.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(judgment-holds (N= Zero Zero))
;; #true
(judgment-holds (N= (Plus1 (Plus1 Zero)) (Plus1 (Plus1 Zero))))
;; #false
(judgment-holds (N= (Plus1 Zero) (Plus1 (Plus1 Zero))))
;; #true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: the inference rules form a &lt;em&gt;set&lt;/em&gt;, not a &lt;em&gt;sequence&lt;/em&gt;. So when you ask Redex whether &lt;strong&gt;(judgment-holds (N= Zero Zero))&lt;/strong&gt;, it applies  all rules that match &lt;strong&gt;(N= Zero Zero)&lt;/strong&gt;. For &lt;strong&gt;N=&lt;/strong&gt; this is just one rule, but in general it could be many rules.&lt;/p&gt;

&lt;h3 id="q-what-is-a-judgment-form-mode"&gt;Q. What is a judgment form &lt;strong&gt;#:mode&lt;/strong&gt;?&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;#:mode&lt;/strong&gt; declaration expects a list of the form &lt;strong&gt;(id pos-use &amp;hellip;)&lt;/strong&gt;,  where &lt;strong&gt;id&lt;/strong&gt; is an identifier and each &lt;strong&gt;pos-use&lt;/strong&gt; is either  &lt;strong&gt;I&lt;/strong&gt; or &lt;strong&gt;O&lt;/strong&gt;. These declarations say four things:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; is the name of a new judgment form&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; expects &lt;strong&gt;N&lt;/strong&gt; arguments, where &lt;strong&gt;N&lt;/strong&gt; is the number of &lt;strong&gt;pos-use&lt;/strong&gt; symbols&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; expects an &lt;em&gt;input&lt;/em&gt; at each position where the mode contains an &lt;strong&gt;I&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; produces an &lt;em&gt;output&lt;/em&gt; at each position where the mode contains an &lt;strong&gt;O&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For example, a type inference judgment may take an expression as input and output a type. Here&amp;rsquo;s a fast and easy type inference judgment for arithmetic expressions. Given any term &lt;strong&gt;e_0&lt;/strong&gt;, the judgment outputs the type &lt;strong&gt;Int&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language Arith
  (e ::= integer (e + e))
  (τ ::= Int))

(define-judgment-form Arith
  #:mode (infer-type I O)
  #:contract (infer-type e τ)
  [
   --- T-Int
   (infer-type e_0 Int)])&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-can-judgments-not-express"&gt;Q. What can judgments &lt;strong&gt;not&lt;/strong&gt; express?&lt;/h3&gt;

&lt;p&gt;Redex does not support inference rules that require guessing.&lt;/p&gt;

&lt;p&gt;One example of this is a transitivity rule: "&lt;strong&gt;τ_0&lt;/strong&gt; is related to &lt;strong&gt;τ_2&lt;/strong&gt;  if there exists a &lt;strong&gt;τ_1&lt;/strong&gt; such that &lt;strong&gt;τ_0&lt;/strong&gt; is related to &lt;strong&gt;τ_1&lt;/strong&gt; and &lt;strong&gt;τ_1&lt;/strong&gt; is  related to &lt;strong&gt;τ_2&lt;/strong&gt;". The following example tries to define a transitive subtyping (&lt;strong&gt;&amp;lt;:&lt;/strong&gt;) relation,  but Redex rejects the &lt;strong&gt;S-Trans&lt;/strong&gt; rule.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language SomeTypes
  (τ ::= (→ τ τ) Integer))

(define-judgment-form SomeTypes
  #:mode (&amp;lt;: I I)
  #:contract (&amp;lt;: τ τ)
  [
   (&amp;lt;: τ_0 τ_1)
   (&amp;lt;: τ_1 τ_2)
   --- S-Trans
   (&amp;lt;: τ_0 τ_2)]
  [
   --- S-Refl
   (&amp;lt;: τ_0 τ_0)]
  [
   (&amp;lt;: τ_dom-1 τ_dom-0)
   (&amp;lt;: τ_cod-0 τ_cod-1)
   --- S-Arrow
   (&amp;lt;: (→ τ_dom-0 τ_cod-0) (→ τ_dom-1 τ_cod-1))])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The error is that in the rule &lt;strong&gt;S-Trans&lt;/strong&gt;,  the named non-terminal &lt;strong&gt;τ_1&lt;/strong&gt; appears in an input position but is not bound to a term.&lt;/p&gt;

&lt;h3 id="q-what-is-a-metafunction"&gt;Q. What is a metafunction?&lt;/h3&gt;

&lt;p&gt;A metafunction is a term-level function on terms.&lt;/p&gt;

&lt;p&gt;Every metafunction needs: (1) a language (2) a name (3) a contract (4) a sequence of guarded input/output cases.&lt;/p&gt;

&lt;p&gt;Here is a metafunction that returns &lt;strong&gt;#true&lt;/strong&gt; when given two equal natural numbers. The definition is similar to the &lt;strong&gt;N=&lt;/strong&gt; judgment form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-metafunction nat
  N=? : N N -&amp;gt; boolean
  [(N=? Zero Zero)
   #true]
  [(N=? N_0 N_1)
   (N=? N_0-- N_1--)
   (where (Plus1 N_0--) N_0)
   (where (Plus1 N_1--) N_1)]
  [(N=? N_0 N_1)
   #false])&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
 &lt;li&gt;the metafunction is named &lt;strong&gt;N=?&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;its contract is &lt;strong&gt;N N -&amp;gt; boolean&lt;/strong&gt;, this means &lt;strong&gt;N=?&lt;/strong&gt; expects 2 terms that  match the &lt;strong&gt;N&lt;/strong&gt; pattern and returns a term that matches the pattern &lt;strong&gt;boolean&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;there are three cases; the second case is guarded by two &lt;strong&gt;where&lt;/strong&gt; clauses&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Any occurrence of &lt;strong&gt;(N=? &amp;hellip;.)&lt;/strong&gt; in any term is evaluated.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(term (N=? (Plus1 (Plus1 Zero)) (Plus1 (Plus1 Zero))))
;; #true
(term ((N=? Zero Zero) Zero))
;; '(#true Zero)
(term (N=? (Plus1 Zero) (Plus1 (Plus1 Zero))))
;; #false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any occurrence of &lt;strong&gt;N=?&lt;/strong&gt; outside a &lt;strong&gt;term&lt;/strong&gt; is an error.&lt;/p&gt;

&lt;p&gt;Metafunction &lt;strong&gt;where&lt;/strong&gt;-clauses are analogous to judgment form &lt;strong&gt;where&lt;/strong&gt;-clauses. See &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28tech._metafunction%29"&gt;the Redex reference&lt;/a&gt; for more.&lt;/p&gt;

&lt;p&gt;Note: the cases in a metafunction form a &lt;em&gt;sequence&lt;/em&gt;, not a &lt;em&gt;set&lt;/em&gt;. To evaluate a metafunction application, Redex tries each case in order  and returns the result of the first case that (1) matches the call-site (2)  for which all guards succeed.&lt;/p&gt;

&lt;h3 id="q-should-i-use-a-metafunction-or-a-judgment-form"&gt;Q. Should I use a metafunction or a judgment form?&lt;/h3&gt;

&lt;p&gt;Use a judgment form.&lt;/p&gt;

&lt;p&gt;Metafunctions are handy, but judgments are easier to read and debug and maintain.&lt;/p&gt;

&lt;h3 id="q-what-is-a-reduction-relation"&gt;Q. What is a reduction relation?&lt;/h3&gt;

&lt;p&gt;A reduction relation is a set of term-rewriting rules.&lt;/p&gt;

&lt;p&gt;Every reduction relation needs: (1) a language (2) a domain (3) a set of rewrite rules.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;The language tells Redex how to interpret patterns.&lt;/li&gt;
 &lt;li&gt;The domain is a pattern.  Input to the reduction relation must match the pattern,  and output from the reduction relation must match the pattern.&lt;/li&gt;
 &lt;li&gt;The rewrite rules have the form &lt;strong&gt;(&amp;mdash;&amp;gt; term term guard &amp;hellip;)&lt;/strong&gt;.  The term on the left is the input, the term on the right is the output.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;See &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28form._%28%28lib._redex%2Freduction-semantics..rkt%29._reduction-relation%29%29"&gt;the Redex reference&lt;/a&gt; for a full description of the guards.&lt;/p&gt;

&lt;p&gt;The preferred way to define a reduction relation is to define a language that includes three non-terminals:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;a non-terminal for the domain of the reduction relation&lt;/li&gt;
 &lt;li&gt;a non-terminal for a &lt;em&gt;subset&lt;/em&gt; of the domain that cannot reduce further&lt;/li&gt;
 &lt;li&gt;a non-terminal for evaluation contexts&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;An evaluation context is a term that contains a &lt;strong&gt;hole&lt;/strong&gt;. A reduction relation can match a term against an evaluation context to find  a sub-term to rewrite &amp;mdash; in particular, the sub-term that matches the &lt;strong&gt;hole&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In the following example, &lt;strong&gt;bexp&lt;/strong&gt; is the domain of a reduction relation. A &lt;strong&gt;bexp&lt;/strong&gt; term represents a boolean expression, which can be &lt;strong&gt;#true&lt;/strong&gt; or  &lt;strong&gt;#false&lt;/strong&gt; or a conjunction of expressions or a disjunction of expressions. The boolean expressions &lt;strong&gt;#true&lt;/strong&gt; and &lt;strong&gt;#false&lt;/strong&gt; are also values (&lt;strong&gt;val&lt;/strong&gt;);  these cannot reduce further. The non-terminal &lt;strong&gt;E&lt;/strong&gt; is for evaluation contexts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language Bool
  (bexp ::= #true #false (bexp ∧ bexp) (bexp ∨ bexp))
  (val ::= #true #false)
  (E ::= hole (E ∧ bexp) (val ∧ E) (E ∨ bexp) (val ∨ E)))

(define step
  (reduction-relation Bool
    #:domain bexp
    [--&amp;gt; (in-hole E (val_lhs ∧ val_rhs))
         (in-hole E val_new)
         ∧-step
         (where val_new ,(and (term val_lhs) (term val_rhs)))]
    [--&amp;gt; (in-hole E (val_lhs ∨ val_rhs))
         (in-hole E val_new)
         ∨-step
         (where val_new ,(or (term val_lhs) (term val_rhs)))]))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function &lt;strong&gt;apply-reduction-relation&lt;/strong&gt; applies a reduction relation to a  term and returns a list of ways that the term can step.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(apply-reduction-relation step (term #true))
;; '()
(apply-reduction-relation step (term (#true ∧ #true)))
;; '(#true)
(apply-reduction-relation step (term (#true ∧ #false)))
;; '(#false)
(apply-reduction-relation step (term ((#true ∨ #false) ∧ #true)))
;; '((#true ∧ #true))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three things about the reduction relation &lt;strong&gt;step&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Using &lt;strong&gt;in-hole&lt;/strong&gt; on the first argument of &lt;strong&gt;&amp;mdash;&amp;gt;&lt;/strong&gt; searches a term  for a subterm that Redex can apply a reduction rule to.&lt;/li&gt;
 &lt;li&gt;Using &lt;strong&gt;in-hole&lt;/strong&gt; on the second argument of &lt;strong&gt;&amp;mdash;&amp;gt;&lt;/strong&gt; puts a new value  back into the &lt;strong&gt;hole&lt;/strong&gt; in the evaluation context.&lt;/li&gt;
 &lt;li&gt;The unquote operator (&lt;strong&gt;,&lt;/strong&gt;) escapes to &amp;ldquo;Racket mode&amp;rdquo; (see below) to evaluate  a conjunction or disjunction.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;A judgment or metafunction is a formal alternative to &amp;ldquo;escaping to Racket&amp;rdquo;,  but escaping can be convenient.&lt;/p&gt;

&lt;p&gt;Note: the cases in a reduction relation form a &lt;em&gt;set&lt;/em&gt;, not a &lt;em&gt;sequence&lt;/em&gt;. If more than one case matches, Redex applies them all.&lt;/p&gt;

&lt;h3 id="q-what-is-racket-mode-what-is-redex-mode"&gt;Q. What is &amp;ldquo;Racket mode&amp;rdquo;? What is &amp;ldquo;Redex mode&amp;rdquo;?&lt;/h3&gt;

&lt;p&gt;Code in a Redex model is sometimes evaluated in &amp;ldquo;Racket mode&amp;rdquo; and  sometimes evaluated in &amp;ldquo;Redex mode&amp;rdquo;. Racket mode evaluates Racket syntax to Racket values. Redex mode evaluates Racket syntax (possibly containing metafunction names) to terms.&lt;/p&gt;

&lt;p&gt;Key points:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;A Redex program starts in Racket mode.&lt;/li&gt;
 &lt;li&gt;The &lt;strong&gt;X&lt;/strong&gt; in &lt;strong&gt;(term X)&lt;/strong&gt; is evaluated in Redex mode &amp;hellip;&lt;/li&gt;
 &lt;li&gt;&amp;hellip; unless &lt;strong&gt;X&lt;/strong&gt; contains unquoted sub-expressions. Unquoting escapes to Racket mode &amp;hellip;&lt;/li&gt;
 &lt;li&gt;&amp;hellip; and &lt;strong&gt;term&lt;/strong&gt;s inside an unquoted sub-expression are evaluated in Redex mode.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;In other words, &lt;strong&gt;term&lt;/strong&gt; enters Redex mode and &lt;strong&gt;unquote&lt;/strong&gt; (&lt;strong&gt;,&lt;/strong&gt;) escapes back to Racket.&lt;/p&gt;

&lt;p&gt;Redex implicitly switches to Redex mode in a few other places, for example:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;the right-side of a &lt;strong&gt;where&lt;/strong&gt; clause is in Redex mode&lt;/li&gt;
 &lt;li&gt;the result of a metafunction is in Redex mode&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;When in doubt, try using an &lt;strong&gt;unquote&lt;/strong&gt;. Redex will raise an exception if it finds an unquote in Racket mode.&lt;/p&gt;

&lt;h3 id="q-are-side-conditions-evaluated-in-racket-mode-or-redex-mode"&gt;Q. Are &lt;strong&gt;side-condition&lt;/strong&gt;s evaluated in &amp;ldquo;Racket mode&amp;rdquo; or &amp;ldquo;Redex mode&amp;rdquo;?&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;(side-condition e)&lt;/strong&gt; sometimes evaluates &lt;strong&gt;e&lt;/strong&gt; as a Racket expression  and sometimes evaluates &lt;strong&gt;e&lt;/strong&gt; as a Redex expression.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;reduction relations and metafunctions expect a &lt;strong&gt;Racket&lt;/strong&gt; expression&lt;/li&gt;
 &lt;li&gt;judgments expect a &lt;strong&gt;Redex&lt;/strong&gt; expression&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="q-what-is-a-binding-form"&gt;Q. What is a binding form?&lt;/h3&gt;

&lt;p&gt;In the lambda calculus, &lt;strong&gt;λ&lt;/strong&gt;-terms bind variables. A term &lt;strong&gt;(λ x M)&lt;/strong&gt; means that any free occurrence of &lt;strong&gt;x&lt;/strong&gt; in the sub-term &lt;strong&gt;M&lt;/strong&gt;  refers to the &lt;strong&gt;x&lt;/strong&gt; from the &lt;strong&gt;λ&lt;/strong&gt;-term.&lt;/p&gt;

&lt;p&gt;Redex can express this idea with a binding form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language Λ
  [e ::= (e e) x (λ x e)]
  [x ::= variable-not-otherwise-mentioned]
  #:binding-forms
  (λ x_0 e_0 #:refers-to x_0))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: all the non-terminals in a language must be defined before the &lt;strong&gt;#:binding-forms&lt;/strong&gt; keyword. If a non-terminal definition appears after the &lt;strong&gt;#:binding-forms&lt;/strong&gt; keyword, then Redex will interpret the &amp;ldquo;definition&amp;rdquo; as a binding form.&lt;/p&gt;

&lt;p&gt;Binding forms work together with Redex&amp;rsquo;s functions for substitution and  alphabetic equivalence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(alpha-equivalent? Λ
  (term (λ x x))
  (term (λ y y))))
;; #true

(define-metafunction Λ
  test-substitute : e -&amp;gt; e
  [(test-substitute (λ x_0 e_0))
   (substitute e_0 x_0 y)])
(term (test-substitute (λ z (z z))))
;; '(y y)&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-is--what-is-"&gt;Q. What is &lt;strong&gt;&amp;hellip;&lt;/strong&gt;? What is &lt;strong&gt;&amp;hellip;.&lt;/strong&gt;?&lt;/h3&gt;

&lt;p&gt;Three dots (&lt;strong&gt;&amp;hellip;&lt;/strong&gt;) is for building patterns. If &lt;strong&gt;p&lt;/strong&gt; is a pattern then &lt;strong&gt;(p &amp;hellip;)&lt;/strong&gt; matches any list whose elements all  match &lt;strong&gt;p&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language L)
(redex-match? L (number ... boolean ...) (term (1 2 #true #true)))
;; #true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Four dots (&lt;strong&gt;&amp;hellip;.&lt;/strong&gt;) may be used in &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28form._%28%28lib._redex%2Freduction-semantics..rkt%29._define-extended-language%29%29"&gt;&lt;strong&gt;define-extended-language&lt;/strong&gt;&lt;/a&gt;  to extend a previosly-defined non-terminal.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-language C
  (keyword ::= auto break case))
(define-extended-language C++
  C
  (keyword ::= .... class))

(redex-match? C keyword (term auto))
;; #true
(redex-match? C keyword (term class))
;; #false
(redex-match? C++ keyword (term auto))
;; #true
(redex-match? C++ keyword (term class))
;; #true&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-where-to-learn-more-about-redex"&gt;Q. Where to learn more about Redex?&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Critical path&amp;rdquo; resources:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Redex documentation: &lt;a href="http://docs.racket-lang.org/redex/index.html"&gt;http://docs.racket-lang.org/redex/index.html&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;A longer tutorial: &lt;a href="https://dvanhorn.github.io/redex-aam-tutorial/"&gt;https://dvanhorn.github.io/redex-aam-tutorial/&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;Source code for this post: &lt;a href="https://github.com/nuprl/website/blob/master/blog/static/redex-faq.rkt"&gt;https://github.com/nuprl/website/blob/master/blog/static/redex-faq.rkt&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;Redex source code (see &lt;code&gt;redex-lib/&lt;/code&gt;): &lt;a href="https://github.com/racket/redex"&gt;https://github.com/racket/redex&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;Procrastination&amp;rdquo; resources:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Tree Automata: &lt;a href="http://tata.gforge.inria.fr/"&gt;http://tata.gforge.inria.fr/&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;Should your Specification Language be Typed?&lt;/em&gt;: &lt;a href="http://lamport.azurewebsites.net/pubs/lamport-types.pdf"&gt;http://lamport.azurewebsites.net/pubs/lamport-types.pdf&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;Source code for this post: &lt;a href="https://github.com/nuprl/website/blob/master/blog/_src/posts/2017-09-25-redex-faq.md"&gt;https://github.com/nuprl/website/blob/master/blog/_src/posts/2017-09-25-redex-faq.md&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>[Why am I going to ICFP 2017? (cross-post)](https://williamjbowman.com/blog/2017/08/29/why-am-i-going-to-icfp-2017/)</title>
   <link>http://prl.ccs.neu.edu/blog/2017/08/29/-why-am-i-going-to-icfp-2017-cross-post-https-williamjbowman-com-blog-2017-08-29-why-am-i-going-to-icfp-2017?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-08-29-why-am-i-going-to-icfp-2017-cross-post-https-williamjbowman-com-blog-2017-08-29-why-am-i-going-to-icfp-2017</guid>
   <pubDate>Tue, 29 Aug 2017 13:33:21 UT</pubDate>
   <author>PRL</author>
   <description></description></item>
  <item>
   <title>Closure Conversion as CoYoneda</title>
   <link>http://prl.ccs.neu.edu/blog/2017/08/28/closure-conversion-as-coyoneda?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-08-28-closure-conversion-as-coyoneda</guid>
   <pubDate>Mon, 28 Aug 2017 10:30:00 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;The continuation-passing style transform (cps) and closure conversion (cc) are two techniques widely employed by compilers for functional languages, and have been studied extensively in the compiler correctness literature. Interestingly, &lt;em&gt;typed&lt;/em&gt; versions of each can be proven to be equivalence preserving using polymorphic types and parametric reasoning, as shown by my advisor Amal Ahmed and Matthias Blume (&lt;a href="http://www.ccs.neu.edu/home/amal/papers/epc.pdf"&gt;cps&lt;/a&gt;,&lt;a href="http://www.ccs.neu.edu/home/amal/papers/tccpoe.pdf"&gt;cc&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In fact, there is something like a duality between the two proofs, cps uses a universal type, closure-conversion uses an existential type and the isomorphism proofs use analogous reasoning. It turns out that both are instances of general theorems in category theory: the polymorphic cps isomorphism can be proven using the Yoneda lemma, and the polymorphic closure-conversion isomorphism can be proven using a less well known theorem often called the &lt;a href="https://ncatlab.org/nlab/show/co-Yoneda+lemma"&gt;*co*Yoneda lemma&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The connection between cps and the Yoneda embedding/lemma is detailed elsewhere in the &lt;a href="http://www.cs.ox.ac.uk/people/daniel.james/iso/iso.pdf"&gt;literature&lt;/a&gt; and blogosphere (&lt;a href="https://golem.ph.utexas.edu/category/2008/01/the_continuation_passing_trans.html"&gt;ncafe&lt;/a&gt;, &lt;a href="https://bartoszmilewski.com/2015/09/01/the-Yoneda-lemma/"&gt;Bartosz&lt;/a&gt;), so I&amp;rsquo;ll focus on closure conversion here. Also, I&amp;rsquo;ll try to go into some detail in showing how the &amp;ldquo;usual&amp;rdquo; version of Yoneda/coYoneda (using the category of sets) relates to the appropriate version for compilers.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll assume some background knowledge on closure conversion and parametricity below. Fortunately, Matt Might has a &lt;a href="http://matt.might.net/articles/closure-conversion/"&gt;nice blog post explaining untyped closure conversion&lt;/a&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;
 &lt;script type="math/tex"&gt;
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Hom}{\mathsf{Hom}}&lt;/script&gt;&lt;/p&gt;

&lt;h2 id="polymorphic-closure-conversion"&gt;Polymorphic Closure Conversion&lt;/h2&gt;

&lt;p&gt;Closure conversion is a way of compiling a language with closures (i.e., basically any modern high-level language) to one that only has function pointers/labels like C or machine code. Closure conversion compiles high-level functions (aka closures) to a pair of an environment that will contain the values of all the functions&amp;rsquo; free variables and a code pointer to a block that takes as inputs all the inputs to the function and values for all of the free variables.&lt;/p&gt;

&lt;p&gt;For instance&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = 3 in λ y. x + y&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would be converted to something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = 3 in ([x: 3], λ env, y. let x = env.x in x + y)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Can we give a type to the resulting code? The source program has type &lt;code&gt;Number -&amp;gt; Number&lt;/code&gt;, but the target has a type more like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ x: Number} × ({x : Number} × Number -&amp;gt; Number).&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to being ugly, this type is leaking irrelevant details of the function&amp;rsquo;s implementation: all of its free variables are there in its type, so two terms with the same function type but different free variables would be translated to different types. Also high-level program equivalences like 
 &lt;script type="math/tex"&gt;\beta&lt;/script&gt;-reducing the term to just &lt;code&gt;λ y. 3 + y&lt;/code&gt; would not even preserve typing. Not only that, but some bad code could now supply a &lt;em&gt;different&lt;/em&gt;, well-typed value for &lt;code&gt;x&lt;/code&gt; than allowed which could break invariants the programmer had about the function.&lt;/p&gt;

&lt;p&gt;We could fix the type preservation issue by just using a dynamic type for our environment, but this would still leak details in the values. Fortunately, there is a nice solution to the other problems using existential types. The idea is that the type of the environment of free variables is &lt;em&gt;irrelevant&lt;/em&gt; to anyone that calls the function, only the function itself should know what the environment looks like; the type of the environment should be &lt;em&gt;abstract&lt;/em&gt; to the caller and &lt;em&gt;concrete&lt;/em&gt; to the callee. Existential types capture this.&lt;/p&gt;

&lt;p&gt;We can translate functions in the source of type &lt;code&gt;A -&amp;gt; B&lt;/code&gt; to pairs of an environment and a code pointer, but now making the environment type existentially quantified:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;∃ Γ. Γ × (Γ × A -&amp;gt; B).&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the syntax of existential types ensure that all any consumer can do with the &lt;code&gt;env : Γ&lt;/code&gt; in the pair is pass it to the code pointer with an &lt;code&gt;A&lt;/code&gt; argument.&lt;/p&gt;

&lt;p&gt;How do we prove that this is correct? And what does correct even mean? We&amp;rsquo;ll focus on a property called &lt;em&gt;full abstraction&lt;/em&gt; which says that if two programs are equal in the source language, then their translations are equal. Here, equal in the source language will just mean 
 &lt;script type="math/tex"&gt;\beta,\eta&lt;/script&gt; equivalence, so things like as above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = 3 in λ y. x + y
≡
λ y. 3 + y&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To prove this we&amp;rsquo;ll show that in a language with existential types the types &lt;code&gt;∃ Γ. Γ × (Γ × A -&amp;gt; B)&lt;/code&gt; and &lt;code&gt;A \to B&lt;/code&gt; are isomorphic. The usual proof is by parametricity, instead we&amp;rsquo;ll use a closely related category-theoretic argument: the coYoneda lemma.&lt;/p&gt;

&lt;h2 id="the-coyoneda-lemma"&gt;The CoYoneda Lemma&lt;/h2&gt;

&lt;p&gt;The coYoneda lemma is a generalization of the equivalence described above. I&amp;rsquo;ll start with the ordinary version which uses &lt;em&gt;coends&lt;/em&gt; and &lt;em&gt;presheaves&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The coYoneda lemma says that for any category 
 &lt;script type="math/tex"&gt; C&lt;/script&gt;, presheaf 
 &lt;script type="math/tex"&gt; Q : C^{op} \to \Set&lt;/script&gt;, and object 
 &lt;script type="math/tex"&gt;A \in C&lt;/script&gt;, 
 &lt;script type="math/tex"&gt;Q(A)&lt;/script&gt; is isomorphic to the coend: 
 &lt;script type="math/tex; mode=display"&gt; \exists B. (A \to B) \times Q(B)&lt;/script&gt; Let&amp;rsquo;s break that down.&lt;/p&gt;

&lt;h3 id="coends"&gt;Coends&lt;/h3&gt;

&lt;p&gt;A coend is a construction that is very similar to the parametric existential quantifier. If you&amp;rsquo;re familiar with parametricity, a good intuition is that coends have the same definition as existential types but where the only relations are functional relations.&lt;/p&gt;

&lt;p&gt;You can take the coend of a functor of type 
 &lt;script type="math/tex"&gt;M : C^{op} \times C \to
\Set&lt;/script&gt;. We can get such an 
 &lt;script type="math/tex"&gt;M&lt;/script&gt; from a type with a free type variable like 
 &lt;script type="math/tex"&gt; X \times A \to X&lt;/script&gt; by splitting the 
 &lt;script type="math/tex"&gt;X&lt;/script&gt; into positive and negative occurrences: 
 &lt;script type="math/tex"&gt;X^- \times A \to X^+&lt;/script&gt;. Then the coend 
 &lt;script type="math/tex"&gt;\exists X. M(X,X) \in \Set&lt;/script&gt; is like the union of all 
 &lt;script type="math/tex"&gt;M(X,X)&lt;/script&gt;, but where the 
 &lt;script type="math/tex"&gt;X&lt;/script&gt; is ensured to be &amp;ldquo;irrelevant&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;So for any object 
 &lt;script type="math/tex"&gt;A \in C&lt;/script&gt; there is a map 
 &lt;script type="math/tex"&gt;pack_A : M(A,A) \to
\exists X. M(X,X)&lt;/script&gt;, we can &amp;ldquo;hide the A&amp;rdquo;. To make sure the 
 &lt;script type="math/tex"&gt;X&lt;/script&gt; is treated opaquely, we add an invariance condition that says if you have an 
 &lt;script type="math/tex"&gt;mA : M(A,A)&lt;/script&gt; and an 
 &lt;script type="math/tex"&gt;mB :
M(B,B)&lt;/script&gt; such that the 
 &lt;script type="math/tex"&gt;A, B&lt;/script&gt; positions are related by some function 
 &lt;script type="math/tex"&gt;f : A \to B&lt;/script&gt;, then 
 &lt;script type="math/tex"&gt;pack_A(mA) = pack_B(mB)&lt;/script&gt;. More formally, this means that if you have a 
 &lt;script type="math/tex"&gt;m' : M(B,A)&lt;/script&gt;, then&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt; pack_B(M(B,f)(m')) = pack_A(M(f,A)(m'))&lt;/script&gt; or in a point-free style: 
 &lt;script type="math/tex; mode=display"&gt; pack_B \circ M(B,f) = pack_A \circ M(f,A) : M(B,A) \to \exists X. M(X,X)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;A function parameterized by types like 
 &lt;script type="math/tex"&gt;pack&lt;/script&gt; that has this property is called a &lt;em&gt;co-wedge&lt;/em&gt; from 
 &lt;script type="math/tex"&gt;M&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;A coend is an object 
 &lt;script type="math/tex"&gt;\exists X. M(X,X)&lt;/script&gt; and a co-wedge 
 &lt;script type="math/tex"&gt;\forall
A. pack_A : M(A,A) \to \exists X. M(X,X)&lt;/script&gt; that are &lt;em&gt;universal&lt;/em&gt;, i.e. any other co-wedge 
 &lt;script type="math/tex"&gt;\forall A. f_A : M(A,A) \to C&lt;/script&gt; factors through 
 &lt;script type="math/tex"&gt;pack_A&lt;/script&gt;. This gives us the syntax for existential elimination.&lt;/p&gt;

&lt;p&gt;If you are familiar with parametricity, it is a good exercise to see why the usual condition for invariance wrt all &lt;em&gt;relations&lt;/em&gt; implies that a parametric 
 &lt;script type="math/tex"&gt;pack, \exists X. M(X,X)&lt;/script&gt; will form a cowedge. It seems that in general it would not be a universal co-wedge because a parametric exists is invariant under all relations and there are many relations that don&amp;rsquo;t act like functions.&lt;/p&gt;

&lt;h3 id="presheaves"&gt;Presheaves&lt;/h3&gt;

&lt;p&gt;Next, a presheaf is just a functor 
 &lt;script type="math/tex"&gt; Q : C^{op} \to
\Set&lt;/script&gt;. Think of this as a set that is parameterised by a type of &amp;ldquo;inputs&amp;rdquo;, so if you have a map in 
 &lt;script type="math/tex"&gt;C, f : A \to B&lt;/script&gt; you get a function 
 &lt;script type="math/tex"&gt;Q(f) :
Q(B) \to Q(A)&lt;/script&gt; that &amp;ldquo;preprocesses&amp;rdquo; the inputs using 
 &lt;script type="math/tex"&gt;f&lt;/script&gt;. Functoriality ensures that preprocessing with the identity is just the identity and that composition of preprocessers is the preprocessor from the composite function.&lt;/p&gt;

&lt;p&gt;So the informal explanation of the coYoneda lemma is that for any presheaf 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt;, if we have an 
 &lt;script type="math/tex"&gt; \exists X. (A \to X) \times Q(X)&lt;/script&gt;, then since we can&amp;rsquo;t inspect the 
 &lt;script type="math/tex"&gt;X&lt;/script&gt; in any way, all we can really do is compose the 
 &lt;script type="math/tex"&gt;Q(X)&lt;/script&gt; with the preprocesser from the function 
 &lt;script type="math/tex"&gt;A \to X&lt;/script&gt;, giving us a 
 &lt;script type="math/tex"&gt;Q(A)&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id="enriched-categories-and-enriched-coyoneda"&gt;Enriched Categories and Enriched CoYoneda&lt;/h3&gt;

&lt;p&gt;But there&amp;rsquo;s a gap from here to applying this to a programming language, the coYoneda lemma as presented says that 
 &lt;script type="math/tex"&gt;Q(A)&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;\exists B. (A \to B) \times Q(B)&lt;/script&gt; are isomorphic as &lt;em&gt;sets&lt;/em&gt;, but we wanted an isomorphism of &lt;em&gt;types&lt;/em&gt; in our programming language. We can reconcile this by considering &lt;em&gt;enriched&lt;/em&gt; category theory and the &lt;em&gt;enriched&lt;/em&gt; coYoneda lemma. Let 
 &lt;script type="math/tex"&gt;V&lt;/script&gt; be a category, then if 
 &lt;script type="math/tex"&gt; V&lt;/script&gt; is sufficiently like the category of sets, then we can do a lot of category theory by replacing the word &amp;ldquo;set&amp;rdquo; with &amp;ldquo;object of 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Specifically, a 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-enriched category (or just 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-category) has a set of objects 
 &lt;script type="math/tex"&gt;Ob&lt;/script&gt;, but for each pair of objects 
 &lt;script type="math/tex"&gt;A,B
\in Ob&lt;/script&gt; we get a 
 &lt;script type="math/tex"&gt; V&lt;/script&gt;-object 
 &lt;script type="math/tex"&gt;\Hom(A,B)&lt;/script&gt; of morphisms from 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; to 
 &lt;script type="math/tex"&gt; B&lt;/script&gt;. If 
 &lt;script type="math/tex"&gt;V&lt;/script&gt; is a closed category, we can see 
 &lt;script type="math/tex"&gt;V&lt;/script&gt; &lt;em&gt;itself&lt;/em&gt; as a 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-enriched category with the same objects and just making 
 &lt;script type="math/tex"&gt;\Hom(A,B) = A \to B&lt;/script&gt; i.e. the &lt;em&gt;internal&lt;/em&gt; hom aka exponential.&lt;/p&gt;

&lt;p&gt;Then we can reinterpret the coYoneda lemma above by saying 
 &lt;script type="math/tex"&gt;C&lt;/script&gt; is a 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-category and 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt; is a 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-presheaf i.e., just a contravariant functor from 
 &lt;script type="math/tex"&gt;V&lt;/script&gt; to itself: 
 &lt;script type="math/tex"&gt;Q : V^{op} \to V&lt;/script&gt; where the preprocessing function is now a morphism in 
 &lt;script type="math/tex"&gt;C&lt;/script&gt;. Haskelletons just call this a &lt;a href="https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html"&gt;contravariant functor&lt;/a&gt;. Furthermore, since existential types provide at least as strong of a reasoning principle as coends, the proof of the coYoneda lemma goes through with existential types instead. Finally, the point-free description above for coend can be interpreted in any category.&lt;/p&gt;

&lt;p&gt;Now that we&amp;rsquo;re working all inside our language, let&amp;rsquo;s look at what the isomorphism looks like in Haskellish/Agdaish syntax. We want mutually inverse functions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f : (Contravariant Q) =&amp;gt; (∃ Γ. (Δ -&amp;gt; Γ) × (Q Γ)) -&amp;gt; Q Δ
g : (Contravariant Q) =&amp;gt; Q Δ -&amp;gt; ∃ Γ. (Δ -&amp;gt; Γ) × (Q Γ)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you try to implement them you won&amp;rsquo;t be able to get it wrong, but here they are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f (k, qΓ) = contramap k qΓ
g qΔ = (id, qΔ)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where we just instantiate 
 &lt;script type="math/tex"&gt;\Gamma = \Delta&lt;/script&gt; in the second case. You can prove 
 &lt;script type="math/tex"&gt; f \circ g = id&lt;/script&gt; using just 
 &lt;script type="math/tex"&gt;\beta&lt;/script&gt; and the Contravariant laws, but to prove 
 &lt;script type="math/tex"&gt;g \circ f = id&lt;/script&gt; you need to use the coend reasoning. For those of you that know about the Yoneda lemma, note the similarity to that proof in using the identity function and instantiating a type variable in a trivial way.&lt;/p&gt;

&lt;h2 id="closure-version-as-coyoneda"&gt;Closure Version as CoYoneda&lt;/h2&gt;

&lt;p&gt;Now it&amp;rsquo;s time to bring it all together. Let 
 &lt;script type="math/tex"&gt;V&lt;/script&gt; be our programming language viewed as a category in the usual way.&lt;/p&gt;

&lt;p&gt;We want to prove the closure conversion isomorphism:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt; A \to B \cong \exists \Gamma. \Gamma \times (\Gamma \times A \to B)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;using the 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-coYoneda lemma which says for any contravariant functor 
 &lt;script type="math/tex"&gt;Q : V^{op} \to V&lt;/script&gt;, and object 
 &lt;script type="math/tex"&gt;\Delta \in V&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt; Q(\Delta) \cong \exists \Gamma. (\Delta \to \Gamma) \times Q(\Gamma)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Clearly based on the right hand side, 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt; should be 
 &lt;script type="math/tex"&gt; - \times
A \to B&lt;/script&gt; which gives us for any 
 &lt;script type="math/tex"&gt;\Delta \in V&lt;/script&gt;:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt; \Delta \times A \to B \cong \exists \Gamma. (\Delta \to \Gamma) \times (\Gamma \times A \to B)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Next we pick 
 &lt;script type="math/tex"&gt;\Delta = 1&lt;/script&gt;, the unit type. Then we use some basic facts about the unit type: 
 &lt;script type="math/tex"&gt;1 \times A \cong
A&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;1 \to \Gamma \cong \Gamma&lt;/script&gt; (at least in a pure language) to get the desired result by composition:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt; A \to B \cong 1 \times A \to B \cong \exists \Gamma. (1 \to
\Gamma) \times (\Gamma \times A \to B) \cong \exists \Gamma. \Gamma
\times (\Gamma \times A \to B)&lt;/script&gt;&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Since closure conversion is an instance of the CoYoneda lemma, this might be a nice example to give intuition for CoYoneda for programmers. While not as famous as its cousin Yoneda, CoYoneda is used in &lt;a href="https://hackage.haskell.org/package/kan-extensions-5.0.2/docs/Data-Functor-Coyoneda.html"&gt;Haskell&lt;/a&gt; and is also central to the &lt;a href="https://ncatlab.org/nlab/show/Day+convolution"&gt;Day Convolution&lt;/a&gt;, which can be used to give semantics to &lt;a href="atkey-thesis"&gt;separation logic&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also in researching for this post, I was surprised at how little I could find on the relationship between ends/coends and relational parametricity. This seems very unfortunate as it looks like we&amp;rsquo;re reproving some of the same theorems (Yoneda, coYoneda) using very similar, but incompatible formalisms.&lt;/p&gt;

&lt;h2 id="you-might-also-like"&gt;You might also like&lt;/h2&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2017/06/05/syntactic-parametricity-strikes-again/"&gt;Syntactic Parametricity Strikes Again&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2017/05/01/categorical-semantics-for-dynamically-typed-programming-languages/"&gt;Categorical Semantics for Dynamically Typed Programming  Languages&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2016/11/16/understanding-constructive-galois-connections/"&gt;Understanding Constructive Galois  Connections&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Gradual Typing Across the Spectrum, part II</title>
   <link>http://prl.ccs.neu.edu/blog/2017/08/22/gradual-typing-across-the-spectrum-part-ii?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-08-22-gradual-typing-across-the-spectrum-part-ii</guid>
   <pubDate>Tue, 22 Aug 2017 15:54:06 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;Last week, Northeastern hosted a PI meeting for the &lt;a href="http://prl.ccs.neu.edu/gtp/"&gt;Gradual Typing Across the  Spectrum&lt;/a&gt; NSF grant. The meeting was made of 20+ researchers from four institutions,  and 12 technical talks. Schedule:&lt;/p&gt;

&lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/gtp/pi2017/pi2017.html"&gt;http://prl.ccs.neu.edu/gtp/pi2017/pi2017.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A common thread among the talks was the question:  &lt;em&gt;how to convert a research idea into a tool for software developers?&lt;/em&gt;&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;In my mind, gradual typing &lt;em&gt;is&lt;/em&gt; an answer to one instance of this question. The research idea is strong static type systems, and the software developers  are the millions using dynamically typed languages. I know that static typing can make programs easier to write and maintain. The developers know that dynamic typing has benefits; moreover they know better  than to migrate their code from one language to another on a whim. Gradual typing is a linguistic solution to the problem of &lt;em&gt;adding&lt;/em&gt; the benefits  of static typing to a dynamically typed language.&lt;/p&gt;

&lt;p&gt;Enough opinions, let&amp;rsquo;s talk about the talks.&lt;/p&gt;

&lt;p&gt;The morning session consisted of four talks:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="https://www.cs.umd.edu/people/milod"&gt;Milod Kazerounian&lt;/a&gt; (&lt;a href="https://www.cs.umd.edu/"&gt;UMD&lt;/a&gt;)  spoke about upgrading the &lt;a href="https://github.com/plum-umd/rdl"&gt;RDL&lt;/a&gt; type checker  for Ruby with support for refinement types.  The idea is to compile Ruby code and types to &lt;a href="https://emina.github.io/rosette/"&gt;Rosette&lt;/a&gt;,  and profit from &lt;a href="http://yices.csl.sri.com/papers/cav2007.pdf"&gt;SMT&lt;/a&gt;-assisted type checking.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://ambrosebs.com/"&gt;Ambrose Bonnaire-Sergeant&lt;/a&gt; (&lt;a href="https://www.cs.indiana.edu/"&gt;IU&lt;/a&gt;, &lt;a href="http://ambrosebs.com/talks/squash-work-boston-pi-2017.pdf"&gt;slides&lt;/a&gt;)  has been inferring &lt;em&gt;useful&lt;/em&gt; &lt;a href="http://typedclojure.org/"&gt;Typed Clojure&lt;/a&gt; types through dynamic analysis of  Clojure programs. His tool observes how values flow through a program at run-time,  then lifts these observations into possibly-recursive, possibly-incorrect type  annotations. The surprising result is that the tool quickly (1&amp;ndash;2 seconds per  unit test, I think) infers types that can help a developer start annotating a program.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://ccs.neu.edu/~types/"&gt;Ben Greenman&lt;/a&gt; (&lt;a href="http://www.ccis.northeastern.edu/"&gt;NEU&lt;/a&gt;, &lt;a href="http://homedirs.ccs.neu.edu/types/resources/talks/preservation-types.pdf"&gt;slides&lt;/a&gt;)  explained why he is implementing a semantics for &lt;a href="https://github.com/racket/typed-racket"&gt;Typed Racket&lt;/a&gt;  inspired by Michael Vitousek&amp;rsquo;s work on &lt;a href="http://homes.soic.indiana.edu/mvitouse/papers/popl17.pdf"&gt;Reticulated Python&lt;/a&gt;.  The &amp;ldquo;why&amp;rdquo; is &amp;ldquo;performance&amp;rdquo;. The Reticulated semantics will enforce a  notion of tag soundness in kind of &lt;a href="https://en.wikipedia.org/wiki/Deal_with_the_Devil"&gt;devils contract&lt;/a&gt;  to improve performance.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="https://cs.brown.edu/~ptunnell/"&gt;Preston Tunnell-Wilson&lt;/a&gt; (&lt;a href="http://cs.brown.edu/"&gt;Brown&lt;/a&gt;, &lt;a href="http://cs.brown.edu/~sk/Publications/Papers/Published/tpk-crowdsource-lang-design/"&gt;ONWARD 2017&lt;/a&gt;)  recently sent questions about programming language design to  &lt;a href="https://www.mturk.com/mturk/welcome"&gt;Mechanical Turk&lt;/a&gt; workers.  Survey says, developers have extremely diverse opinions about what they &lt;em&gt;expect&lt;/em&gt;  and what they &lt;em&gt;want&lt;/em&gt; regarding scope, inheritance, and infix operators.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;In the early afternoon, we had two talks on similar themes as the morning session:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="https://github.com/akuhlens"&gt;Andre Kuhlenschmidt&lt;/a&gt; (&lt;a href="https://www.cs.indiana.edu/"&gt;IU&lt;/a&gt;)  is exploring the design space of efficient implementations for run-time type checks.  The main challenge is how to &lt;em&gt;monitor&lt;/em&gt; higher-order data in a way that efficiently  performs type checks and can help the programmer debug any failed checks.  This talk presented data comparing two approaches to the program; I believe  the latter, improved approach is based on &lt;a href="http://homepages.inf.ed.ac.uk/wadler/papers/coercions/coercions.pdf"&gt;coercions&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="https://zeinamigeed.com/"&gt;Zeina Migeed&lt;/a&gt; (&lt;a href="http://www.ccis.northeastern.edu/"&gt;NEU&lt;/a&gt;)  explained that there are many ways to adapt type soundness to a gradually  typed language, and presented some data comparing Typed Racket&amp;rsquo;s &lt;em&gt;generalized soudness&lt;/em&gt;  to Reticulated Python&amp;rsquo;s &lt;em&gt;tag soundness&lt;/em&gt;. The data suggests that tag soundness  never adds an order-of-magnitude slowdown.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Next on the schedule were two talks about implementing advanced type systems  in Racket&amp;rsquo;s macro expander (think: meta-level linguistic re-use, capture-avoiding  substitution for free!)&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="https://github.com/iitalics"&gt;Milo Turner&lt;/a&gt; (&lt;a href="http://www.ccis.northeastern.edu/"&gt;NEU&lt;/a&gt;)  first showed how to implement &lt;a href="https://gankro.github.io/blah/linear-rust/#definitions-and-the-state-of-rust"&gt;linear and affine&lt;/a&gt;  type systems using &lt;a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html"&gt;syntax-parse&lt;/a&gt;,  and second presented a simpler implementation using the &lt;a href="http://docs.racket-lang.org/turnstile/index.html"&gt;Turnstile&lt;/a&gt; library.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://www.davidchristiansen.dk/"&gt;David Christiansen&lt;/a&gt; (&lt;a href="https://www.cs.indiana.edu/"&gt;IU&lt;/a&gt;)  is building &lt;a href="https://github.com/david-christiansen/pudding"&gt;a proof assistant&lt;/a&gt;  in Racket. This talk focused on the design and implementation of proof  tactics.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;After a short break, we heard about something completely different:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://justinpombrio.net/"&gt;Justin Pombrio&lt;/a&gt; (&lt;a href="http://cs.brown.edu/"&gt;Brown&lt;/a&gt;, &lt;a href="http://cs.brown.edu/research/plt/dl/icfp2017/"&gt;ICFP 2017&lt;/a&gt;)  taught us to interpet the scoping rules of a &amp;ldquo;core&amp;rdquo; language as a preorder.  Using the preorder, he then showed how to &lt;em&gt;infer&lt;/em&gt; the scoping rules of  any &amp;ldquo;surface&amp;rdquo; language based on its translation to the &amp;ldquo;core&amp;rdquo;.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Last summer and fall, Jeremy Siek hosted two REUs (&lt;a href="https://www.nsf.gov/funding/pgm_summ.jsp?pims_id=5517&amp;amp;from=fund"&gt;research experience for undergraduates&lt;/a&gt;) at Indiana University. The two students gave the next talks:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Di Zhong (&lt;a href="https://www.cs.indiana.edu/"&gt;IU&lt;/a&gt;)  talked about implementing interpreters in Racket, Python, and Haskell.  As I understand, this was a hands-on experience through &lt;a href="https://www.cis.upenn.edu/~bcpierce/tapl/"&gt;TAPL&lt;/a&gt;  and &lt;a href="https://redex.racket-lang.org/"&gt;the Redex book&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="https://zeinamigeed.com/"&gt;Zeina Migeed&lt;/a&gt; (&lt;a href="https://www.cs.indiana.edu/"&gt;IU&lt;/a&gt;)  demonstrated her implementation of &lt;a href="http://theory.stanford.edu/~aiken/publications/papers/popl94.pdf"&gt;conditional types&lt;/a&gt;  for &lt;a href="https://github.com/mvitousek/reticulated"&gt;Reticulated&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Finally,&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://nikivazou.github.io/"&gt;Niki Vazou&lt;/a&gt; (&lt;a href="https://www.cs.umd.edu/"&gt;UMD&lt;/a&gt;)  presented a theory of gradual refinement types.  Any &amp;ldquo;holes&amp;rdquo; in the refinements introduce a search problem; type checking  attempts to solve the problem by finding a predicate that unifies a function  definition and its callers.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;This meeting was a great opportunity to reflect on the recent past and  share opinions on what&amp;rsquo;s worth pursuing in the future. Many thanks to the participants, and to the NSF for the support!&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;If you want to know about the future, you need to ask the young people who will create it. Young people don&amp;rsquo;t know what can&amp;rsquo;t be done, and so they go ahead and do it. &amp;mdash; &lt;a href="https://www.youtube.com/watch?v=sM1bNR4DmhU"&gt;Ivan Sutherland&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</description></item>
  <item>
   <title>Reviews and author responses: we should stop asking for 500-word responses</title>
   <link>http://prl.ccs.neu.edu/blog/2017/08/13/reviews-and-author-responses-we-should-stop-asking-for-500-word-responses?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-08-13-reviews-and-author-responses-we-should-stop-asking-for-500-word-responses</guid>
   <pubDate>Sun, 13 Aug 2017 14:29:41 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;This year I reviewed many ICFP submissions, and got to be on the receiving end of equally many author responses (also sometimes called, somewhat combatively, rebuttals). I found that there was a large difference between the official written advice on author responses and what I, as a reviewer reading the responses, found effective. In particular, I now believe that limiting yourself to 500 words should strongly be avoided &amp;mdash; we should even stop giving that advice.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;This year, I had the honor (and accompanying load of work) of being a Program Committee (PC) member at the ICFP conference. It was my first time being a PC member at a conference, and I found it extremely pleasant and interesting, thanks to the authors who sent us articles to review, my fellow PC members, and the ever-smiling careful balancing work of our PC chair, Mark Jones. It was also a lot of work, starting with 18 reviews to do over a month and a half, an intense PC meeting, and the new &amp;ldquo;second phase&amp;rdquo; process with the opportunity for authors and reviewers to exchange feedback on changes requested by the program committee.&lt;/p&gt;

&lt;p&gt;There is little guidance on how to write author responses, although this &lt;a href="http://www.pl-enthusiast.net/2014/09/17/advice-writing-author-response/"&gt;blog post&lt;/a&gt; by Michael Hicks on pl-enthusiast is quite good. One thing that is obvious as a reviewer and is only slightly brushed in this post, however, is that author responses should &lt;em&gt;not&lt;/em&gt; aim to fit a 500 words limit, and in fact I believe that it is a bad idea to do so.&lt;/p&gt;

&lt;p&gt;As for most conference, the ICFP review system recommends (in writing) to authors to keep their response to 500 words (some systems also highlight words after those in red to make the point clear). Don&amp;rsquo;t do this! The least convincing responses I have seen are those that followed this recommendation.&lt;/p&gt;

&lt;p&gt;(I have also seen at least 18*2 other reviewers read the same responses I read, most of them well over 500 words, and &lt;em&gt;none&lt;/em&gt; of them made any comment on the length of the author responses.)&lt;/p&gt;

&lt;p&gt;We have a frustrating situation where the explicit rule is different from the thing people do in practice. This is bad for newcomers that do not know the norms and cannot tell if ignoring the rule may hurt them. This is the point of this blog post:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;If you are an author, please know that disrespecting the 500-words  limit is the &lt;em&gt;right thing&lt;/em&gt; to do. You should also know, of course,  that people have limited time, so keep the main body of your  response reasonably long. (I spent a day and a half on your paper  already, I am willing to spend 10 additional minutes reading the  response.)&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If you are a program committee chair or a Magical HotCRP Wizard,  please remove this silly recommendation to keep responses to 500  words. (See an alternative proposal at the end of this post.)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="my-personal-response-format"&gt;My personal response format&lt;/h2&gt;

&lt;p&gt;My author responses start with general comments that elaborate on the main point I want to tell all reviewers. Then, a second part contains per-reviewer comments (one section per reviewer); it is clearly marked as skippable. Here is the skeleton of the last response I wrote:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;We thank the reviewers for their work on our article and their detailed feedback. We start with a general discussion that responds to the salient points raised by reviewers. In a second part, we provide detailed responses to the questions/remarks of each reviewer.&lt;/p&gt;
 &lt;h3 id="general-discussion"&gt;General discussion&lt;/h3&gt;
 &lt;p&gt;[..]&lt;/p&gt;
 &lt;h3 id="specific-questionscomments-review-a"&gt;Specific questions/comments: review #A&lt;/h3&gt;
 &lt;p&gt;[..]&lt;/p&gt;
 &lt;h3 id="specific-questionscomments-review-b"&gt;Specific questions/comments: review #B&lt;/h3&gt;
 &lt;p&gt;[..]&lt;/p&gt;
 &lt;h3 id="specific-questionscomments-review-c"&gt;Specific questions/comments: review #C&lt;/h3&gt;
 &lt;p&gt;[&amp;hellip;]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For this particular response, the &amp;ldquo;General discussion&amp;rdquo; section used 1296 words according to &lt;code&gt;wc -w&lt;/code&gt; (M-x shell-command-on-region). In the following sections, I quote the reviews to answer specific points, email-style (following the Markdown syntax that HotCRP renders properly).&lt;/p&gt;

&lt;h2 id="suggested-wording-for-pc-chairs"&gt;Suggested wording for PC chairs&lt;/h2&gt;

&lt;p&gt;If you are a PC chair, you should remove the suggestion of respecting a 500 words limit for your conference. Here would be a suggested alternative wording:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Please remember, in writing your author response, that reviewers may stop reading the response at any point. We suggest having a reasonably-sized main section where you make your most important high-level comments, and clearly marked sections where you answer individual reviewer&amp;rsquo;s questions. It is not useful nor productive to answer every point of each review, you should focus on the comments that you believe the reviewers are most interested in.&lt;/p&gt;&lt;/blockquote&gt;</description></item>
  <item>
   <title>Trees, 1973</title>
   <link>http://prl.ccs.neu.edu/blog/2017/07/19/trees-1973?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-07-19-trees-1973</guid>
   <pubDate>Wed, 19 Jul 2017 21:48:56 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;From the PRL archives:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;I think that I shall never see a matrix lovely as a tree. &amp;mdash; &lt;a href="/img/gls-trees-poem-1979.pdf"&gt;&lt;em&gt;Trees&lt;/em&gt;&lt;/a&gt;, by Guy L. Steele Jr., MIT, 1973&lt;/p&gt;&lt;/blockquote&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;p&gt;You might recognize the opening line from Joyce Kilmer&amp;rsquo;s 1914 poem &lt;a href="https://en.wikipedia.org/wiki/Trees_(poem)"&gt;&lt;em&gt;Trees&lt;/em&gt;&lt;/a&gt;, or from Radia Perlman&amp;rsquo;s &lt;a href="/img/p-sigcomm-1985.pdf"&gt;&lt;em&gt;Algorhyme&lt;/em&gt;&lt;/a&gt; (published 1985).&lt;/p&gt;

&lt;p&gt;The poem is online in &lt;a href="http://mercury.lcs.mit.edu/~jnc/humour/lisp.tree"&gt;at least one other place&lt;/a&gt;, but the copy linked above (from &lt;a href="https://archive.org/details/byte-magazine"&gt;BYTE magazine&lt;/a&gt;) comes with a footnote on &lt;em&gt;How this poem came to be printed&lt;/em&gt;.&lt;/p&gt;</description></item>
  <item>
   <title>Continuations</title>
   <link>http://prl.ccs.neu.edu/blog/2017/07/17/continuations?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-07-17-continuations</guid>
   <pubDate>Mon, 17 Jul 2017 12:52:07 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;From the PRL archives:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;It was also a concept that grabbed my mind, ran off with it, and only returned it after substantial renovation and expansion. &amp;mdash; &lt;a href="/img/nall-continuations-1983.pdf"&gt;&lt;em&gt;Continuations&lt;/em&gt;&lt;/a&gt; by Alan Nall, Indiana University, 1983&lt;/p&gt;&lt;/blockquote&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;p&gt;I first encountered this essay on continuations in a green folder in the PRL. It turns out, the author spent a semester at Indiana University working on the  &lt;a href="http://wiki.c2.com/?SameFringeProblem"&gt;same fringe problem&lt;/a&gt; for a graduate-level programming languages course. According to &lt;a href="https://www.cs.indiana.edu/~dfried/"&gt;the instructor&lt;/a&gt;:  &amp;ldquo;What he said was true. He could not stop thinking about the problem the entire semester.&amp;rdquo; This essay was a kind of final exam.&lt;/p&gt;</description></item>
  <item>
   <title>Quotes and Stories from "Turing 50"</title>
   <link>http://prl.ccs.neu.edu/blog/2017/06/24/quotes-and-stories-from-turing-50?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-06-24-quotes-and-stories-from-turing-50</guid>
   <pubDate>Sat, 24 Jun 2017 20:00:52 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;The ACM recently hosted &lt;a href="https://www.acm.org/turing-award-50"&gt;a celebration of 50 years of the A.M. Turing award&lt;/a&gt;. These are some notes and thoughts from the event, including how Fred Brooks once rented a bus, Don Knuth&amp;rsquo;s outrageous implementation of batch processing, and Judea Pearl&amp;rsquo;s theory of homo sapiens.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;script&gt;document.createElement('dialog');&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Conventions / Disclaimers:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;The blockquotes below are paraphrased, may be incorrect, and may be incorrectly attributed.  Make sure to watch the ACM&amp;rsquo;s live stream before quoting anything here!!!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Section-breaks are labeled as &amp;ldquo;panel&amp;rdquo;, &amp;ldquo;talk&amp;rdquo;, &amp;ldquo;question&amp;rdquo;, etc.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;This is intentionally &amp;ldquo;bad writing&amp;rdquo; in the Peter Lee sense (see below)  &amp;mdash; primarily &amp;ldquo;what I saw&amp;rdquo;, very little about &amp;ldquo;what I thought and felt&amp;rdquo;.  A summary in my own words just wouldn&amp;rsquo;t do justice to the panelists.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The &amp;ldquo;Augmented Reality&amp;rdquo; session was my favorite.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="opening-remarks"&gt;Opening Remarks&lt;/h3&gt;

&lt;h4 id="alan-turing-is-with-us-today"&gt;&lt;em&gt;Alan Turing is with us today&lt;/em&gt;&lt;/h4&gt;

&lt;p&gt;At the start of the event, the &lt;a href="http://users.ecs.soton.ac.uk/wh/"&gt;emcee&lt;/a&gt; unveiled a bronze bust of Alan Turing. This statue was on display at center stage during the whole event.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a good sculpture and it&amp;rsquo;s good we remember Alan Turing, but I&amp;rsquo;m sad  that the ACM would encourage this kind of idol-worship. Let&amp;rsquo;s not forget Turing&amp;rsquo;s excellent teachers and colleagues!&lt;/p&gt;

&lt;h3 id="talk-impact-of-turing-recipients-work"&gt;talk: Impact of Turing Recipients&amp;rsquo; Work&lt;/h3&gt;

&lt;h5 id="barbara-liskov"&gt;Barbara Liskov&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;the first awards recognized achievements in the standard fields of theory, AI, and systems&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;hostile environment around the first awards, trepidation about future awards&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;with Unix, Ritchie and Thompson got the design right&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;Niklaus Wirth: &amp;ldquo;If I understood how important Pcode was, I would have spent more time designing it&amp;rdquo;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="thoughts"&gt;thoughts&lt;/h4&gt;

&lt;p&gt;What is &amp;ldquo;systems&amp;rdquo; &amp;mdash; does that even have a definition? And Unix is definitely NOT an example of a &amp;ldquo;right design&amp;rdquo;; rather it&amp;rsquo;s a  landmark of &lt;a href="https://www.dreamsongs.com/WorseIsBetter.html"&gt;worse is better&lt;/a&gt; design.&lt;/p&gt;

&lt;h3 id="panel-advances-in-deep-neural-networks"&gt;panel: Advances in Deep Neural Networks&lt;/h3&gt;

&lt;h4 id="stuart-russell"&gt;Stuart Russell&lt;/h4&gt;

&lt;blockquote&gt;
 &lt;p&gt; &lt;em&gt;I work in all areas of AI except for deep learning&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="judea-pearl"&gt;Judea Pearl&lt;/h4&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I am a foreigner in this field &amp;hellip; left because human beings are not good at handling information &amp;hellip; people are very good with causal inference, not with statistical inference &amp;hellip; deep learning is statistical&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;there is a very old existence proof, homo sapiens took over the planet &amp;hellip; I believe because they had an internal model of their environment &amp;hellip; a drawing of a lion with wings is evidence of this model, you have  to have such a model before you can experiment with it and imagine &amp;hellip; snakes have superb optics, result of a long  evolution process &amp;hellip; very specific but they cannot build eyeglasses &amp;hellip; humans have an internal model, can build a market based on promises  and build large communities based on promises&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;I see four levels &amp;hellip; second level is predicting events, if I do X then what? &amp;hellip; third level is counterfactual, if I did things differently then how would the outcome change &amp;hellip; very hard to advance between levels, are we working to help machine learning &amp;lsquo;level up&amp;rsquo;?&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;data science is about the relation between data and reality &amp;hellip; data alone is not data science&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="michael-jordan"&gt;Michael Jordan&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;today we can&amp;rsquo;t think without holding a piece of metal&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;machine learning is part of computer science rather than AI &amp;hellip; AI is about how to make human &amp;hellip; machine learning is about allocating resources &amp;hellip; matrices are not all of human intelligence &amp;hellip; neural nets are part of a wider toolbox &amp;hellip; too much hype in NLP its just syntax&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;huge gap between syntax and semantics &amp;hellip; chat bots are just syntax, don&amp;rsquo;t learn &amp;hellip; faking intelligence with neural nets, so well that you can build a company &amp;hellip;&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;real metric is task completion&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;if I say &amp;lsquo;a GLEEB walked across the airport&amp;rsquo; then true intelligence can make a lot of educated guesses about a &amp;lsquo;GLEEB&amp;rsquo; without any other context&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fei-fei-li"&gt;Fei-Fei Li&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I disagree, ML is part of AI &amp;hellip; understanding intelligence and making intelligent methods for solving AI problems&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;to quote Churchhill &amp;lsquo;its not beginning of end, not end, not beginning of end, probably end of beginning&amp;rsquo;&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;todays AI powered by hardware and data&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;AI cannot yet find our keys&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;quote: &amp;lsquo;todays AI is making a perfect chess move while the world is on fire&amp;rsquo; &amp;hellip; ignores context&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="stuart-russell"&gt;Stuart Russell&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Turing &amp;hellip; a program is a mathematical object &amp;hellip; math community did not recognize this&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;lots of grad student descent &amp;hellip; tuning to get performance &amp;hellip; deep learning is neglecting the problem of exponential data &amp;hellip; deep learning is just circuits, circuits lack expressive power &amp;hellip; a human can process data from CERN but a neural net cannot, need to know physics&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;probabilistic programming, somewhat under the radar, maybe on the right track &amp;hellip; 10-line program running/generating/updating a large network of possibilities &amp;hellip; more composable and flexible&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="ilya-sutskever"&gt;Ilya Sutskever&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;why I like deep learning &amp;hellip; philosophically satisfying &amp;hellip; the hypothesis class is a circuit &amp;hellip; powerful hypothesis class not too many parameters &amp;hellip; can actually find circuits &amp;hellip; &amp;lsquo;violates all theory&amp;rsquo; &amp;hellip; really amazing &amp;hellip; humans can see and hear pretty fast, even though our neurons are pretty slow, perhaps because we do a massively parallel process that doesn&amp;rsquo;t take many steps &amp;hellip; works well enough to be useful&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;models e.g. for vision are very hard to understand &amp;hellip; fight fire with fire &amp;hellip; incomprehensible solution to incomprehensible problem&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="raquel-urtasun"&gt;Raquel Urtasun&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;the breakthrough in neural nets is not algorithms &amp;hellip; it is tricks, hardware, and grad students&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;with neural nets we forget about modeling, uncertainty, and prior knowledge &amp;hellip; perception is a canonical example&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-boundaries"&gt;question: boundaries&lt;/h4&gt;

&lt;h5 id="judea-pearl"&gt;Judea Pearl:&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;glad to see people in deep learning understand its limitations &amp;hellip; is there a clearer definition of the boundaries? Are you worried about bridging the levels factual/inferential/counterfactural?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="michael-jordan"&gt;Michael Jordan&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;the big problem is decision making under uncertainty&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fei-fei-li"&gt;Fei-Fei Li&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;cognition is a hard problem&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="judea-pearl"&gt;Judea Pearl&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;do you have a clear idea of the boundaries?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="michael-jordan"&gt;Michael Jordan&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;neural nets use back-propagation &amp;hellip; its non-modular, sad fact &amp;hellip; performance and explainability is the tradeoff &amp;hellip; then again people are non-modular&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="stuart-russell"&gt;Stuart Russell&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;AlphaGo is not deep learning &amp;hellip; basically an improved version of the machines Arthur Samuel made in the late 1950s &amp;hellip; the interesting code is in C++ &amp;hellip; rules of go, next moves, searching future states &amp;hellip; depends on transitive closure&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="judea-pearl"&gt;Judea Pearl&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;can AlphaGo take advice from a human?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="michael-jordan"&gt;Michael Jordan&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;not currently, but that would be a new policy to add to the toolbox &amp;hellip; just as neural nets are one tool within AlphaGo&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="raquel-urtasun"&gt;Raquel Urtasun&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;no reason to ask if deep learning is going to solve all problems&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-education"&gt;question: education?&lt;/h4&gt;

&lt;h5 id="judea-pearl"&gt;Judea Pearl&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;indeed, what DO you teach in your neural networks classes?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fei-fei-li"&gt;Fei-Fei Li&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;&amp;hellip; chain rule, Taylor expansion&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="judea-pearl"&gt;Judea Pearl&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;teaching is communicating truths &amp;hellip; what is true about neural nets? what are some things that will definitely not happen?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="stuart-russell"&gt;Stuart Russell&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Peter Norvig and I have a problem with our AI book &amp;hellip; chapter on vision, chapter on speech, will probably post just point to the neural nets chapter &amp;hellip; we don&amp;rsquo;t really understand! &amp;hellip; really selling students short&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fei-fei-li"&gt;Fei-Fei Li&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;in labs we talk about what we cannot do &amp;hellip; we all have open problems&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;Stuart I hope you have a very good author for the chapters. There are so many open problems to communicate to students!&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="michael-jordan"&gt;Michael Jordan&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;CS cirriculum needs more statistics, inferential thinking &amp;hellip; revise the whole cirriculum bottom-up to weave this in&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-could-a-neural-net-fix-my-phone-without-breaking-it"&gt;question: could a neural net fix my phone without breaking it?&lt;/h4&gt;

&lt;h5 id="judea-pearl"&gt;Judea Pearl&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;right! big problem that neural nets have no internal model to manipulate&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-generalizability"&gt;question: generalizability?&lt;/h4&gt;

&lt;h5 id="ilya-sutskever"&gt;Ilya Sutskever&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;special-purpose vs. general purpose solution depends on the problem &amp;hellip; most things we give special-purpose solutions &amp;hellip; I guess if you wanted to automate a mathematician that would need to be general&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="stuart-russell"&gt;Stuart Russell&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;always argue with your self &amp;hellip; try to break what you&amp;rsquo;ve built &amp;hellip; there&amp;rsquo;s a system that plays video games just using the pixels on screen as hints &amp;hellip; it&amp;rsquo;s very good at mazes; if a newborn baby learned to play maze games in 2 hours that would be amazing! &amp;hellip; does the system scale? absolutely not&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="thoughts"&gt;thoughts&lt;/h4&gt;

&lt;p&gt;When Michael Jordan said &amp;ldquo;people are non-modular&amp;rdquo;, I think he means that people are able  to break abstraction barriers when needed.&lt;/p&gt;

&lt;h3 id="panel-restoring-personal-privacy-without-compromising-national-security"&gt;panel: Restoring Personal Privacy without Compromising National Security&lt;/h3&gt;

&lt;h5 id="joan-feigenbaum"&gt;Joan Feigenbaum&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;&amp;hellip; wikileaks &amp;hellip; russian hackers &amp;hellip; social emergency &amp;hellip;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="whitfield-diffie"&gt;Whitfield Diffie&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;everything I say today is copyleft&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;its a misunderstanding to talk about a conflict between security and privacy &amp;hellip; two aspects &amp;hellip; problem goes back to feudalism &amp;hellip; the right to build a castle was granted by the king &amp;hellip; on one hand a castle improves national security &amp;hellip; on the other hand a castle can be used to attack the king &amp;hellip; technology is upsetting the basic notion of private vs. public security &amp;hellip; governments cannot protect citizens and cannot protect themselves &amp;hellip; extremely difficult to prove that a small process is secure&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;exceptional access makes it more complex&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="paul-syverson"&gt;Paul Syverson&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;major concern are national security threats and ability of authorities to confound threats &amp;hellip; analogy to printing press &amp;hellip; proclimation of 1635 that only state messengers can carry letters &amp;hellip; 1663 treatise by the national censor, no printing house can have a back door &amp;hellip; the general topic is very old &amp;hellip; title of this session isn&amp;rsquo;t very good, the real dilemma is investigation vs privacy&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="bryan-ford"&gt;Bryan Ford&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;code is law for better or worse, tech is not a tool like a watch &amp;hellip; tech can monitor us and decide when it works &amp;hellip; tech is government, not obedient tools &amp;hellip; the mind is a warrant-proof space &amp;hellip; 5th amendment rights should extend to wearables&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="nadia-heninger"&gt;Nadia Heninger&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;cannot divorce the security/privacy issues from the current political context &amp;hellip; the serious vulnerabilities are not in math &amp;hellip; they are in users and implementors&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-back-doors"&gt;question: back doors&lt;/h4&gt;

&lt;h5 id="joan-feigenbaum"&gt;Joan Feigenbaum&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;perhaps we should explain what a back door is&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="bryan-ford"&gt;Bryan Ford&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;agency keeps a master key in escrow&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;non-lawyers can and should take a stand on basic issues&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;there are legitimate warrant-proof spaces &amp;hellip; electronic extensions of the mind need to be recognized as warrant-proof spaces&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;the set of authorities with backdoor access should change as I travel between countries &amp;hellip; but this will lead to a global race to the bottom&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="whitfield-diffie"&gt;Whitfield Diffie&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;germany has a law against sex tourism (committed by German citizens visiting other countries) &amp;hellip; neither government will be willing to lose backdoor access&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="nadia-heninger"&gt;Nadia Heninger&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;technical reasons against backdoors &amp;hellip; (1) &amp;lsquo;weak crypto&amp;rsquo; was implemented, nobody turned it off, is now breakable by anyone in 2015 &amp;hellip; (2) Juniper used non-default crypto parameters, someone (inside?) changed the parameters &amp;hellip; (3) attackers exploit back doors&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="paul-syverson"&gt;Paul Syverson&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;quote &amp;lsquo;you can put a man on the moon, surely you can put a man on the sun&amp;rsquo;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="whitfield-diffie"&gt;Whitfield Diffie&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;trouble is getting him back safely&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="bryan-ford"&gt;Bryan Ford&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I think back doors are okay, but not for personal devices &amp;hellip; need public lab and transparent processes, need separation of powers &amp;hellip; prosecutors are getting cases thrown out because courts do not accept their backdoors &amp;hellip; there is a place for transparent back door tools&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="nadia-heninger"&gt;Nadia Heninger&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;politicians are rarely technical people&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="bryan-ford"&gt;Bryan Ford&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;tech is not a set of policy-neutral tools, need to address gap of understanding&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-"&gt;question: ???&lt;/h4&gt;

&lt;h5 id="whitfield-diffie"&gt;Whitfield Diffie&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;we don&amp;rsquo;t know how to build good crypto programs &amp;hellip; opponents are debugging our programs with different goals &amp;hellip; we&amp;rsquo;re trying for-all-paths safety (universal) &amp;hellip; they&amp;rsquo;re trying exists-bad-path (existential)&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="bryan-ford"&gt;Bryan Ford&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;cybersecurity market is a lemon market&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-how-to-advise"&gt;question: how to advise&lt;/h4&gt;

&lt;h5 id="joan-feigenbaum"&gt;Joan Feigenbaum&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;question from audience &amp;lsquo;I am an advisor to a company working with nuclear energy, they are terrified of being attacked, how should I advise them?&amp;rsquo;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="whitfield-diffie"&gt;Whitfield Diffie&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;a network like that is probably separated enough to be safe &amp;hellip; the problem is being safe AND connected to the web&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="bryan-ford"&gt;Bryan Ford&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;because the internet of things&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-what-should-the-acm-do"&gt;question: what should the ACM do?&lt;/h4&gt;

&lt;h5 id="nadia-heninger"&gt;Nadia Heninger&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;maybe we need increased regulation, the ACM could help bring experts together&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-what-is-true-security"&gt;question: what is true security&lt;/h4&gt;

&lt;h5 id="paul-syverson"&gt;Paul Syverson&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;it&amp;rsquo;s all the same thing &amp;hellip; gets labeled differently &amp;hellip; just trying to control which bits can go where and who gets to read them&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="nadia-heninger"&gt;Nadia Heninger&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;security is the absense of being violated&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="paul-syverson-no-true--security-need-to-consider-context"&gt;Paul Syverson: &lt;em&gt;no true &amp;gt; security, need to consider context&lt;/em&gt;&lt;/h5&gt;

&lt;h5 id="joan-feigenbaum"&gt;Joan Feigenbaum&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;problem of our community, have strict standards, may be unrealistic &amp;hellip; maybe a lot more tolerance in practice than our model accepts&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="paul-syverson"&gt;Paul Syverson&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;security and privacy are environmental problems&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-can-we-stop-the-needle-in-haystack-search-for-vulnerabilities"&gt;question: can we stop the needle-in-haystack search for vulnerabilities?&lt;/h4&gt;

&lt;h5 id="paul-syverson"&gt;Paul Syverson&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;need to build in security from the start&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="bryan-ford"&gt;Bryan Ford&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;need rule of law, transparency, separation of powers&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="whitfield-diffie"&gt;Whitfield Diffie&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;stop delaying, instead of spending $$$ on fixing problems, we should invest in solving the fundamental issues&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="panel-preserving-our-past-for-the-future"&gt;panel: Preserving our Past for the Future&lt;/h3&gt;

&lt;p&gt;Note: I was volunteering during this session; quotes are sparse&lt;/p&gt;

&lt;h5 id="mahadev-satyanarayanan"&gt;Mahadev Satyanarayanan&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;the running system is the total documentation &amp;hellip; there are too many details for prose to capture&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id=""&gt;??&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;running old code has a danger of running old bugs&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id=""&gt;??:&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;what not to save? &amp;hellip; it&amp;rsquo;s very hard to tell in advance&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="mahadev-satyanarayanan"&gt;Mahadev Satyanarayanan:&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;there is no absolute censor in a world with caching&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="brewster-kahle"&gt;Brewster Kahle&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;asking UNESCO to solve the problem is unrealistic &amp;hellip; need to empower the fanatics, given them tools to preserve data&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="thoughts"&gt;thoughts&lt;/h4&gt;

&lt;p&gt;I totally agree with the &amp;ldquo;empower the fanatics&amp;rdquo; sentiment. Today, because of &amp;ldquo;volunteer librarians&amp;rdquo;, I think we&amp;rsquo;re doing pretty well about preserving  the past. Suppose I found an old PowerPoint file. I&amp;rsquo;m sure I could find a way to read it with help from the internet &amp;mdash; either  by searching Google, pirating an old version of PowerPoint, or asking online forums. So personally I&amp;rsquo;m not worried about losing data we have currently; I&amp;rsquo;m more  worried about the future, the internet becoming &amp;ldquo;less chaotic&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The panel raised a good question about how to preserve research and encourage reproducibility. A &lt;code&gt;.pdf&lt;/code&gt; or &lt;code&gt;.tex&lt;/code&gt; document is not enough; a virtual machine is okay. Really I think we need a stronger cultural emphasis on literate programming  and a mature library like TeX to help authors store and share their work. &lt;a href="https://thegamma.net/"&gt;The Gamma&lt;/a&gt; seems on the right track.&lt;/p&gt;

&lt;p&gt;I was surprised that the panel did not discuss search, version control, and  the ACM&amp;rsquo;s open-access policy.&lt;/p&gt;

&lt;h3 id="panel-moores-law-is-really-dead-whats-next"&gt;panel: Moore&amp;rsquo;s Law is Really Dead: What&amp;rsquo;s Next?&lt;/h3&gt;

&lt;p&gt;Note: I was volunteering during this session&lt;/p&gt;

&lt;h5 id="butler-lampson"&gt;Butler Lampson&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;there&amp;rsquo;s plenty of room at the top &amp;hellip; with Moore&amp;rsquo;s Law we got improvements at the bottom of the software stack, everything above got to benefit and it was easy to integrate the changes &amp;hellip; there&amp;rsquo;s lots of opportunities to trim fat in the middle/top of the software stack &amp;hellip; these improvements will be harder to integrate, but there&amp;rsquo;s lots of opportunities&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="margaret-martonosi"&gt;Margaret Martonosi&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;By the way, don&amp;rsquo;t believe the brochure that says I&amp;rsquo;m at Google. My affiliation is Princeton, Google and I are just friends.&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="butler-lampson"&gt;Butler Lampson&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;important to distinguish approximate vs. precise software &amp;hellip; precise software has a specification and the customer cares about that specification &amp;hellip; approximate software doesn&amp;rsquo;t have a hard spec, just needs to approximately work &amp;hellip; the web is approximate, it doesn&amp;rsquo;t work and it doesn&amp;rsquo;t need to! &amp;hellip; windows is precise, definitely has a spec and users definitely care&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="thoughts"&gt;thoughts&lt;/h4&gt;

&lt;p&gt;The recording of this panel should be good; it was very lively, very practical. And the first audience question (by &lt;a href="https://people.eecs.berkeley.edu/~pattrsn/"&gt;David Patterson&lt;/a&gt;) was &amp;ldquo;an A+ question&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The panel reminded me of a talk by &lt;a href="http://users.ece.utexas.edu/~patt/"&gt;Yale Patt&lt;/a&gt;  about &amp;ldquo;the end&amp;rdquo; of the Von Neumann architecture. His opinion is future computers will be Von Neumann machines that rely  on &amp;ldquo;accelerators&amp;rdquo; like a GPU &amp;mdash; computer organization is not going to change,  but will expand to have a bigger toolbox. So sure, Moore&amp;rsquo;s Law is dead, but there are many opportunities to make  computers faster at places other than the bottom of the software stack.&lt;/p&gt;

&lt;h3 id="panel-challenges-in-ethics-and-computing"&gt;panel: Challenges in Ethics and Computing&lt;/h3&gt;

&lt;p&gt;Note: I was volunteering during this session&lt;/p&gt;

&lt;h5 id="raj-reddy"&gt;Raj Reddy&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;there are more slaves in the world currently than there were in the US during the civil war &amp;hellip; here is one way technology could help, by giving everone a device to record their location &amp;hellip; if someone&amp;rsquo;s time and location is constant, they may be held against their will&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id=""&gt;??&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;do you believe every problem has a technological solution?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="noel-sharkey"&gt;Noel Sharkey&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;yes the training set may be biased against people similar to me, but I want you to consider my case as an individual&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id=""&gt;??&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;a very nice Washington Post article&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id=""&gt;??&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;whether to encrypt the back hall&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="raj-reddy"&gt;Raj Reddy&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;we can sit here and wring our hands, but nothing will come of it unless it is written in the US constitution&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="thoughts"&gt;thoughts&lt;/h4&gt;

&lt;p&gt;I did not enjoy this panel. This is an ACM event, not a United Nations event. An ACM-sponsored panel about social and political problems should  look for constructive ways that computer science can address these problems. Raj Reddy tried to give constructive solutions, but the panel seemed more  interested in complaining about how hopeless things are.&lt;/p&gt;

&lt;p&gt;The comment by Noel Sharkey about &amp;ldquo;consider me as an individual&amp;rdquo; was something  I hadn&amp;rsquo;t thought about. Instead of worrying about biased datasets, let&amp;rsquo;s use technology to  collect data on an individual instead of abstracting a person by their  race, age, or neighborhood.&lt;/p&gt;

&lt;h3 id="talk-computer-science-as-a-major-body-of-accumulated-knowledge"&gt;talk: Computer Science as a Major Body of Accumulated Knowledge&lt;/h3&gt;

&lt;h5 id="donald-knuth"&gt;Donald Knuth&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt; &lt;em&gt;don&amp;rsquo;t applaud me, just read my books&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;at the time, computer science was AI, numerical analysis, and programming languages&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;a colleague said &amp;lsquo;I will believe that computer science is a science when it has 1000 deep theorems&amp;rsquo; &amp;hellip; I am not sure what a deep theorem is but I think its different from what&amp;rsquo;s proven by deep learning&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;great privilege that we can invent the problems we work on &amp;hellip; imagination &amp;hellip; physicists can only guess the size of the sun&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;I&amp;rsquo;ve always believed computer science and math are two parallel subjects &amp;hellip; sometimes you hear people wondering if one subsumes the other&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;when I won the Turing Award, the prize money was about $1,000,000 less than it is today &amp;hellip; I did get a nice Tiffany bowl that my wife and I use to serve strawberries &amp;hellip; strawberries actually taste better &amp;hellip;&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;very fortunate in this field &amp;hellip; I&amp;rsquo;m completely worthless as an economic advisor &amp;hellip; it&amp;rsquo;s a game I&amp;rsquo;ve been able to take advantage of&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-how-could-you-offer-to-pay-for-tex-bug-reports"&gt;question: how could you offer to pay for TeX bug reports?&lt;/h4&gt;

&lt;h5 id="donald-knuth"&gt;Donald Knuth&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;well there were many, many bugs &amp;hellip; I stopped doubling at 32768 &amp;hellip; brought people out of nowhere &amp;hellip; next time I check the bug reports will be 2021 &amp;hellip; someone is queueing the bugs reports &amp;hellip; I believe strongly in batch rather than swap-in/swap-out &amp;hellip; last time I checked reports was 2014 so 2021 will be next&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;TeX was a literate program, and it helped that I wrote &amp;lsquo;The Errors of TeX&amp;rsquo; about the first N bugs&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-do-you-think-computers-will-become-good-composers-of-music-do-you-see-a-role-for-computer-assisted-proving"&gt;question: do you think computers will become good composers of music? do you see a role for computer-assisted proving?&lt;/h4&gt;

&lt;h5 id="donald-knuth"&gt;Donald Knuth&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Yes in part, assisted is the key word &amp;hellip; I have a program running now that I hope will help me prove a theorem&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-favorite-algorithm"&gt;question: favorite algorithm?&lt;/h4&gt;

&lt;h5 id="donald-knuth"&gt;Donald Knuth&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Tarjan&amp;rsquo;s strong components &amp;hellip; short deep useful&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-thoughts-on-ai-computers-taking-over"&gt;question: thoughts on AI, computers taking over?&lt;/h4&gt;

&lt;h5 id="donald-knuth"&gt;Donald Knuth&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I get scared when I see Stuart Russell making assumptions based on people acting rationally &amp;hellip; then you look at election results&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-if-you-could-start-over-and-do-things-differently-what-would-you-change"&gt;question: if you could start over and do things differently, what would you change?&lt;/h4&gt;

&lt;h5 id="donald-knuth"&gt;Donald Knuth&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I would use decimal internally in TeX instead of binary&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-how-to-record-history"&gt;question: how to record history?&lt;/h4&gt;

&lt;h5 id="donald-knuth"&gt;Donald Knuth&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;a video &amp;lsquo;Lets not dumb down the history of CS&amp;rsquo; &amp;hellip; used to be history of algorithms &amp;hellip; trouble with funding &amp;hellip; the history is nothing that a non-CS person could not understand &amp;hellip; the whole field of history changed from internal to external &amp;hellip; historians need to be external to get published in journals &amp;hellip; no CS department supports a historian &amp;hellip; recently read a dissertation about the ALGOL 60 copmiler &amp;hellip; very careful, describes data structures and organization &amp;hellip; this kind of thing is what deserves to be called history&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-teachers"&gt;question: teachers&lt;/h4&gt;

&lt;h5 id="donald-knuth"&gt;Donald Knuth&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;hardest thing for me is choosing between two hypotheses (1) could teach this to anyone (2) only 2% of the world is geeks &amp;hellip; suppose the second is true then you can&amp;rsquo;t talk about how to teach if the teacher is not in the 2% &amp;hellip;&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;the newest issue of CACM has a fun typo, &amp;lsquo;deep earning&amp;rsquo;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="panel-quantum-computing-far-away-around-the-corner-or-maybe-both-at-the-same-time"&gt;panel: Quantum Computing: Far Away? Around the Corner? Or Maybe Both at the Same Time?&lt;/h3&gt;

&lt;h5 id="john-martinis"&gt;John Martinis&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;goal to have a 45&amp;ndash;50 qbit machine &amp;hellip; 1 error per 1000 operations &amp;hellip; to test, run sample algorithm, chart output vs. a classical supercomputer &amp;hellip; got to be a supercomputer to finish the computation in time&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="andrew-yao"&gt;Andrew Yao&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I&amp;rsquo;m a believer &amp;hellip; one suggested benchmark is to factor 1000-digit numbers &amp;hellip; impossible to attain &amp;hellip; need to expore new possibilities, take physics attitute&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;CS did well attracting attention to quantum &amp;hellip; science should be more open &amp;hellip; share results between physics chemistry CS &amp;hellip; don&amp;rsquo;t just stick to your specialized conferences&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;CS departments reception to quantum is less than satisfactory &amp;hellip; 15 years ago, maybe 4 or 5 universities &amp;hellip; now, maybe 7 or 8 .. China doing much better in this regard&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="jay-gambetta"&gt;Jay Gambetta&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;not useful to make analogy to anything classical &amp;hellip; universal fault tolerance? or computation in the presence of error &amp;hellip; either would be excellent, still a long way off&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;IBM put quantum on the cloud &amp;hellip; picked an instruction set that tries to abstract away &amp;hellip; have been 19 published papers on the behavior of this quantum hardware&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="dorit-aharonov"&gt;Dorit Aharonov&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;two paths &amp;hellip; finding algorithms, besides Shor&amp;rsquo;s algorithm &amp;hellip; make quantum computer to realize the algorithms &amp;hellip; finding algorithms is very difficult &amp;hellip; information-processing point-of-view&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;error correction still small scale &amp;hellip; can we use entanglement between probes to improve accuracy?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="umesh-vazirani"&gt;Umesh Vazirani&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;_different goals &amp;hellip; maybe you want perfect Qbits for a perfect Hilbert space &amp;hellip; reality is a noisy space &amp;hellip; short run, how to compute with noise &amp;hellip; how to correct errors &amp;hellip;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="jay-gambetta"&gt;Jay Gambetta:&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;_those 2 paths are the same to me &amp;hellip; we want larger devices with fidelity&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;lets build hardware see where goes &amp;hellip; exciting prospect, computer scientists will explore what they can do with these erroneous qbits &amp;hellip; that&amp;rsquo;s why IBM has the instruction set open to the community&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-why-isnt-adding-10-qbits-only-10x-harder"&gt;question: why isn&amp;rsquo;t adding 10 qbits only 10x harder?&lt;/h4&gt;

&lt;h5 id="john-martinis"&gt;John Martinis:&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;building infrastructure to scale &amp;hellip; not just grad student code &amp;hellip; we&amp;rsquo;re all good coders using standard industry practices for coding&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="jay-gambetta"&gt;Jay Gambetta&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;fidelity is hard to achieve&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-both-ibm-and-google-use-superconducting-storage"&gt;question: both IBM and Google use superconducting storage?&lt;/h4&gt;

&lt;h5 id="john-martinis"&gt;John Martinis&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;superconducting scales &amp;hellip; ion traps harder to scale, but we still watch, keep eye on data&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-education"&gt;question: education&lt;/h4&gt;

&lt;h5 id="john-martinis"&gt;John Martinis&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I like talking to engineering colleges &amp;hellip; physics and engineering need to work together&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-is-quantum-going-to-change-programing-languages"&gt;question: is quantum going to change programing languages?&lt;/h4&gt;

&lt;h5 id="jay-gambetta"&gt;Jay Gambetta&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;yes very different to handle errors &amp;hellip; current challenge is building an abstraction over the superconducting hardware&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="john-martinis"&gt;John Martinis&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;hoping to first expose hardware, then get a model, eventually a language&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="dorit-aharonov"&gt;Dorit Aharonov&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;need to start with more algorithms&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-what-would-feynman-do"&gt;question: what would Feynman do?&lt;/h4&gt;

&lt;h5 id="john-martinis"&gt;John Martinis&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;experiments!&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="dorit-aharonov"&gt;Dorit Aharonov&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;yes he&amp;rsquo;d tell us to keep playing, and play with us&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="panel-augmented-reality-from-gaming-to-cognitive-aids-and-beyond"&gt;panel: Augmented Reality: From Gaming to Cognitive Aids and Beyond&lt;/h3&gt;

&lt;p&gt;Peter Lee starts off wearing a headset.&lt;/p&gt;

&lt;h5 id="ivan-sutherland"&gt;Ivan Sutherland:&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I can tell you how VR started. Bell Helicopter company wanted to land at night &amp;hellip; put an infrared camera on the landing site and a display in the cockpit &amp;hellip; to test they used the roof of their building &amp;hellip; one day an observer in a Bell office is watching, though the camera, two men playing catch on the roof &amp;hellip; one player threw the ball at the camera and the observer ducked &amp;hellip; he had identified his position with the camera &amp;hellip; my observation was that you didn&amp;rsquo;t need a camera, could substitute a computer &amp;hellip; the rest is history&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="yvonne-rogers"&gt;Yvonne Rogers&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;my goal is to augment people &amp;hellip; &lt;a href="https://en.wikipedia.org/wiki/The_Mother_of_All_Demos"&gt;Englebart&lt;/a&gt; very inspiring &amp;hellip; ok 2 stories &amp;hellip; (1) a student of mine wanted to help picky eaters &amp;hellip; computer vision for when they tried to hide peas under the plate &amp;hellip; projected colors onto the peas, called them &amp;lsquo;disco peas&amp;rsquo;, kids were distracted enough to get over their aversion &amp;hellip; children and parents got involved, new social interaction &amp;hellip; (2) opera makeup for schoolchildren, virtually getting into character &amp;hellip; teenage boys in the classes got to try makeup for the first time &amp;hellip; singers found it useful for rehearsals&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I feel socially awkward wearing this headset, but I have some of my slides here &amp;hellip; making a wearable headset requires huge effort &amp;hellip; research prototypes can be uncomfortable &amp;hellip; a product needs to be perfect and its very hard to do perfect &amp;hellip; one goal, give Lowe&amp;rsquo;s VR to demo a virtual kitchen &amp;hellip; Case Western anatomy class used virtual cadaver, great collective experience&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;two stories &amp;hellip; (1) Henry Fuchs 1998, working with breast surgeon, try augmented reality to improve the precision of biopsy probe insertion &amp;hellip; 2 years to a working prototype, hard to track surgeon&amp;rsquo;s eyes, display where probe is, where ultrasound is, provide low latency &amp;hellip; one day trying on live patient, worked 100% perfect probe right on the mark, jubilation &amp;hellip; then the doctor had to tell the patient &amp;lsquo;yes it is really cancer&amp;rsquo; &amp;hellip; (2) a challenge, augmented reality EMT training &amp;hellip; real teams, virtual patient, virtual surround &amp;hellip; track real tools, 8 eyes, 8 images, team needs to interact&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-what-are-current-uses-of-augmented-reality"&gt;question: what are current uses of augmented reality?&lt;/h4&gt;

&lt;h5 id="ivan-sutherland"&gt;Ivan Sutherland&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;the pilot of a jumbo jet typically has 1 hour flight experience before he flies for the first time, but extensive training in a flight simulator&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;the &lt;strong&gt;best&lt;/strong&gt; AR&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="ivan-sutherland"&gt;Ivan Sutherland&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;once I was in a flight simulator with the chief pilot &amp;hellip; and he turned to me and asked &amp;lsquo;have you ever experienced a slow roll in a 747?&amp;rsquo; &amp;hellip; a slow roll is a twisting motion, a very benign maneuver, constant one-G pressure the plane doesn&amp;rsquo;t know its upside down &amp;hellip; &amp;lsquo;here we go&amp;rsquo; and suddenly the world inverted &amp;hellip; I remarked that it was certainly impressive, but didn&amp;rsquo;t you treat the simulator as a real experience, and never attempted anything you would not do in reality? &amp;hellip; &amp;lsquo;that is true, but I am the chief pilot&amp;rsquo;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;construction, architecture&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;where&amp;rsquo;s the &amp;lsquo;augmented&amp;rsquo;?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;whether augmented or virtual&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;yes we did my kitchen that way, made my wife sick when she tried it&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;surgical&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;still sounds virtual&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="yvonne-rogers"&gt;Yvonne Rogers&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;displays on a car, superimposed directions on the tarmac &amp;hellip; one of the users took a vacation and had to use the old GPS technology &amp;hellip; found it very difficult to go back&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-ar-tools-for-developers"&gt;question: AR tools for developers?&lt;/h4&gt;

&lt;h5 id="blair-macintyre"&gt;Blair MacIntyre&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;can developers write apps for the Microsoft &lt;a href="https://www.microsoft.com/en-us/hololens"&gt;Hololens&lt;/a&gt;?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;we belive in experience, anything we can do to foster experiences is good&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;faking things &amp;hellip; subtle and important &amp;hellip; I remember using a flight simulator, navigating the runway, and I turned my head to see if my wing was going to clip a plane &amp;hellip; turned and there was nothing there &amp;hellip; emotional shock to leave the simulation, I had been flying for 1 hour&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="ivan-sutherland"&gt;Ivan Sutherland&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;pilot training is an early adopter because the cost of real planes is so high, impossible to train for emergency situations&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;the ultimate goal, you can sit in a virtual chair &amp;hellip; and if the chair has handcuffs you cannot get up &amp;hellip; a virtual bullet is lethal &amp;hellip; probably impossible because bits don&amp;rsquo;t weigh anything &amp;hellip; you know Ben Franklin invented augmented reality, eyeglasses &amp;hellip; the desire outweighs cost &amp;hellip; I cannot see the audience here, maybe it would be good if I had a headset! but Peter took his off&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;because of my slides I couldn&amp;rsquo;t see the audience, but then without the headset I couldn&amp;rsquo;t see them either&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-any-challenges-to-suggest-to-the-audience"&gt;question: any challenges to suggest to the audience?&lt;/h4&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;if we had holographic transport, we wouldn&amp;rsquo;t need planes!&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="yvonne-rogers"&gt;Yvonne Rogers&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;maybe, but you need to give attendees a physical presence &amp;hellip; smell, touch&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="ivan-sutherland"&gt;Ivan Sutherland&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;what makes us willing to work together? I had a collaboration with three people &amp;hellip; all in different locations .. communicated with a phone &amp;hellip; worked perfectly, because we had worked in the same location first and knew one another so well &amp;hellip; how to get to that point, where a simulation could be a useful tool &amp;hellip; another good observation by Fred Brooks, given a domain X ask how good does the simulation need to be for X &amp;hellip; Licklider told me, you&amp;rsquo;d need damn good fiction to land someone on the moon, the simulation would need to provide every detail &amp;hellip; for flight simulation the user&amp;rsquo;s imagination can fill some gaps, a pilot can recognize an aircraft carrier from a rougher picture&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;at IBM I once hired buses to bring the Poughkeepsie secretaries to the main office &amp;hellip; the secretaries at the two offices only knew one another from the phone &amp;hellip; this one lunch did so much good &amp;hellip; only $75 to rent a bus&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;how important is it to shake hands, to bump into a table?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="yvonne-rogers"&gt;Yvonne Rogers&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;for this conference, I think the live stream is getting a better experience because the cameras zoom in on us, the panelists &amp;hellip; the audience in the back cannot see us, only a picture of us on the monitors&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;_one excellent video game, starts in the dark, you hear a voice &amp;hellip; turn around and there&amp;rsquo;s a character sitting on a chair &amp;hellip; if you rearrange your furniture he finds a new seat &amp;hellip;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="yvonne-rogers"&gt;Yvonne Rogers&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;games are a great example &amp;hellip; Pokemon Go &amp;hellip; Apple jusr released an app toolkit &amp;hellip; need to get those in schools, in the hands of kids who can build with them&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-ivan-about-your-ultimate-display-paper-what-has-since-surprised-or-frustrated-you"&gt;question: Ivan, about your &amp;lsquo;ultimate display&amp;rsquo; paper, what has since surprised or frustrated you?&lt;/h4&gt;

&lt;h5 id="ivan-sutherland"&gt;Ivan Sutherland&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I wasn&amp;rsquo;t surprised because I never had any expectations &amp;hellip; of course sticks are not real &amp;hellip; no assumptions so no strong feelings&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-people-already-distracted-by-cell-phones-how-to-manage-all-this-input"&gt;question: people already distracted by cell phones, how to manage all this input?&lt;/h4&gt;

&lt;h5 id="yvonne-rogers"&gt;Yvonne Rogers&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;good question, how much data you can present to people &amp;hellip; and then the problem with google glass, your companions don&amp;rsquo;t know what you are looking at &amp;hellip; at least with snapchat glasses, you can trust the device is simpler&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;good writing defines reality, bad writing reports it &amp;hellip; with the printing press, quickly went from 30,000 books to over 13,000,000 &amp;hellip; novels evolved shortly after, a new form of expression&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-peter-how-long-do-your-people-wear-the-hololens"&gt;question: Peter, how long do your people wear the hololens?&lt;/h4&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;hard to say &amp;hellip; but often longer than the battery lasts&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;how long does it last?&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;depends what you&amp;rsquo;re doing, 3 hours&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;that&amp;rsquo;s encouraging, we had a 30-minute cutoff because participants had enough&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-nausea"&gt;question: nausea&lt;/h4&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I get nauseous in our minecraft VR &amp;hellip; but there&amp;rsquo;s a pop-out feature where you keep playing, but the game world is in a TV set instead of around you &amp;hellip; can pop back in when you&amp;rsquo;re feeling better&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="yvonne-rogers"&gt;Yvonne Rogers&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;we&amp;rsquo;ve seen about 20% of the population gets nauseous&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="audience-member"&gt;audience member&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Dana Boyd conducted an experiment, found the nausea was worse for wemon&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="yvonne-rogers"&gt;Yvonne Rogers&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;oculus makes me feel sick, but the hololens has never given me trouble&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;have models to predict head motion, to keep the VR world steadier&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="blair-macintyre"&gt;Blair MacIntyre&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;I remember reading papers that measured framerate &amp;hellip; would be interesting to revisit&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;framerate not important, its the latency that gets you &amp;hellip; one colleague  of mine, we call her &amp;lsquo;the canary&amp;rsquo; because she&amp;rsquo;s so sensitive, in fact &amp;hellip;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="peter-lee"&gt;Peter Lee&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;talking about nausea is part of the problem, people experience it more &amp;hellip; every time I talk about it in public my co-workers tell me to stop!&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;&lt;em&gt;another cool application, there&amp;rsquo;s a hololens app to give blind people a tour of the Redmond office &amp;hellip; you say a building and it takes you there&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5 id="fred-brooks"&gt;Fred Brooks&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;one challenge, the relative brightness of the real and virtual worlds&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4 id="question-any-last-remarks"&gt;question: any last remarks&lt;/h4&gt;

&lt;h5 id="ivan-sutherland"&gt;Ivan Sutherland&lt;/h5&gt;

&lt;blockquote&gt;
 &lt;p&gt;_I hoped from the beginning that AR would be a teaching tool &amp;hellip; I learned that &lt;code&gt;F = MA&lt;/code&gt; not from a book but from a large flywheel in the school&amp;rsquo;s basement &amp;hellip; very substantial inertia &amp;hellip; the greatest value for AR would be to show people things in a way that makes the underlying meaning clear &amp;hellip; what color should the hydrogen atoms in a benzene ring be? the color will be fiction, but the quality of learning will depend on that fiction &amp;hellip; challenge for content makers &amp;hellip; what is the haptic experience of feeling bits?&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="small-group-session"&gt;Small Group Session&lt;/h3&gt;

&lt;p&gt;After the last panel, I got to attend a small group session with other students,  Dick Karp, and Don Knuth. It doesn&amp;rsquo;t feel right to summarize or quote from the  session, but there&amp;rsquo;s one thing I want to write about.&lt;/p&gt;

&lt;p&gt;During the group session, I said something that I now regret. There was a brief silence as the group changed subjects, and someone suggested that we do a round of introductions. I objected, &lt;em&gt;this will take so long&lt;/em&gt;,  but in fact the introductions were a very good idea.&lt;/p&gt;

&lt;p&gt;Normally, I don&amp;rsquo;t like introductions because they focus on names, backgrounds,  and credentials. I don&amp;rsquo;t care about any of these when I&amp;rsquo;m meeting someone! Rather, I prefer to just talk and by-the-way learn about the other person(s). There&amp;rsquo;s an anaology to double-blind reviewing &amp;mdash; the focus should be content  and not credentials.&lt;/p&gt;

&lt;p&gt;These introductions were successful for two reasons. First, they gave everyone in the room a turn to speak, and this seemed  to help people join the actual discussion sooner. That was strange to me. I always feel a little nervous the first time I speak up in front  of a group, but if I really feel like speaking then I can always get over this  little barrier. I guess it&amp;rsquo;s not right to assume the nervousness is &amp;ldquo;little&amp;rdquo; for everyone. Second, the introductions format was &amp;ldquo;say your name and a funny fact&amp;rdquo;. This prompt by itself led to some nice conversation topics:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Could a computer program decide whether a statement was funny or not funny?&lt;/li&gt;
 &lt;li&gt;What kind of humor works in a classroom? In a textbook?&lt;/li&gt;
 &lt;li&gt;Would this kind of introduction be acceptable in another era or culture,  for instance Victorian England?&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;Nice&amp;rdquo; in the sense that everyone could contribute, which was a real challenge. Even the question &amp;ldquo;does anyone have a favorite algorithm?&amp;rdquo; didn&amp;rsquo;t have much  success fostering discussion.&lt;/p&gt;

&lt;p&gt;Related: a useful greeting at the event was &amp;ldquo;what SIG are you?&amp;rdquo;. The answer was a good hint about what level of abstraction you two could best communicate at.&lt;/p&gt;
&lt;!-- ### Misc.--&gt;
&lt;!-- I noticed that some of the young people who served on panels and also gave--&gt;
&lt;!-- long-and-not-very-insightful answers to questions were later on their laptops--&gt;
&lt;!-- as other panels discussed things. I noticed some of the older people who--&gt;
&lt;!-- served on panels falling asleep during other panels--&gt;</description></item>
  <item>
   <title>Spring 2017 PL Junior Retrospective</title>
   <link>http://prl.ccs.neu.edu/blog/2017/06/16/spring-2017-pl-junior-retrospective?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-06-16-spring-2017-pl-junior-retrospective</guid>
   <pubDate>Fri, 16 Jun 2017 11:38:25 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;The &lt;a href="http://prl.ccs.neu.edu/seminars.html"&gt;PL Junior Seminar&lt;/a&gt; is for beginning PhD and interested undergrad and masters students to understand the foundations of programming languages research. It serves to fill in background knowledge and get up to speed with different areas of PL research.&lt;/p&gt;

&lt;p&gt;For the spring 2017 instance of PL Junior we chose program synthesis, the sequent calculus, and logic programming as topics we wanted to learn more about. We also did two group paper readings for Luca Cardelli&amp;rsquo;s &lt;a href="http://www.lucacardelli.name/Papers/TypefulProg.pdf"&gt;Typeful Programming&lt;/a&gt; and Alan Kay&amp;rsquo;s &lt;a href="http://worrydream.com/EarlyHistoryOfSmalltalk/"&gt;Early History of Smalltalk&lt;/a&gt;. At the same time, we changed up the format from the previous semester.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="format"&gt;Format&lt;/h2&gt;

&lt;p&gt;As discussed in &lt;a href="http://prl.ccs.neu.edu/blog/2017/01/02/fall-2016-pl-junior-retrospective/"&gt;last fall&amp;rsquo;s retrospective&lt;/a&gt;, we wanted to move from group reading and discussion towards weekly presentations. Reading a paper to prepare a presentation is quite a different experience compared to the effort that goes in when it is just for a group discussion (in our experience). With any luck, the presentation will convey some of this deeper knowledge to the rest of the group, with the result being a deep understanding on the part of the presenter and an informed, if somewhat shallower, understanding in the rest of the group. Ideally, the end result should compare favorably to simply reading the paper individually.&lt;/p&gt;

&lt;p&gt;One idea from last semester that we decided to keep is to spend a length of time (possibly an entire semester) on a topic rather than having a new topic each week. Staying on the same theme helps with retention as well as allowing for deeper investigation.&lt;/p&gt;

&lt;p&gt;In that spirit, we chose three themes for the semester: program synthesis, the sequent calculus, and logic programming. Mostly by chance, these topics have interesting connections to each other, and we even had several PL Grown-Up Seminars this semester on program synthesis!&lt;/p&gt;

&lt;h2 id="synthesis"&gt;Synthesis&lt;/h2&gt;

&lt;p&gt;The first paper on program synthesis that we looked at was &lt;a href="https://www.sri.com/sites/default/files/uploads/publications/pdf/725.pdf"&gt;A Deductive Approach to Program Synthesis&lt;/a&gt; by Manna and Waldinger. We chose this paper because it&amp;rsquo;s old and has a lot of citations so it&amp;rsquo;s probably Important. It was interesting and provided an OK introduction to proof search but the method presented seems far removed from modern synthesis techniques.&lt;/p&gt;

&lt;p&gt;The next paper was &lt;a href="https://arxiv.org/abs/1507.02988"&gt;Programmatic and Direct Manipulation, Together&lt;/a&gt; by Chugh, Hempel,  Spradlin, and Alders, which presents the &lt;a href="https://ravichugh.github.io/sketch-n-sketch/index.html"&gt;Sketch-n-Sketch&lt;/a&gt; system. Sketch-n-Sketch is a cool system. It demonstrates that a narrow application of synthesis - trying to fill in the constant values in a program (sketching) - can be used for great effect. We were left wondering, however, if it was too narrow an application of synthesis to give much of an indication of what the entire field is like.&lt;/p&gt;

&lt;p&gt;We concluded our program synthesis segment with &lt;a href="http://www.cis.upenn.edu/~stevez/papers/OZ15.pdf"&gt;Type-and-Example-Directed Program Synthesis&lt;/a&gt; by Osera and Zdancewic, another relatively recent paper. This seems like a relevant paper because we are under the impression that using examples to do synthesis is a big thing right now. Using types to constrain the search is another interesting perspective on techniques for synthesis.&lt;/p&gt;

&lt;p&gt;While each of theses papers had merits, none was so comprehensive as to be a necessary inclusion in any future look at program synthesis for pl junior&lt;/p&gt;

&lt;h2 id="sequent-calculus"&gt;Sequent Calculus&lt;/h2&gt;

&lt;p&gt;We followed up the program synthesis unit with a week on the sequent calculus. The seminar presentation was based on a paper by &lt;a href="https://hal.inria.fr/inria-00381525/document"&gt;Herbelin&lt;/a&gt;. &lt;a href="http://www.ccs.neu.edu/home/gasche/phd_thesis/scherer-thesis.pdf"&gt;Gabriel’s thesis&lt;/a&gt; (chapter 4) includes maybe a more suitable modern introduction to the sequent calculus.&lt;/p&gt;

&lt;p&gt;It might have been better to do sequent calculus first because there is a modern branch of proof search based on the sequent calculus. Presenting this first would have allowed us to look into proof search for program synthesis.&lt;/p&gt;

&lt;p&gt;An additional problem is that it was insufficiently motivated. Either skipping the topic or spending more time on it would be preferable, since one week was just enough to describe the sequent calculus but not enough to apply it. For this topic to be worthwhile, it would best be used as the basis for subsequent readings that directly reference it.&lt;/p&gt;

&lt;h2 id="logic-programming"&gt;Logic Programming&lt;/h2&gt;

&lt;p&gt;The topic was presented over two weeks. The first session presented/demoed Prolog as a language, and we got a sense of what logic programming could do. But it was a whirlwind tour, and we were left wondering about specific details (how proof search runs, what &lt;code&gt;cut&lt;/code&gt; does).&lt;/p&gt;

&lt;p&gt;The second session presented the paper &lt;a href="http://www.doc.ic.ac.uk/~rak/papers/kowalski-van_emden.pdf"&gt;The Semantics of Predicate Logic as a Programming Language&lt;/a&gt;. It was interesting and insightful but left wondering how it relates to the implementation of real logic programming languages.&lt;/p&gt;

&lt;p&gt;In hindsight this was about as far as we could have gotten in just two weeks. However, complications such as the cut rule seem prevalent enough in practice that more time would be required to build up a useful understanding of logic programming&lt;/p&gt;

&lt;h2 id="bonus-rounds"&gt;Bonus Rounds&lt;/h2&gt;

&lt;p&gt;We also used a few weeks to read and discuss specific papers as a group.&lt;/p&gt;

&lt;p&gt;The first paper we read was Cardelli&amp;rsquo;s &lt;a href="http://www.lucacardelli.name/Papers/TypefulProg.pdf"&gt;Typeful Programming&lt;/a&gt;. We picked typeful programming because Matthias has mentioned on occasion how important he thinks it is.&lt;/p&gt;

&lt;p&gt;It was an interesting read; more of an essay than a paper. It really stood out as different from the other academic publications that we have looked at. It’s a walk through of a language design motivating each design decision in practical terms, as in things that actually help the programmer.&lt;/p&gt;

&lt;p&gt;Cardelli places great importance on polymorphism (subtyping in addition to parametric), as well as features for programming in the large such as modules and interfaces. Several features are interesting in their omission, like type inference and macros.&lt;/p&gt;

&lt;p&gt;After reading it it’s not clear why Matthias thinks it’s so important. From the perspective of modern researchers, many of the features in Cardelli&amp;rsquo;s language seem rather mundane. However, it&amp;rsquo;s likely that at the time he published it, these ideas were significantly newer and much less widespread.&lt;/p&gt;

&lt;p&gt;The other paper we read as a group was Alan Kay&amp;rsquo;s &lt;a href="http://worrydream.com/EarlyHistoryOfSmalltalk/"&gt;The Early History of Smalltalk&lt;/a&gt;. It seems like the Smalltalk project investigated a plethora of interesting ideas about designing programming languages and environments. This article seems to confirm that but does not delve into many particulars.&lt;/p&gt;

&lt;h2 id="final-thoughts"&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Overall this semester of pl junior went well enough that we think it makes a reasonable template for future semesters. The topics were interesting and relevant, and we mostly picked appropriate material for presentations. One downside is that we didn’t quite ‘fill out’ the semester with presentations due to scheduling and not wanting to make some people present twice. Here’s a lesson: recruit more people to the phd program (or get more undergrads) so you don’t have this problem!&lt;/p&gt;

&lt;p&gt;Having papers in a theme helped a lot over previous paper-presentation iterations of pl junior. It helped each week being able to build on what we learned last week, as opposed to having a whirlwind of unrelated topics.&lt;/p&gt;

&lt;p&gt;Writing this retrospective has also proven to be a beneficial exercise. Especially with our sequences of connected topics, looking back has allowed us to put the earlier papers into perspective and better assess both their relevance and presentation.&lt;/p&gt;</description></item>
  <item>
   <title>[Bridging the System Configuration Gap (Cross-Post)](https://aaronweiss.us/posts/2017-06-05-bridging-the-system-configuration-gap.html)</title>
   <link>http://prl.ccs.neu.edu/blog/2017/06/09/-bridging-the-system-configuration-gap-cross-post-https-aaronweiss-us-posts-2017-06-05-bridging-the-system-configuration-gap-html?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-06-09-bridging-the-system-configuration-gap-cross-post-https-aaronweiss-us-posts-2017-06-05-bridging-the-system-configuration-gap-html</guid>
   <pubDate>Fri, 09 Jun 2017 13:36:56 UT</pubDate>
   <author>PRL</author>
   <description></description></item>
  <item>
   <title>Report: PLISS 2017</title>
   <link>http://prl.ccs.neu.edu/blog/2017/06/05/report-pliss-2017?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-06-05-report-pliss-2017</guid>
   <pubDate>Mon, 05 Jun 2017 15:47:59 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;Two weeks ago, I attended the first &lt;a href="https://pliss2017.github.io/"&gt;Programming Language Implementation Summer School&lt;/a&gt;, held in beautiful Bertinoro, Italy.&lt;/p&gt;

&lt;p&gt;The goal of PLISS was &amp;ldquo;to prepare early graduate students and advanced undergraduates for research in the field,&amp;rdquo; and I think it successfully accomplished that. There were many talks in a variety of areas, such as just-in-time compilers, garbage collection, static analysis, and distributed systems. But PLISS was more than just a series of talks: PLISS provided an environment for interacting with other students as well as senior researchers.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="the-talks"&gt;The Talks&lt;/h2&gt;

&lt;p&gt;With the amount of technical content at PLISS, there was easily something for everyone. &lt;a href="http://janvitek.org/"&gt;Jan Vitek&lt;/a&gt; and &lt;a href="http://tratt.net/laurie/"&gt;Laurence Tratt&lt;/a&gt; gave lectures that included hands-on exercises where we worked on JITs. &lt;a href="https://www.cs.purdue.edu/homes/suresh/"&gt;Suresh Jagannathan&lt;/a&gt; dived into the operational semantics of a distributed system, so we could reason about different weak consistency models. Francesco Logozzo gave us a whirlwind tour of abstract interpretation.&lt;/p&gt;

&lt;p&gt;Most of my favorite talks included some form of extra content, such as exercises, live-coding presentations, or demos. I found it really helpful to write actual code and apply what I had just learned, or to look at some concrete examples. The examples and exercises also helped with the pacing, as actively listening to four 90-minute talks every day is exhausting!&lt;/p&gt;

&lt;p&gt;Off the top of my head, these were some of my favorite talks:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Dynamic Programming Language Implementation with LLVM&lt;/strong&gt;, by Petr Maj, Oli  Flückiger, and &lt;a href="http://janvitek.org/"&gt;Jan Vitek&lt;/a&gt;. As the first talk of the summer school, this  was a gentle introduction for the rest of the week. We had &lt;a href="https://github.com/PRL-PRG/pliss-rift/"&gt;exercises&lt;/a&gt;  (with intentional bugs to make us think!), and also brief overviews of  intermediate languages, static analysis, and garbage collection. These three  topics would later show up in more detail.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Micro Virtual Machines&lt;/strong&gt;, by &lt;a href="http://users.cecs.anu.edu.au/~steveb/"&gt;Steve Blackburn&lt;/a&gt;. This talk covered  background information on virtual machines, and also the &lt;a href="http://microvm.github.io/"&gt;Micro VM&lt;/a&gt;  project that Steve&amp;rsquo;s group has been working on. A lot of the material was  already familiar to me, but I still enjoyed the talk, and even got a few  ideas for the project I&amp;rsquo;m working on!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Static Analysis&lt;/strong&gt;, by &lt;a href="http://matt.might.net/"&gt;Matt Might&lt;/a&gt;. Matt&amp;rsquo;s talk was based on one of  his &lt;a href="http://matt.might.net/articles/intro-static-analysis/"&gt;articles&lt;/a&gt; and an older talk he&amp;rsquo;s given. Impressively, the entire  example was live-coded, with only a single mistake!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Testing Language Implementations&lt;/strong&gt;, by &lt;a href="http://multicore.doc.ic.ac.uk/"&gt;Alastair Donaldson&lt;/a&gt;. This was  an entertaining talk, since Ally showed multiple examples of crashing  compilers, and causing other kinds of mischief by triggering compiler bugs.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;If you&amp;rsquo;re disappointed that you couldn&amp;rsquo;t see these talks, don&amp;rsquo;t worry! The talks were recorded and will be posted very shortly.&lt;/p&gt;

&lt;h2 id="the-people"&gt;The People&lt;/h2&gt;

&lt;p&gt;But there&amp;rsquo;s more to PLISS than the talks. I&amp;rsquo;m referring to &lt;em&gt;networking&lt;/em&gt;, or the opportunity to get out and talk to other people about research.&lt;/p&gt;

&lt;p&gt;As an early graduate student, I&amp;rsquo;ve been given a lot of advice about talking to people at conferences and the importance of the &amp;ldquo;hallway track.&amp;rdquo; I still have difficulty doing this at an actual conference, like &lt;a href="http://pldi17.sigplan.org/home"&gt;PLDI&lt;/a&gt; or &lt;a href="http://2017.ecoop.org/"&gt;ECOOP&lt;/a&gt;. When there are hundreds of attendees, or when people already know each other and are in conversation groups, I find it difficult to approach them.&lt;/p&gt;

&lt;p&gt;This was not the case at PLISS. There were fewer attendees: about fifty students and a dozen speakers. There was a good mix of undergraduate, master&amp;rsquo;s, first-year PhD, and more senior PhD students. All our breakfasts, lunches, and breaks were together, so we would see the same people again and again, and inevitably start to learn each other&amp;rsquo;s names. The speakers would also be among us, and there was a good ratio of speakers to students for discussions and mealtime mentoring.&lt;/p&gt;

&lt;p&gt;I had many opportunities to practice my &amp;ldquo;research pitch.&amp;rdquo; I talked to senior students and got advice. I talked to junior students and gave advice. Two different people I talked to about my research pointed me to the same paper to read. I found another student who was working with &lt;a href="http://research.cs.wisc.edu/wpis/papers/popl95.pdf"&gt;IFDS&lt;/a&gt;, an algorithm I have spent much time trying to understand. And, one day at lunch, my table discovered that we were all working on static analysis!&lt;/p&gt;

&lt;p&gt;As much as I enjoyed the talks, I think the best part of PLISS was meeting and talking to other people. You can replace talks with videos (but you lose the speaker-audience interaction), and you can replace conversations with other forms of communication. But there isn&amp;rsquo;t really anything that can replace the serendipity of bumping into someone with a shared interest.&lt;/p&gt;

&lt;h2 id="the-location"&gt;The Location&lt;/h2&gt;

&lt;p&gt;Actually, the &lt;em&gt;other&lt;/em&gt; best part of PLISS was the location. Italy is a beautiful country with delicious food. And Bertinoro is a small town on the top of a hill, with a breathtaking view of the surrounding area. The lectures were held in a &lt;a href="https://pliss2017.github.io/images/pics/7.jpg"&gt;castle at the top of the hill&lt;/a&gt; (photo credit: Steve Blackburn). The speakers lived in the castle for the week, while the students lived in the former monastery (seems fitting), which has been renovated into a university residence.&lt;/p&gt;

&lt;p&gt;Here are my two favorite pictures I took (click for full size):&lt;/p&gt;

&lt;p&gt;&lt;a href="/img/pliss2017-1.jpg"&gt;&lt;img src="/img/pliss2017-1-thumb.jpg" alt="View from the castle" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="/img/pliss2017-2.jpg"&gt;&lt;img src="/img/pliss2017-2-thumb.jpg" alt="Panorama" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Steve Blackburn has more pictures posted on the &lt;a href="https://pliss2017.github.io/"&gt;PLISS website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="final-thoughts"&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;PLISS was a wonderful event. Many thanks need to be given to the speakers, organizers, and sponsors, for making this possible!&lt;/p&gt;

&lt;p&gt;If and when there is a second PLISS, I highly encourage students to apply! You will learn a lot from the lectures, from talking to the speakers, and meeting other students. And if it&amp;rsquo;s in Bertinoro again, you can enjoy the weather and nice view!&lt;/p&gt;</description></item>
  <item>
   <title>Syntactic parametricity strikes again</title>
   <link>http://prl.ccs.neu.edu/blog/2017/06/05/syntactic-parametricity-strikes-again?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-06-05-syntactic-parametricity-strikes-again</guid>
   <pubDate>Mon, 05 Jun 2017 14:27:44 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;In this blog post, reporting on a collaboration with &lt;a href="https://poisson.chat/"&gt;Li-Yao Xia&lt;/a&gt;, I will show an example of how some results that we traditionally think of as arising from free theorems / parametricity can be established in a purely &amp;ldquo;syntactic&amp;rdquo; way, by looking at the structure of canonical derivations. More precisely, I prove that 
 &lt;script type="math/tex"&gt;
\newcommand{\List}[1]{\mathsf{List}~#1}
\newcommand{\Fin}[1]{\mathsf{Fin}~#1}
\newcommand{\Nat}[1]{\mathbb{N}}
\newcommand{\rule}[2]{\frac{\displaystyle \array{#1}}{\displaystyle #2}}
\newcommand{\judge}[2]{{#1} \vdash {#2}}
\newcommand{\emptyrule}[1]{\begin{array}{c}\\[-1em] #1 \end{array}}
  ∀α. \List α → \List \alpha&lt;/script&gt; is isomorphic to 
 &lt;script type="math/tex"&gt;
    Π(n:\Nat{}). \List{(\Fin{n})}&lt;/script&gt; where 
 &lt;script type="math/tex"&gt;\Fin{n}&lt;/script&gt; is the type of integers smaller than 
 &lt;script type="math/tex"&gt;n&lt;/script&gt;, corresponding to the set 
 &lt;script type="math/tex"&gt;\{0, 1, \dots, n-1\}&lt;/script&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;Context: Last week I had the pleasure of visiting UPenn, where I had many interesting discussions with various people. It was also an occasion to temporarily resume a discussion/collaboration I have with Li-Yao Xia, who is currently an intern there, and Jean-Philippe Bernardy, about testing polymorphic programs and its relation to canonical representations for System F.&lt;/p&gt;

&lt;p&gt;During one of our blackboard discussion, Li-Yao and I did a manual proof of a cool result: we proved a parametricity theorem for 
 &lt;script type="math/tex"&gt;∀α. \List α → \List α&lt;/script&gt; using syntactic methods, namely proof search among canonical proofs. (This is an idea that I have been playing with since the last year of my &lt;a href="http://www.ccs.neu.edu/home/gasche/phd_thesis/"&gt;PhD thesis&lt;/a&gt;, where I unsuccessfully tried to extend my work on canonical forms for the simply-typed lambda-calculus to polymorphism. It is here worked out on an specific example, but my end goal is to turn the manual reasoning into an algorithm.)&lt;/p&gt;

&lt;p&gt;You may wonder, first, why the isomorphism holds. The idea is that a polymorphic function of type 
 &lt;script type="math/tex"&gt;\List α → \List α&lt;/script&gt; cannot inspect the elements of the input list; it can only use them in the resulting list, possibly duplicating, reordering or dropping some elements. On any input list of size 
 &lt;script type="math/tex"&gt;n&lt;/script&gt;, the behavior of the function can be described by a list of indices in 
 &lt;script type="math/tex"&gt;[0; n-1]&lt;/script&gt;. For example, if the input 
 &lt;script type="math/tex"&gt;[x, y, z]&lt;/script&gt; (for some values of 
 &lt;script type="math/tex"&gt;x, y, z&lt;/script&gt;) gives the output 
 &lt;script type="math/tex"&gt;[y, y, x]&lt;/script&gt;, then this relation will hold on &lt;em&gt;any&lt;/em&gt; value of 
 &lt;script type="math/tex"&gt;x, y, z&lt;/script&gt;, as the function cannot inspect their value or even test them for equality. The behavior of this function on lists of size 3 can be fully described by the list of indices 
 &lt;script type="math/tex"&gt;[1, 1, 0]&lt;/script&gt;. Its whole behavior is then uniquely determined by one such list for each possible size:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt;
    ∀α. \List α → \List α  \quad≃\quad  Π(n:\Nat{}). \List{(\Fin n)}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;The idea behind the &amp;ldquo;syntactic&amp;rdquo; (proof-theoretic?) proof method is the following: the set of closed values at a type 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; is isomorphic to the &lt;em&gt;search space&lt;/em&gt; for canonical/normal derivations of 
 &lt;script type="math/tex"&gt;\judge{}{A}&lt;/script&gt;. We have tools (in particular the notion of &lt;em&gt;invertible&lt;/em&gt; inference rules) to reason on those – in this post I will only present the reasoning informally, but it can easily be made formally precise.&lt;/p&gt;

&lt;p&gt;We start by looking at the shape of the search space for&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt;
    \judge{}{∀α. \List α → \List α}&lt;/script&gt; or, said otherwise, of the judgment 
 &lt;script type="math/tex; mode=display"&gt;
    \judge{}{\List α → \List α}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;with a fresh/abstract type variable 
 &lt;script type="math/tex"&gt;α&lt;/script&gt;. (I will not be keeping opened type variables in context to avoid confusing them with hypotheses.)&lt;/p&gt;

&lt;p&gt;Any derivation of a function type, without loss of generality (w.l.o.g), is equivalent to a derivation starting with a function introduction. This is the η-expansion rule for functions: any proof term 
 &lt;script type="math/tex"&gt;e&lt;/script&gt; is equivalent to 
 &lt;script type="math/tex"&gt;λx.~(e~x)&lt;/script&gt;, a proof that starts with a 
 &lt;script type="math/tex"&gt;λ&lt;/script&gt;. So any proof can be taken to start as follows: 
 &lt;script type="math/tex; mode=display"&gt;
\rule{
\judge{\List \alpha}{\List \alpha}
}{
\judge{}{\List \alpha \to \List \alpha}
}&lt;/script&gt; we can, w.l.o.g, unfold the recursive type in the context (\(\List α = 1 + (α × \List α)\)): 
 &lt;script type="math/tex; mode=display"&gt;
\rule{
\judge{1 + (α × \List α)}{\List α}
}{
\rule{
\judge{\List α}{\List α}
}{
\judge{}{\List α → \List α}
}}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;A derivation with a sum type as hypothesis can, w.l.o.g, be assumed to start by splitting on this pair (this is the η-expansion rule for sums): 
 &lt;script type="math/tex; mode=display"&gt;
\rule{
\judge{1}{\List α}
\quad
\judge{α × \List α}{\List α}
}{
\rule{
\judge{1 + (α × \List α)}{\List α}
}{
\rule{
\judge{\List α}{\List α}
}{
\judge{}{\List α → \List α}
}}}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;In the right subgoal, we can always, w.l.o.g, split a hypothesis of product type: 
 &lt;script type="math/tex; mode=display"&gt;
\rule{
\emptyrule{\judge{1}{\List α}}
\quad
\rule{
\judge{α, \List α}{\List α}
}{
\judge{α × \List α}{\List α}
}}{
\rule{
\judge{1 + (α × \List α)}{\List α}
}{
\rule{
\judge{\List α}{\List α}
}{
\judge{}{\List α → \List α}
}}}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Now, an interesting pattern emerges. In the process of trying to prove 
 &lt;script type="math/tex"&gt;\judge{\List α}{\List α}&lt;/script&gt;, we have to prove the (right) subgoal 
 &lt;script type="math/tex"&gt;\judge{α,\List α}{α}&lt;/script&gt;. We can generalize this derivation by assuming that we start with some number 
 &lt;script type="math/tex"&gt;n&lt;/script&gt; of variables of type 
 &lt;script type="math/tex"&gt;α&lt;/script&gt; in the context (we write 
 &lt;script type="math/tex"&gt;α^n&lt;/script&gt; for this): 
 &lt;script type="math/tex; mode=display"&gt;
\rule{
\rule{
\judge{\alpha^n}{\List \alpha}
}{
\judge{\alpha^n, 1}{\List \alpha}
}
\quad
\rule{
\judge{\alpha^{n+1}, \List \alpha}{\List \alpha}
}{
\judge{\alpha^n, \alpha \times \List \alpha}{\List \alpha}
}}{
\rule{
\judge{\alpha^n, 1 + (\alpha \times \List \alpha)}{\List \alpha}
}{
\judge{\alpha^n, \List \alpha}{\List \alpha}
}}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt;
\newcommand{\llbracket}{〚}
\newcommand{\rrbracket}{〛}
\newcommand{\sem}[1]{\llbracket{} #1 \rrbracket{}}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Let us write 
 &lt;script type="math/tex"&gt;\sem{\judge{\alpha^n, \List \alpha}{\List \alpha}}&lt;/script&gt; for the search space corresponding to all possible derivations of the judgment 
 &lt;script type="math/tex"&gt;\judge{\alpha^n, \List \alpha}{\List \alpha}&lt;/script&gt;. All the proof steps above have been done &amp;ldquo;without loss of generality&amp;rdquo; (in terms of focusing, we only used invertible rules), so they appear in any such derivation. Similarly, let us write 
 &lt;script type="math/tex"&gt;\sem{\judge{\alpha^n}{\List \alpha}}&lt;/script&gt; for the space of all possible derivations of 
 &lt;script type="math/tex"&gt;\judge{\alpha^n}{\List \alpha}&lt;/script&gt;, then above we have proven that 
 &lt;script type="math/tex; mode=display"&gt;
\sem{\judge{\alpha^n, \List \alpha}{\List \alpha}}
\quad=\quad
\sem{\judge{\alpha^n}{\List \alpha}}
\times
\sem{\judge{\alpha^{n+1}, \List \alpha}{\List \alpha}}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;This equality can be unfolded at will 
 &lt;script type="math/tex; mode=display"&gt;
\begin{align}
&amp; \sem{\judge{\alpha^n, \List \alpha}{\List \alpha}} \\
= &amp; \sem{\judge{\alpha^n}{\List \alpha}}
    \times
    \sem{\judge{\alpha^{n+1}, \List \alpha}{\List \alpha}} \\
= &amp; \sem{\judge{\alpha^n}{\List \alpha}}
    \times
    \sem{\judge{\alpha^{n+1}}{\List \alpha}}
    \times
    \sem{\judge{\alpha^{n+2}, \List \alpha}{\List \alpha}} \\
= &amp; \sem{\judge{\alpha^n}{\List \alpha}}
    \times
    \sem{\judge{\alpha^{n+1}}{\List \alpha}}
    \times
    \sem{\judge{\alpha^{n+2}}{\List \alpha}}
    \times
    \sem{\judge{\alpha^{n+3}, \List \alpha}{\List \alpha}} \\
= &amp; \dots \\
\end{align}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;or written as an infinite product 
 &lt;script type="math/tex; mode=display"&gt;
    \sem{\judge{\alpha^n, \List \alpha}{\List \alpha}}
    \quad=\quad
    \prod_{k \in \Nat{}}{\sem{\judge{\alpha^{n+k}}{\List \alpha}}}&lt;/script&gt; and, in particular, 
 &lt;script type="math/tex; mode=display"&gt;
\begin{align}
&amp; \sem{\judge{}{\List \alpha \to \List \alpha}} \\
= &amp; \sem{\judge{\alpha^0, \List \alpha}{\List \alpha}} \\
= &amp; \prod_{n \in \Nat{}}{\sem{\judge{\alpha^n}{\List \alpha}}} \\
\end{align}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s look at the structure of the derivations of 
 &lt;script type="math/tex"&gt;\judge{\alpha^n}{\List \alpha}&lt;/script&gt;. A proof of this judgment cannot start with a &amp;ldquo;left rule&amp;rdquo;, inspecting the value of one of the 
 &lt;script type="math/tex"&gt;n&lt;/script&gt; variables of type 
 &lt;script type="math/tex"&gt;α&lt;/script&gt;, given that the structure of 
 &lt;script type="math/tex"&gt;α&lt;/script&gt; is unknown/abstract. It must start by choosing to either build the empty list or a cons cell. We write this as follows (after unfolding the type):&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt;
\rule{
\rule{
\judge{\alpha^n}{1}
\quad\oplus\quad
\judge{\alpha^n}{\alpha \times \List \alpha}
}{
\judge{\alpha^n}{1 + (\alpha \times \List \alpha)}
}}{
\judge{\alpha^n}{\List \alpha}
}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;The 
 &lt;script type="math/tex"&gt;\oplus&lt;/script&gt; notation between two judgments is non-standard; it means that they are not two requirements of the same proof, but two alternatives for possible proofs. All valid proofs fit that structure, and they either have a 
 &lt;script type="math/tex"&gt;\judge{\alpha^n}{1}&lt;/script&gt; premise or a 
 &lt;script type="math/tex"&gt;\judge{\alpha^n}{\alpha \times \List \alpha}&lt;/script&gt; premise. With this syntax, we are describing a set of possible derivations, rather than a single (partial) derivation.&lt;/p&gt;

&lt;p&gt;Proofs of 
 &lt;script type="math/tex"&gt;\judge{\Gamma}{1}&lt;/script&gt; are trivial, and a proof of a product is always, w.l.o.g, a product of proofs (in intuitionistic logic / the λ-calculus they reuse the same context), so we can decompose further: 
 &lt;script type="math/tex; mode=display"&gt;
\rule{
\rule{
\rule{
}{
\judge{\alpha^n}{1}
}
\quad\oplus\quad
\rule
{
\judge{\alpha^n}{\alpha}
\quad
\judge{\alpha^n}{\List \alpha}
}{
\judge{\alpha^n}{\alpha \times \List \alpha}
}
}{
\judge{\alpha^n}{1 + (\alpha \times \List \alpha)}
}}{
\judge{\alpha^n}{\List \alpha}
}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;There is exactly one possible proof of 
 &lt;script type="math/tex"&gt;\judge{\alpha^n}{1}&lt;/script&gt;, so its search space is 
 &lt;script type="math/tex"&gt;1&lt;/script&gt;, the unit set (with a single element). There are exactly 
 &lt;script type="math/tex"&gt;n&lt;/script&gt; possible proofs of 
 &lt;script type="math/tex"&gt;\judge{\alpha^n}{\alpha}&lt;/script&gt;, so the search space is just 
 &lt;script type="math/tex"&gt;n&lt;/script&gt;, seen as a set, or, in type-theoretic notation, 
 &lt;script type="math/tex"&gt;\Fin{n}&lt;/script&gt;. We thus have the recursive equation: 
 &lt;script type="math/tex; mode=display"&gt;
\sem{\judge{\alpha^n}{\List \alpha}}
\quad=\quad
1 + (\Fin n \times \sem{\judge{\alpha^n}{\List \alpha}})&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;This type is either 
 &lt;script type="math/tex"&gt;1&lt;/script&gt;, or a 
 &lt;script type="math/tex"&gt;\Fin{n}&lt;/script&gt; and itself, recursively. This is exactly a list: 
 &lt;script type="math/tex; mode=display"&gt;
\sem{\judge{\alpha^n}{\List \alpha}}
\quad=\quad
\List{(\Fin{n})}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;so, plugging everything together: 
 &lt;script type="math/tex; mode=display"&gt;
\begin{align}
&amp; \sem{\forall \alpha. \List \alpha \to \List \alpha} \\
= &amp; \prod_{n \in \Nat{}}{\sem{\judge{\alpha^n}{\List \alpha}}} \\
= &amp; \prod_{n \in \Nat{}}{\List{(\Fin{n})}} \\
\end{align}&lt;/script&gt;&lt;/p&gt;

&lt;h3 id="post-scriptum"&gt;Post Scriptum&lt;/h3&gt;

&lt;p&gt;Some of reasoning steps above can be formulated in a way that is less clear but more familiar, as a sequence of type isomorphisms. For example, the first part on 
 &lt;script type="math/tex"&gt;\sem{\judge{\alpha^n, \List
\alpha}{\List \alpha}}&lt;/script&gt; can written as:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt;
\begin{align}
&amp;
∀α. αⁿ × \List α → \List α
\\ &amp;
= \text{(unfold List)}
\\ &amp;
    ∀α. αⁿ × (1 + α × \List α) → \List α
\\ &amp;
    = \text{(distribute × over +)}
\\ &amp;
    ∀α. ((αⁿ × 1) + (αⁿ⁺¹ × \List α)) → \List α
\\ &amp;
    = \text{(A × 1 ≃ A)}
\\ &amp;
    ∀α. (αⁿ + (αⁿ⁺¹ × \List α)) → \List α
\\ &amp;
    = \text{(A+B) → C ≃ (A→C)×(B→C)}
\\ &amp;
    ∀α. (αⁿ → \List α) × (αⁿ⁺¹ × \List α → \List α)
\\ &amp;
    = \text{(distribute ∀α below product)}
\\ &amp;
    (∀α. αⁿ → \List α) × (∀α. αⁿ⁺¹ × \List α → \List α)
\\
\end{align}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Reading this equational sequence, it may look like we had to make the right choice at each step; but the proof-search perspective reveals that there were in fact no choices, as each time we apply invertible rules (&amp;ldquo;w.l.o.g. rules&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Furthermore, some parts cannot be derived in this style; in the latter part of the proof, the isomorphism between 
 &lt;script type="math/tex"&gt;∀\alpha. \alpha^n → \alpha&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;\Fin{n}&lt;/script&gt;, which is immediate from a proof search perspective, cannot be justified in this way. (In particular, 
 &lt;script type="math/tex"&gt;A×B → C&lt;/script&gt; is &lt;em&gt;not&lt;/em&gt; isomorphic to 
 &lt;script type="math/tex"&gt;(A→C)+(B→C)&lt;/script&gt;.)&lt;/p&gt;

&lt;h3 id="going-further"&gt;Going further&lt;/h3&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;It is an unfortunately-little-known obvious fact that many things we  associate to &amp;ldquo;free theorems&amp;rdquo; can be recovered by proof search. For  example, it is much simpler to prove that the only inhabitant of  
   &lt;script type="math/tex"&gt;\forall \alpha. \alpha \to \alpha&lt;/script&gt; is the identity using proof  search than parametricity. I briefly discussed the idea in the  section 1.3 of my 2015 article, &lt;a href="http://gallium.inria.fr/~scherer/research/unique_inhabitants/unique_stlc_sums-long.pdf"&gt;Which simple types have a unique  inhabitant?&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If you are unfamiliar with proof search (or the LF community) and  curious about what I mean by &amp;ldquo;canonical forms&amp;rdquo; and why I think this  is an important idea, see my non-technical 2017 article &lt;a href="http://www.ccs.neu.edu/home/gasche/research/canonical-forms/snapl.pdf"&gt;Search for  Program  Structure&lt;/a&gt;. The  problem of extending the notion of canonical forms to arbitrary  polymorphic types is briefly discussed in the section 14.5 of my  2016 &lt;a href="http://www.ccs.neu.edu/home/gasche/phd_thesis/scherer-thesis.pdf"&gt;phd  manuscript&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If you haven&amp;rsquo;t heard of it yet, you would probably be interested in  the 2010 article &lt;a href="http://publications.lib.chalmers.se/records/fulltext/local_99387.pdf"&gt;Testing Polymorphic  Properties&lt;/a&gt;  by Jean-Philippe Bernardy, Patrik Jansson and Koen Claessen. Li-Yao  has a 2016 implementation called  &lt;a href="https://github.com/Lysxia/metamorph"&gt;Metamorph&lt;/a&gt; that got us talking  together. The problems of understanding canonical forms and testing  are quite related, but yet not exactly the same&amp;hellip;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="you-might-also-like"&gt;You might also like&lt;/h3&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2017/05/01/categorical-semantics-for-dynamically-typed-programming-languages/"&gt;Categorical Semantics for Dynamically Typed Programming  Languages&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="https://williamjbowman.com/blog/2017/01/03/toward-type-preserving-compilation-of-coq-at-popl17-src/"&gt;Toward Type-Preserving Compilation of Coq, at POPL17 SRC&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2016/11/16/understanding-constructive-galois-connections/"&gt;Understanding Constructive Galois  Connections&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Racket 6.9 and Windows 10 Creators Update</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/26/racket-6-9-and-windows-10-creators-update?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-26-racket-6-9-and-windows-10-creators-update</guid>
   <pubDate>Fri, 26 May 2017 17:00:28 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;&lt;a href="http://racket-lang.org/"&gt;Racket&lt;/a&gt; 6.9 was released in April and it has been smooth sailing for many people. However, some people using the &lt;a href="https://blogs.windows.com/windowsexperience/2017/04/11/whats-new-in-the-windows-10-creators-update/"&gt;Windows 10 Creators Update&lt;/a&gt; have been experiencing &lt;a href="https://github.com/racket/racket/issues/1671"&gt;crashes&lt;/a&gt;, not just for Racket, but for the whole operating system. This is due to a bug in Windows. We have contacted Microsoft; they have classified the bug as (1) a stack overflow and (2) not a security hazard, and intend to add a fix in a future version of Windows.&lt;/p&gt;

&lt;p&gt;The next version of Racket will include a patch to help avoid triggering the bug. Until then, one work-around is to run Racket in a virtual machine (VM). This blog post is a step-by-step guide on how to install a VM for Racket.&lt;/p&gt;

&lt;p&gt;A VirtualBox image with Racket preinstalled can be downloaded here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/website/releases/download/racket69vm/Racket_6_9.ova"&gt;https://github.com/nuprl/website/releases/download/racket69vm/Racket_6_9.ova&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The username and password for this machine are both &lt;code&gt;racket&lt;/code&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;The first thing you need to install is virtualization software. In principle it doesn&amp;rsquo;t matter what you install, but for this tutorial, we will use &lt;a href="https://www.virtualbox.org/"&gt;VirtualBox&lt;/a&gt;. Go to their &lt;a href="https://www.virtualbox.org/wiki/Downloads"&gt;downloads&lt;/a&gt; page and download and install the version for your platform (most likely Windows).&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Once installed, you need to download a virtual image and install Racket on it. We have prepared an image that comes with Racket pre-installed, which &lt;a href="https://github.com/nuprl/website/releases/download/racket69vm/Racket_6_9.ova"&gt;you can download here&lt;/a&gt;. The rest of this tutorial will assume you are using this image.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Start up VirtualBox and import the virtual machine. You can do this by clicking on &lt;code&gt;File -&amp;gt; Import Appliance&lt;/code&gt;. In the dialog, select the image you downloaded and hit &lt;code&gt;Continue&lt;/code&gt;. The next window lets you change the specs for your virtual machine. Feel free to make any changes you want, but the defaults work fine for this image. Once you are satisfied click &lt;code&gt;Import&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;After import finishes, you should now see your new VM in the list on the left of the VirtualBox manager. Select it and hit &lt;code&gt;Start&lt;/code&gt;. Once started up, you will see DrRacket and Firefox on the VM&amp;rsquo;s desktop.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</description></item>
  <item>
   <title>Programming Language Conference in Russia</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/24/programming-language-conference-in-russia?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-24-programming-language-conference-in-russia</guid>
   <pubDate>Wed, 24 May 2017 12:25:17 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;In April 3&amp;mdash;5 I took part into a Russian conference exclusively devoted to programming languages: &lt;a href="http://plc.sfedu.ru/"&gt;Programming Languages and Compilers&lt;/a&gt; (&lt;a href="https://translate.google.com/translate?sl=auto&amp;amp;tl=en&amp;amp;js=y&amp;amp;prev=_t&amp;amp;hl=en&amp;amp;ie=UTF-8&amp;amp;u=http%3A%2F%2Fplc.sfedu.ru%2F&amp;amp;edit-text=&amp;amp;act=url"&gt;Google.Translated version of the site&lt;/a&gt;). I was a member of organizing committee and had a paper there.&lt;/p&gt;

&lt;p&gt;This is the first conference in Russia highly focused on our area of PL. At least for the last several decades (I believe, there were conferences of the kind back in USSR). The conference was devoted to the memory of prominent Soviet PL-researcher from Rostov-on-Don, Adolf Fuksman who worked on ideas quite similar to what we know as the aspect-oriented programming back in the 70-s.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;We designed and implemented the conference with my colleagues from I.I.Vorovich institute of Mathematics, Mechanics and Computer Science, Southern Federal University (&lt;a href="https://www.google.com/maps/place/Rostov-on-Don,+Rostov+Oblast,+Russia/@49.8345629,18.9321123,4.5z/data=!4m5!3m4!1s0x40e3c777c3b4b6ef:0x8248b451e48b4d04!8m2!3d47.2357137!4d39.701505"&gt;Rostov-on-Don&lt;/a&gt;, Russia). We aimed at gathering as much PL-researchers and enthusiasts from academia in Russia as we could. One of the consequences of the aim was a decision to run the conference in Russian. Though we missed expertise from our non-Russian speaking colleagues, we got thorough participation from all over Russia:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Saint-Petersburg, Moscow, Novosibirsk, Krasnoyarsk, Ekaterinburg, Kazan, etc.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I only mention here the cities with more than 1 mil. population in decreasing in number of conference participants order (and excluding Rostov itself, of course).&lt;/p&gt;

&lt;p&gt;I particularly liked talks by invited speakers. When searching for ones, we targeted Russians who work at prominent universities and/or have some visibility at the international level. We ended up with two researchers: &lt;a href="http://ilyasergey.net/"&gt;Ilya Sergey&lt;/a&gt; (University College of London) and &lt;a href="http://www.macs.hw.ac.uk/~ek19/"&gt;Ekaterina Komendantskaya&lt;/a&gt; (Heriot-Watt U., Edinburg, UK). Interestingly, their talks were quite close to each other:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;I. Sergey, Dependent Types for verification of real-world programs,&lt;/li&gt;
 &lt;li&gt;E. Komendantskaya, Automated Theorem Proving for Type Inference, Constructively.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Both of them talked about types as a logic tool to ensure program correctness.&lt;/p&gt;

&lt;p&gt;Biggest opening in this conference for me was a team from Languages Tools Laboratory of &lt;a href="https://en.wikipedia.org/wiki/JetBrains"&gt;JetBrains&lt;/a&gt;. Surely, you heard about JB: either about their famous IDE, IntelliJ IDEA, or the Kotlin programming language (which, by the way, &lt;a href="https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/"&gt;is endorsed&lt;/a&gt; for Android development these days). You may also have noticed that JB become sponsors of ECOOP and OPLSS this year. So we had a whole team of researchers from Saint-Petersburg office of JB. Among their topics: &lt;code&gt;OCaml&lt;/code&gt; embedding of &lt;code&gt;miniKanren&lt;/code&gt; (some results was presented on ML Workshop 2016), parser combinator libraries for &lt;code&gt;OCaml&lt;/code&gt; and constrained graph querying (this is not specifically a PL problem, see &lt;a href="https://arxiv.org/abs/1502.02242"&gt;arXiv:1502.02242&lt;/a&gt; for details).&lt;/p&gt;

&lt;p&gt;Otherwise the spectrum of topics presented on the conference was quite broad, here are some:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Static analysis with PVS-studio (a sponsor talk),&lt;/li&gt;
 &lt;li&gt;supercompilation (a talk by researchers from Pereslavl-Zalesskiy, where the topic is actively developed for decades),&lt;/li&gt;
 &lt;li&gt;C++ and beyond (by a member of the ISO C++ committee),&lt;/li&gt;
 &lt;li&gt;architecture-agnostic parallel programming languages and compilation techniques for parallel architectures,&lt;/li&gt;
 &lt;li&gt;game semantics and ontologies for PL semantics,&lt;/li&gt;
 &lt;li&gt;program analysis,&lt;/li&gt;
 &lt;li&gt;compiler architectures.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Full program with links to slides in Russian is available &lt;a href="https://docs.google.com/spreadsheets/d/11QiFUqJG_NiBHVUfji_6-FiqP3aQWmdDBN13abM32nY/edit?usp=sharing"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me mention my submission: that was a joint work with a student of mine on exploring design space for parser combinator libraries using programming language with direct support of effect system, namely &lt;a href="http://popl17.sigplan.org/event/popl-2017-papers-do-be-do-be-do"&gt;Frank&lt;/a&gt;. &lt;a href="http://staff.mmcs.sfedu.ru/%7Ejuliet/index.en.html"&gt;Julia Belyakova&lt;/a&gt; also participated in the conference with her work on Coq-certified interpreter for an extension of lambda-calculus with concept-parameters (module-like kind of thing). The follow-up of that work is accepted for FTfJP workshop this year. You can also listen to her on the topic at the &lt;a href="http://www.nepls.org/Events/30/"&gt;NEPLS&lt;/a&gt; next week.&lt;/p&gt;

&lt;p&gt;I hope that we will find sources, time, and, most important, high quality submissions for PLC&amp;ndash;2018.&lt;/p&gt;</description></item>
  <item>
   <title>Building a Website with Scribble</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/23/building-a-website-with-scribble?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-23-building-a-website-with-scribble</guid>
   <pubDate>Tue, 23 May 2017 01:53:13 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;The source code for the PRL website is written using Scribble, the Racket  documentation tool. I am very happy with this choice, and you should be too!&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="the-story-so-far"&gt;The Story so Far&lt;/h2&gt;

&lt;p&gt;Last Fall, I took a flight to Chicago (on my way to &lt;a href="http://con.racket-lang.org/2016/"&gt;RacketCon 2016&lt;/a&gt;). When I landed, there was a new message in my inbox:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Subject: Web Page
    Date: 2016-09-15

    You have been nominated webmaster by public acclamation. Congratulations!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Emboldened by the trust of my people, I promptly converted the PRL website  from Racket-generating-HTML to the fine &lt;a href="http://docs.racket-lang.org/scribble-pp/html.html"&gt;&lt;code&gt;scribble/html&lt;/code&gt;&lt;/a&gt;  preprocessor language (commit &lt;a href="https://github.com/nuprl/website/commit/a0600d32fec4bd70c5530b2717aec32979d634f7"&gt;&lt;code&gt;a0600d&lt;/code&gt;&lt;/a&gt;) This bold action polarized the community.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;I can&amp;rsquo;t read the source anymore! Is this really an improvement?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fear not, citizens. The switch to &lt;a href="http://docs.racket-lang.org/scribble-pp/html.html"&gt;&lt;code&gt;scribble/html&lt;/code&gt;&lt;/a&gt; was the right choice, and you  too can learn to read the source code.&lt;/p&gt;

&lt;h2 id="how-to-read-scribblehtml-programs"&gt;How to Read &lt;code&gt;scribble/html&lt;/code&gt; Programs&lt;/h2&gt;

&lt;h3 id="basics"&gt;Basics&lt;/h3&gt;

&lt;p&gt;Scribble is a language for writing Racket documentation. The key innovation in Scribble is the &lt;em&gt;@-expression&lt;/em&gt; (read: &amp;ldquo;at expression&amp;rdquo;). The &lt;a href="http://docs.racket-lang.org/scribble-pp/html.html"&gt;&lt;code&gt;scribble/html&lt;/code&gt;&lt;/a&gt; language combines @-expression syntax with  functions that generate HTML.&lt;/p&gt;

&lt;h4 id="-syntax"&gt;@-syntax&lt;/h4&gt;

&lt;p&gt;&lt;a href="http://www.greghendershott.com/2015/08/at-expressions.html"&gt;Greg Hendershott&lt;/a&gt; and the &lt;a href="http://docs.racket-lang.org/scribble/reader.html"&gt;Scribble Documentation&lt;/a&gt; explain @-expressions properly. Here&amp;rsquo;s a short tutorial (Part 1 of 2, &amp;ldquo;the basics&amp;rdquo;):&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Scribble programs start in &amp;ldquo;text mode&amp;rdquo;.  Every character you type goes straight to the document you are building.&lt;/li&gt;
 &lt;li&gt;The @-sign toggles to &amp;ldquo;Racket mode&amp;rdquo; for the next expression.  In Racket mode, the characters you type will be evaluated as a Racket program  to produce part of the document.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Examples:&lt;/em&gt; Evaluating &lt;code&gt;"Hello Dave"&lt;/code&gt; puts &amp;ldquo;Hello Dave&amp;rdquo; in your document. Evaluating &lt;code&gt;"Hello @Dave"&lt;/code&gt; puts &amp;ldquo;Hello ???&amp;rdquo; in your document, where "???" is the value of the variable &lt;code&gt;Dave&lt;/code&gt;. Finally if &lt;code&gt;Dave&lt;/code&gt; is the name of a function, then &lt;code&gt;"Hello @(Dave)"&lt;/code&gt; calls the &lt;code&gt;Dave&lt;/code&gt; function with zero arguments and puts whatever it returns into your document.&lt;/p&gt;

&lt;p&gt;To make it easy to interleave text, function calls, and code, Scribble  discriminates between 4 kinds of parentheses when they follow an @-sign (Part 2 of 2, &amp;ldquo;the parens&amp;rdquo;):&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;code&gt;@(f A B)&lt;/code&gt; is just like the function call &lt;code&gt;(f A B)&lt;/code&gt; in Racket&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;@f[A B]&lt;/code&gt; is the same as &lt;code&gt;@(f A B)&lt;/code&gt;, but typically more useful because &amp;hellip;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;@f[A B]{....}&lt;/code&gt; evaluates the &lt;code&gt;....&lt;/code&gt; in &amp;ldquo;text mode&amp;rdquo; to a list of words &lt;code&gt;w*&lt;/code&gt;,  then calls &lt;code&gt;f&lt;/code&gt; just like &lt;code&gt;(apply f A B w*)&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;@f{....}&lt;/code&gt; evaluates the &lt;code&gt;....&lt;/code&gt; in &amp;ldquo;text mode&amp;rdquo; and calls &lt;code&gt;f&lt;/code&gt; with the results&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;@f|{....}|&lt;/code&gt; is similar, but the &lt;code&gt;....&lt;/code&gt; are in &amp;ldquo;unescapable text mode&amp;rdquo;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;Unescapable text mode&amp;rdquo; treats @-signs as text instead of toggling between modes.&lt;/p&gt;

&lt;h4 id="generating-html"&gt;Generating HTML&lt;/h4&gt;

&lt;p&gt;The &lt;a href="http://docs.racket-lang.org/scribble-pp/html.html"&gt;&lt;code&gt;scribble/html&lt;/code&gt;&lt;/a&gt; language comes with functions that render HTML. These functions have the same name as the corresponding HTML tag.&lt;/p&gt;

&lt;p&gt;Example program:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="kn"&gt;#lang scribble/html&lt;/span&gt;
&lt;span class="nv"&gt;@p&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nf"&gt;Hello&lt;/span&gt; &lt;span class="nv"&gt;World&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Running this program prints:&lt;/p&gt;

&lt;div class="brush: html"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hello World&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;No surprises.&lt;/p&gt;

&lt;p&gt;One thing that &lt;em&gt;is&lt;/em&gt; surprising is how &lt;code&gt;scribble/html&lt;/code&gt; handles tag attributes. Every tag-rendering function accepts &amp;ldquo;Racket mode&amp;rdquo; arguments that specify  an attribute name and attribute value.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="kn"&gt;#lang scribble/html&lt;/span&gt;
&lt;span class="nv"&gt;@p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;style:&lt;/span&gt; &lt;span class="s"&gt;"color:red"&lt;/span&gt;&lt;span class="p"&gt;]{&lt;/span&gt;&lt;span class="nf"&gt;Hello&lt;/span&gt; &lt;span class="nv"&gt;World&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Prints:&lt;/p&gt;

&lt;div class="brush: html"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt; &lt;span class="na"&gt;style=&lt;/span&gt;&lt;span class="s"&gt;"color:red"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Hello World&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Hope the output looks familiar. The input syntax is strange, but that&amp;rsquo;s what it is.&lt;/p&gt;

&lt;p&gt;Larger programs print larger webpages. Each page on the PRL website is HTML generated by one &lt;code&gt;scribble/html&lt;/code&gt; program.&lt;/p&gt;

&lt;h2 id="why-scribblehtml-is-an-improvement"&gt;Why &lt;code&gt;scribble/html&lt;/code&gt; is an Improvement&lt;/h2&gt;

&lt;p&gt;Before &lt;code&gt;scribble/html&lt;/code&gt;, the PRL website was implemented in &lt;code&gt;scribble/text&lt;/code&gt;. A &lt;code&gt;scribble/text&lt;/code&gt; program renders and prints text. There is no extra support for HTML.&lt;/p&gt;

&lt;p&gt;To compare, here&amp;rsquo;s the start of the old homepage:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="kn"&gt;#lang scribble/text&lt;/span&gt;
&lt;span class="nv"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._require))" style="color: inherit"&gt;require&lt;/a&gt; &lt;/span&gt;&lt;span class="s"&gt;"templates.rkt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;&amp;lt;!DOCTYPE&lt;/span&gt; &lt;span class="nv"&gt;html&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;&amp;lt;html&lt;/span&gt; &lt;span class="nv"&gt;lang=&lt;/span&gt;&lt;span class="s"&gt;"en"&lt;/span&gt;&lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3e))" style="color: inherit"&gt;&amp;gt;&lt;/a&gt;&lt;/span&gt;
  &lt;span class="nv"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;header&lt;/span&gt; &lt;span class="s"&gt;"Home"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;&amp;lt;body&lt;/span&gt; &lt;span class="nv"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;"pn-top"&lt;/span&gt;&lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3e))" style="color: inherit"&gt;&amp;gt;&lt;/a&gt;&lt;/span&gt;
    &lt;span class="nv"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;navbar&lt;/span&gt; &lt;span class="s"&gt;"Home"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="nv"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"jumbotron"&lt;/span&gt;&lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3e))" style="color: inherit"&gt;&amp;gt;&lt;/a&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;And here is the start of the &lt;code&gt;scribble/html&lt;/code&gt;&amp;rsquo;d homepage:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="kn"&gt;#lang scribble/html&lt;/span&gt;
&lt;span class="nv"&gt;@require&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"templates.rkt"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="nv"&gt;@doctype&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nf"&gt;html&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;@html&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;lang:&lt;/span&gt; &lt;span class="s"&gt;"en"&lt;/span&gt;&lt;span class="p"&gt;]{&lt;/span&gt;
  &lt;span class="nv"&gt;@header&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nf"&gt;Home&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nv"&gt;@body&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;id:&lt;/span&gt; &lt;span class="s"&gt;"pn-top"&lt;/span&gt;&lt;span class="p"&gt;]{&lt;/span&gt;
      &lt;span class="nv"&gt;@navbar&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nf"&gt;Home&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="nv"&gt;@div&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;class:&lt;/span&gt; &lt;span class="s"&gt;"jumbotron"&lt;/span&gt;&lt;span class="p"&gt;]{&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The pages look similar. The new one has more @-signs and parentheses, the old one has more &lt;code&gt;&amp;lt;&lt;/code&gt;-signs  and quotes. If you were able to edit the old page, you should be able to edit the new page.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;key improvement&lt;/strong&gt; in the new page is that &lt;strong&gt;common mistakes are now  compile-time errors&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Before, a typo like &lt;code&gt;&amp;lt;hmtl&amp;gt;&lt;/code&gt; would generate an ugly webpage.  After, a typo like &lt;code&gt;@hmtl&lt;/code&gt; is a syntax error.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Before, a typo like &lt;code&gt;&amp;lt;b&amp;gt;....&lt;/code&gt; with no closing tag would generate an ugly webpage.  After, a typo like &lt;code&gt;@b{....&lt;/code&gt; is a syntax error.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Both flavors of error message come with source-code line numbers. This is very very helpful.&lt;/p&gt;

&lt;h3 id="small-improvements"&gt;Small Improvements&lt;/h3&gt;

&lt;h4 id="1-more-functions"&gt;1. More Functions&lt;/h4&gt;

&lt;p&gt;Before, the &lt;a href="http://prl.ccs.neu.edu/teaching.html"&gt;Teaching page&lt;/a&gt; contained  some interesting HTML for rendering vertical text (look for the word &amp;ldquo;Semantics&amp;rdquo; to see how this was used):&lt;/p&gt;

&lt;div class="brush: html"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;span&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"how-to-design-programs"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;S&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;e&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;m&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;a&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;n&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;t&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;i&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;c&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;s&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;After, the same text is generated from a function call:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nv"&gt;@span&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;class:&lt;/span&gt; &lt;span class="s"&gt;"how-to-design-programs"&lt;/span&gt;&lt;span class="p"&gt;]{&lt;/span&gt;&lt;span class="nf"&gt;@vertical-text&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nf"&gt;Semantics&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;vertical-text&lt;/code&gt; function is simple:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nv"&gt;@require&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._only-in))" style="color: inherit"&gt;only-in&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;racket/list&lt;/span&gt; &lt;span class="nv"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._add-between))" style="color: inherit"&gt;add-between&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;

&lt;span class="nv"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;vertical-text&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;str*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._add-between))" style="color: inherit"&gt;add-between&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/strings.html#(def._((quote._~23~25kernel)._string-~3elist))" style="color: inherit"&gt;string-&amp;gt;list&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._append*))" style="color: inherit"&gt;append*&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;str*&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;br&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;h4 id="2-more-structure-less-boilerplate"&gt;2. More Structure, Less Boilerplate&lt;/h4&gt;

&lt;p&gt;Here&amp;rsquo;s part of the old definition of &amp;ldquo;Ben Greenman&amp;rdquo; on the &lt;a href="http://prl.ccs.neu.edu/people.html"&gt;People page&lt;/a&gt;:&lt;/p&gt;

&lt;div class="brush: html"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"row pn-person"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-12 pn-row-eq-height"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-3 pn-photo"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"img-wrapper"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;img&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;"img/ben_greenman.jpg"&lt;/span&gt; &lt;span class="na"&gt;title=&lt;/span&gt;&lt;span class="s"&gt;"Ben Greenman"&lt;/span&gt; &lt;span class="na"&gt;alt=&lt;/span&gt;&lt;span class="s"&gt;"Ben Greenman"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-9"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-4 pn-contact"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;span&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"pn-name"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Ben Greenman&lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        Advisor: Matthias Felleisen&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"mailto:types@"&lt;/span&gt;&lt;span class="err"&gt;@"&lt;/span&gt;&lt;span class="na"&gt;ccs&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;neu&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;edu&lt;/span&gt;&lt;span class="err"&gt;"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;types@"@"ccs.neu.edu&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://www.ccs.neu.edu/home/types"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;www.ccs.neu.edu/home/types&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-3 pn-muted col-md-offset-5"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        Joined 2014
      &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-12 pn-bio"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;I like constructions .... &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The new definition uses a helper function with keyword arguments for each  &amp;ldquo;field&amp;rdquo; of the person:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nv"&gt;@person&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kd"&gt;#:name&lt;/span&gt; &lt;span class="s"&gt;"Ben Greenman"&lt;/span&gt;
        &lt;span class="kd"&gt;#:title&lt;/span&gt; &lt;span class="s"&gt;"Advisor: Matthias Felleisen"&lt;/span&gt;
        &lt;span class="kd"&gt;#:e-mail&lt;/span&gt; &lt;span class="s"&gt;"types@ccs.neu.edu"&lt;/span&gt;
        &lt;span class="kd"&gt;#:website&lt;/span&gt; &lt;span class="s"&gt;"http://ccs.neu.edu/home/types"&lt;/span&gt;
        &lt;span class="kd"&gt;#:history&lt;/span&gt; &lt;span class="nv"&gt;@list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Joined 2014"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="kd"&gt;#:img&lt;/span&gt; &lt;span class="s"&gt;"ben_greenman.jpg"&lt;/span&gt;&lt;span class="p"&gt;]{&lt;/span&gt;
  &lt;span class="nv"&gt;I&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;constructions&lt;/span&gt; &lt;span class="o"&gt;....&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;h4 id="3-less-string-formatting"&gt;3. Less String-Formatting&lt;/h4&gt;

&lt;p&gt;Before, the code did a lot of string formatting (&lt;a href="https://github.com/nuprl/website/commit/a0600d#diff-1921e33ce89be28dd277cf1c7880d1beL9"&gt;link&lt;/a&gt;):&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&lt;a href="http://docs.racket-lang.org/reference/creatingunits.html#(form._((lib._racket/unit..rkt)._link))" style="color: inherit"&gt;link&lt;/a&gt;&lt;/span&gt; &lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/strings.html#(def._((quote._~23~25kernel)._string-append))" style="color: inherit"&gt;string-append&lt;/a&gt; &lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;a href=\""&lt;/span&gt; &lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="s"&gt;"\"&amp;gt;"&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;/a&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The new code has no need for such helper functions.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nv"&gt;@a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;href:&lt;/span&gt; &lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;h4 id="bottom-line"&gt;Bottom Line&lt;/h4&gt;

&lt;p&gt;Scribble is a good language for making static HTML pages.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;If you liked this post, you may also be interested in:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://docs.racket-lang.org/pollen/index.html"&gt;Pollen&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://github.com/vishesh/racketscript"&gt;RacketScript&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;Other websites built using &lt;a href="http://docs.racket-lang.org/scribble-pp/html.html"&gt;&lt;code&gt;scribble/html&lt;/code&gt;&lt;/a&gt;:  (1) &lt;a href="http://nanopass.org/"&gt;nanopass.github.io&lt;/a&gt; (&lt;a href="https://github.com/nanopass/nanopass.github.io"&gt;source code&lt;/a&gt;),  (2) &lt;a href="http://prl.ccs.neu.edu/gtp/"&gt;Gradual Typing Across the Spectrum&lt;/a&gt; (&lt;a href="https://github.com/nuprl/gtp"&gt;source code&lt;/a&gt;).&lt;/li&gt;
 &lt;li&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2016/05/18/gradual-typing-across-the-spectrum/"&gt;Notes from a Gradual Typing Across the Spectrum PI meeting&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Artifacts for Semantics</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/15/artifacts-for-semantics?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-15-artifacts-for-semantics</guid>
   <pubDate>Mon, 15 May 2017 10:08:31 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;&lt;a href="http://gallium.inria.fr/~scherer/"&gt;Gabriel Scherer&lt;/a&gt; and I recently wrote an &lt;a href="https://dbp.io/artifacts/funtal"&gt;artifact&lt;/a&gt; for a semantics &lt;a href="https://dbp.io/pubs/2017/funtal.pdf"&gt;paper&lt;/a&gt; on a typed assembly language interoperating with a high-level functional language.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;We wrote a interpreter, typechecker, and parser in OCaml, compiled it to Javascript using &lt;a href="http://ocsigen.org/js_of_ocaml/"&gt;js_of_ocaml&lt;/a&gt;, and then put it on a webpage (with an editor with syntax highlighting and error reporting) that allows people to step through examples from the paper or write their own. (Feel free to start by playing a bit with &lt;a href="https://dbp.io/artifacts/funtal"&gt;our artifact&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;This post will summarize the different parts to make it easier for others to repeat this process. We think it was a total success, and have gotten feedback that it makes understanding the (somewhat complex) language from the paper much easier. We argue that building such interpreters / typecheckers is easy enough that all papers should do this. Further, while our interpreter / typechecker is completely unverified, since we wrote it in OCaml, this approach should work equally well for semantics verified in Coq and then extracted to OCaml.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The paper in question, &lt;a href="https://dbp.io/pubs/2017/funtal.pdf"&gt;FunTAL: Reasonably Mixing a Functional Language with Assembly&lt;/a&gt; (to appear in PLDI17), presents a multi-language that incorporates a typed assembly language (TAL) and a simple functional language where each can be embedded within the other. The paper then develops a logical relation that can be used to reason about the equivalence of such mixed programs. For example in the paper we show an imperative register-based factorial and a functional factorial equivalent.&lt;/p&gt;

&lt;p&gt;Both the static and dynamic semantics are relatively complex. The typed assembly has registers (which store word-sized values), a heap (which stores code-blocks and tuples), and a stack (not a call-stack, simply a place where word-sized values can be pushed and popped). Code-blocks have pre-conditions on the state of the registers and the stack, and allow the tail of the stack to be abstracted over polymorphically. This allows values to be protected on the stack before jumping to blocks that otherwise could change them. This is used, along with a novel notion of &lt;strong&gt;return markers&lt;/strong&gt;, to ensure well-bracketing in the control flow of the typed assembly. The return markers indicate the location that points to the block that will eventually be returned to (assuming it doesn&amp;rsquo;t loop infinitely). At the top level, the return marker &lt;code&gt;end&lt;/code&gt; indicates that, assuming it does not loop, eventually the program will stop, rather than returning somewhere else.&lt;/p&gt;

&lt;p&gt;Understanding the dynamic semantics requires tracking how values flow through the registers, the heap, and the stack, and rather than a call-stack, the user has to track the control flow through the statically-enforced return markers. This allows a good deal of low-level control-flow while still ensuring that calls will eventually return to the right place. This well-bracketing is vital to be able to reason about &amp;ldquo;components&amp;rdquo; that eventually return a value of a particular type, a necessity when embedding these components in a typed high-level program! However, it does mean that understanding the static and dynamic semantics from a few rules alone is a tall order. Our functional language is more standard, though we use (iso)-recursive types to allow recursion, which can easily trip up people, especially when you don&amp;rsquo;t have a type-checker to catch typos!&lt;/p&gt;

&lt;p&gt;For that reason, when working through examples for the paper I implemented a simple interpreter for the multi-language. I did this in OCaml, in the most straightforward way possible: by translating the definitions from the paper into type definitions (&lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/ftal.ml#L835"&gt;for F&lt;/a&gt; and &lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/ftal.ml#L1209"&gt;for TAL&lt;/a&gt;), and the reduction relation into a &lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/ftal.ml#L1155"&gt;&amp;ldquo;step&amp;rdquo; function&lt;/a&gt; that (assuming it wasn&amp;rsquo;t stuck or a value), did one step of evaluation. Later, I did the same thing for the type-checker, translating rules into a &lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/ftal.ml#L282"&gt;type-checking function&lt;/a&gt;. The latter had to deviate from the rules in the paper in a few minor ways, as the typing rules we had in the paper were slightly not syntax directed.&lt;/p&gt;

&lt;p&gt;Having the interpreter and type-checker was very useful for me, as I could check that the examples from the paper did not contain typos, but it was much less useful as an artifact for a reader of the paper. To use it the reader would have to download the source, install OCaml, write out examples as OCaml data constructors in a test file, compile it, run it, and then interpret the (quite overwhelming) output of every step of evaluation. At each step, I printed the current registers, current stack, current heap, what the evaluation context was (as you might be evaluating TAL instructions that were embedded inside a functional program that, in turn, was embedded in further TAL instructions), and what the current reduction was.&lt;/p&gt;

&lt;p&gt;To get from that useful-for-the-authors artifact to a useful-to-readers artifact requires doing three things:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Allow reading/writing programs in a notation as close to the paper as  possible. In our paper we use superscripts, subscripts, and a few greek  letters, but ended up with a syntax otherwise very close to the paper &amp;mdash; the biggest  differences were a few extra delimiters introduced to reduce ambiguity.&lt;/li&gt;
 &lt;li&gt;Present an interface that highlights type errors at the location they  occurred in, and allow a reader to step forward and backwards through the  evaluation. Printing console output traces is fine for authors, but adds too  much effort for readers.&lt;/li&gt;
 &lt;li&gt;Put it online! Don&amp;rsquo;t require installing any software! Conveniently,  implementing 2 is also made easier once done online, as we could use existing  editor tooling to present the code, highlight errors, etc. By using OCaml, we  were able to easily use the  excellent &lt;a href="http://ocsigen.org/js_of_ocaml/"&gt;js_of_ocaml&lt;/a&gt;.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The first was done by Gabriel, who wrote a grammar using &lt;a href="http://gallium.inria.fr/~fpottier/menhir/"&gt;Menhir&lt;/a&gt;, and then equipped it with custom parsing error messages that provide much better feedback when there are typos in what people are trying. We also wrote a pretty-printer using the &lt;a href="http://gallium.inria.fr/blog/first-release-of-pprint/"&gt;PPrint&lt;/a&gt; library, so we could show intermediate program states through the UI. After writing this, we were able to convert our existing suite of test cases and examples to be written textually, which was a huge improvement for us as well! These and other tests were used to ensure that the parser/pretty-printer would round-trip properly.&lt;/p&gt;

&lt;p&gt;For the interface, I built a simple web page that had the &lt;a href="https://codemirror.net/"&gt;CodeMirror&lt;/a&gt; editor equipped with a very simple syntax highlighter (&lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/artifact/index.html#L247"&gt;8 lines of code&lt;/a&gt; to highlight keywords &amp;amp; atoms, plus a CodeMirror extension to highlight matching brackets) and error highlighting (which is triggered by the OCaml code). I then made a simple &amp;ldquo;machine state&amp;rdquo; UI that showed, in pretty-printed format, the heap, stack, registers, context, and redex. On the OCaml side, when the &amp;ldquo;run&amp;rdquo; button is clicked, we parse and typecheck and, assuming no errors occur, store the current state as our &amp;ldquo;history&amp;rdquo;. As the user clicks forward or backwards, we run the step function and append to the history of states or pop states off of the history. In total, there are &lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/artifact/index.html#L246"&gt;50 lines of Javascript&lt;/a&gt; and about &lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/web.ml"&gt;150 lines of OCaml&lt;/a&gt; that handle the logic for this interactive UI.&lt;/p&gt;

&lt;p&gt;Putting it online was very easy, based on the choice of tools used earlier. We compile the main file (&lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/web.ml"&gt;web.ml&lt;/a&gt;) to Javascript using &lt;a href="http://ocsigen.org/js_of_ocaml/"&gt;js_of_ocaml&lt;/a&gt;, and it pulls in the parser, type-checker, interpreter, examples, etc. The rest of the artifact is a single html file, a CSS file, and a few javascript files for CodeMirror. It requires no server backend, is easy to archive and save, and will even run on smartphones!&lt;/p&gt;

&lt;p&gt;The total time spent implementing the artifact was a small fraction of the time spent on the paper (probably 15 days of person-time), and while it was not in any critical way essential for the success of the paper, it does make the paper much easier to read, and we would argue that all semantics papers would be better off with easy to use artifacts for experimentation. Also, while implementing the artifact we found a few mistakes in the typing judgments for the language. The most interesting one was for our &lt;code&gt;protect&lt;/code&gt; TAL instruction, which exists to protect the tail of the stack in a fresh type variable. We had written this as a typing rule that type-checked the rest of the instruction sequence with the abstracted tail, but this never allowed the tail to be accessed again. By translating the typing judgments exactly into code, we realized that there was a problem, because examples that should have worked did not type-check! We were then able to fix the typing rule to conform to what we originally thought it achieved &amp;mdash; locally abstracting, but not abstracting from outside the component. What is interesting is that this did not come up in our proofs because the typing rule was perfectly valid &amp;mdash; it just did not allow non-trivial programs that used the &lt;code&gt;protect&lt;/code&gt; instruction. It&amp;rsquo;s quite possible we would have noticed this without implementing the artifact, but the artifact certainly made it easier!&lt;/p&gt;

&lt;p&gt;To see the artifact online, visit:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://dbp.io/artifacts/funtal"&gt;https://dbp.io/artifacts/funtal&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The source code is at:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/dbp/funtal/tree/032be70f33f77e80f4fab7e62016bfabf96476f3"&gt;https://github.com/dbp/funtal&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>