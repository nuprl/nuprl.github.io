<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">PRL Blog: Posts tagged 'typed racket'</title>
 <link rel="self" href="http://prl.ccs.neu.edu/blog/feeds/typed-racket.atom.xml" />
 <link href="http://prl.ccs.neu.edu/blog/tags/typed-racket.html" />
 <id>urn:http-prl-ccs-neu-edu:-blog-tags-typed-racket-html</id>
 <updated>2020-01-15T12:16:35Z</updated>
 <entry>
  <title type="text">The Typed Racket Optimizer vs. Transient</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2020/01/15/the-typed-racket-optimizer-vs-transient/?utm_source=typed-racket&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2020-01-15-the-typed-racket-optimizer-vs-transient</id>
  <published>2020-01-15T12:16:35Z</published>
  <updated>2020-01-15T12:16:35Z</updated>
  <author>
   <name>PRL</name></author>
  <content type="html">
&lt;p&gt;What type-directed optimizations does Typed Racket perform  and do any require full types?&lt;/p&gt;
&lt;!-- more--&gt;

&lt;blockquote&gt;
 &lt;p&gt;This post is based on a short talk. Slides from the talk are here: &lt;a href="http://ccs.neu.edu/home/types/resources/talks/prl-offsite-2019.pdf"&gt;http://ccs.neu.edu/home/types/resources/talks/prl-offsite-2019.pdf&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Standard Typed Racket guarantees full type soundness and uses higher-order  contracts to make sure that interactions between Typed Racket and untyped  Racket obey the types. These contracts can be very expensive [&lt;a href="https://doi.org/10.1017/S0956796818000217"&gt;JFP 2019&lt;/a&gt;]. And so, the standard types are very strong but (possibly) slow.&lt;/p&gt;

&lt;p&gt;Lately, I&amp;rsquo;ve been working on a &lt;a href="https://dl.acm.org/citation.cfm?id=3009849"&gt;transient&lt;/a&gt;  back-end for Typed Racket. Transient Typed Racket provides a weaker guarantee &amp;mdash; only that typed code  cannot get &amp;ldquo;stuck&amp;rdquo; &amp;mdash; via simpler run-time checks. Early data shows that these simple checks are often faster   than the standard boundary checks [&lt;a href="https://doi.org/10.1145/3236766"&gt;ICFP 2018&lt;/a&gt;],  hence we want both options for Typed Racket programmers: slow/correct  and fast/wrong.&lt;/p&gt;

&lt;p&gt;The implementation of Transient needs to re-use some parts of Standard Typed  Racket and modify others. Typed Racket comes with three major components:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;a static type checker,&lt;/li&gt;
 &lt;li&gt;a compiler from types to contracts, and&lt;/li&gt;
 &lt;li&gt;a type-driven optimizer [&lt;a href="https://www2.ccs.neu.edu/racket/pubs/padl12-stff.pdf"&gt;PADL 2012&lt;/a&gt;, &lt;a href="https://doi.org/10.1145/2384616.2384629"&gt;OOPSLA 2012&lt;/a&gt;].&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Transient Typed Racket can re-use all of the type checker  and parts of the type-to-contract compiler. The question for this post is: can Transient re-use the optimizer?&lt;/p&gt;

&lt;h2 id="q-can-transient-re-use-the-typed-racket-optimizer"&gt;Q. Can Transient re-use the Typed Racket optimizer?&lt;/h2&gt;

&lt;p&gt;The answer requires some thought because Standard Typed Racket and Transient  Typed Racket preserve different amounts of type information.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;In Standard Typed Racket, if an expression &lt;strong&gt;e&lt;/strong&gt; has type &lt;strong&gt;T&lt;/strong&gt; and reduces  to a value &lt;strong&gt;v&lt;/strong&gt; (for short, &lt;strong&gt;e : T &amp;mdash;&amp;gt;* v&lt;/strong&gt;), then the result &lt;strong&gt;v&lt;/strong&gt; definitely  matches the full type &lt;strong&gt;T&lt;/strong&gt;.&lt;/li&gt;
 &lt;li&gt;In Transient Typed Racket, if &lt;strong&gt;e : T &amp;mdash;&amp;gt;* v&lt;/strong&gt; then the result &lt;strong&gt;v&lt;/strong&gt; matches  the toplevel &amp;ldquo;shape&amp;rdquo; of &lt;strong&gt;T&lt;/strong&gt; but (maybe) nothing more.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The idea of a &amp;ldquo;shape&amp;rdquo; is that it corresponds to the outermost constructor of  a type. A shape check must be decidable, but otherwise finding the best shape for a type  is an engineering challenge. On one hand, deeper checks give stronger guarantees. On the other hand, shallower checks are quicker to validate.&lt;/p&gt;

&lt;p&gt;Here are a few shapes according to the current Transient prototype:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Shape(Natural)                = Natural
  Shape(Listof String)          = Listof Any
  Shape(Symbol -&amp;gt; Boolean)      = Any -&amp;gt; Any
  Shape(Vector Void Void)       = Vector Any Any
  Shape(U Void (Listof Symbol)) = U Void (Listof Any)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the current shapes, can we re-use the Typed Racket optimizer?&lt;/p&gt;

&lt;h2 id="optimization-topics"&gt;Optimization Topics&lt;/h2&gt;

&lt;p&gt;Typed Racket implements 15 kinds of type-directed transformation. Below, each gets: a short description, an example, and a verdict of &amp;ldquo;safe&amp;rdquo;  or &amp;ldquo;unsafe&amp;rdquo; for Transient.&lt;/p&gt;

&lt;p&gt;To be clear: some optimization topics perform many kinds of transformations, but this post picks only one example transformation for each.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-1-apply"&gt;Topic 1: apply&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/apply.rkt"&gt;apply.rkt&lt;/a&gt;  &amp;ldquo;inlines&amp;rdquo; expressions of the form &lt;code&gt;(apply f (map g xs))&lt;/code&gt; to map and fold  in one pass over the list (&lt;code&gt;xs&lt;/code&gt;). Currently, the pass only triggers when &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: xs (Listof Integer))

  ;; --------------------------------------------------
  ;; Before Optimization
  (apply + (map abs xs))

  ;; --------------------------------------------------
  ;; After Optimization
  (let loop ((v 0)
             (lst xs))
    (if (null? lst)
      v
      (loop (+ v (abs (unsafe-car lst)))
            (unsafe-cdr lst))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, but risky.&lt;/p&gt;

&lt;p&gt;Technically, this transformation is unsound for Transient because of how it uses &lt;code&gt;unsafe-car&lt;/code&gt;. The expansion of &lt;code&gt;(apply * (map g xs))&lt;/code&gt; applies &lt;code&gt;(g (unsafe-car xs))&lt;/code&gt; without  confirming that the first element of &lt;code&gt;xs&lt;/code&gt; matches its expected type. This unsoundness is no problem, though, as long as &lt;em&gt;every&lt;/em&gt; Transient-typed function  checks the shape of its input. (Typed functions that flow to untyped code already need to check inputs.)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-2-box"&gt;Topic 2: box&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/box.rkt"&gt;box.rkt&lt;/a&gt;  safely applies unsafe box operations to expressions with &lt;code&gt;Box&lt;/code&gt; type.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: b (Boxof Symbol))

  ;; --------------------------------------------------
  ;; Before Optimization
  (unbox b)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-unbox b)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-3-dead-code"&gt;Topic 3: dead-code&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/dead-code.rkt"&gt;dead-code.rkt&lt;/a&gt;  uses type information to identify code that cannot run. Once identified, the TR optimizer makes the dead code obvious for the Racket  bytecode compiler. The pass deals with &lt;code&gt;if&lt;/code&gt; expressions, &lt;code&gt;lambda&lt;/code&gt; expressions, and &lt;code&gt;case-lambda&lt;/code&gt;;  the latter is the most interesting for Transient.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: f (-&amp;gt; Symbol Symbol)

  ;; --------------------------------------------------
  ;; Before Optimization
  (define f
    (case-lambda
      ((s) s)
      ((s i)
       (for/list ((_i (in-range i))) s))))

  ;; --------------------------------------------------
  ;; After Optimization
  (define f
    (case-lambda
      ((s) s)
      ((s i)
       ; dead code, replace with no-op
       (void))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: unsafe, can change behavior&lt;/p&gt;

&lt;p&gt;The pass infers that some branches of a &lt;code&gt;case-lambda&lt;/code&gt; can never run because  the type says they do not exist. In Standard Typed Racket, this inference is correct because a run-time contract  seals off the &amp;ldquo;untyped&amp;rdquo; branches. In Transient, though, there is no need to add a contract and therefore no  guarantee these branches are inaccessible. An application in untyped code can enter the dead branch;  if it does, then adding Transient types to part of a program can change  its result to &lt;code&gt;(void)&lt;/code&gt; and thereby violate the graduality design goal [&lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;SNAPL 2015&lt;/a&gt;, &lt;a href="https://doi.org/10.1145/3236768"&gt;ICFP 2018&lt;/a&gt;]  &amp;mdash; that is, that adding types should only change behavior by introducing runtime  type mismatches.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-4-extflonum"&gt;Topic 4: extflonum&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/extflonum.rkt"&gt;extflonum.rkt&lt;/a&gt;  safely applies unsafe extflonum operations to expressions with &lt;code&gt;Extflonum&lt;/code&gt; type.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: e Extflonum)

  ;; --------------------------------------------------
  ;; Before Optimization
  (extflabs e)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-extflabs e)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-5-fixnum"&gt;Topic 5: fixnum&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/fixnum.rkt"&gt;fixnum.rkt&lt;/a&gt;  safely applies unsafe fixnum operations to expressions with &lt;code&gt;Fixnum&lt;/code&gt; type.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: f Fixnum)

  ;; --------------------------------------------------
  ;; Before Optimization
  (exact-&amp;gt;inexact f)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-fx-&amp;gt;fl f)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-6-float-complex"&gt;Topic 6: float-complex&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/float-complex.rkt"&gt;float-complex.rkt&lt;/a&gt;  unboxes complex numbers (into one real-part variable and one imaginary-part variable)  and rewrites operations to handle the unboxed numbers.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: f (-&amp;gt; Float-Complex Float-Complex Float-Complex))

  ;; --------------------------------------------------
  ;; Before Optimization
  (define (f n0 n1)
    (+ n0 n1))

  ;; --------------------------------------------------
  ;; After Optimization
  (define (f n0 n1)
    (let* ((unboxed-real-0 (unsafe-flreal-part n0))
           (unboxed-imag-0 (unsafe-flimag-part n0))
           (unboxed-real-1 (unsafe-flreal-part n1))
           (unboxed-imag-1 (unsafe-flimag-part n1))
           (unboxed-real-2 (unsafe-fl+ (real-&amp;gt;double-flonum unboxed-real-0)
                                       unboxed-real-1))
           (unboxed-imag-2 (unsafe-fl+ (real-&amp;gt;double-flonum unboxed-imag-0)
                                       unboxed-imag-1)))
      (unsafe-make-flrectangular unboxed-real-2 unboxed-imag-2)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, with caution&lt;/p&gt;

&lt;p&gt;The body of a Transient-typed function (that can flow to untyped code)  must first check that its inputs have the correct shape. Currently, the &lt;strong&gt;float-complex&lt;/strong&gt; pass creates functions that apply &lt;code&gt;unsafe-flreal-part&lt;/code&gt; before  anything else; to be safe, the pass needs to make sure that Transient checks  come first.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-7-float"&gt;Topic 7: float&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/float.rkt"&gt;float.rkt&lt;/a&gt;  safely applies unsafe flonum operations to expressions with &lt;code&gt;Flonum&lt;/code&gt; type  and also transforms some &lt;code&gt;random&lt;/code&gt; calls to use &lt;code&gt;unsafe-flrandom&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; --------------------------------------------------
  ;; Before Optimization
  (random)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-flrandom (current-pseudo-random-generator))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, but a close call&lt;/p&gt;

&lt;p&gt;Accessing a parameter, as in &lt;code&gt;(current-pseudo-random-generator)&lt;/code&gt;, is an  elimination form that may require a shape check. This particular parameter, however, is protected by a contract that enforces  the precondition of &lt;code&gt;unsafe-flrandom&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-8-list"&gt;Topic 8: list&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/list.rkt"&gt;list.rkt&lt;/a&gt;  safely applies unsafe list operations to list expressions.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: lst (List Symbol Symbol))

  ;; --------------------------------------------------
  ;; Before Optimization
  (list-ref lst 0)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-list-ref lst 0)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, with strong-enough shape checks&lt;/p&gt;

&lt;p&gt;The shape check for a &lt;code&gt;(Listof T)&lt;/code&gt; must check for proper lists (via &lt;code&gt;list?&lt;/code&gt;);  note that the cost of this check depends on the size of incoming values. The shape check for a &lt;code&gt;(List T ...)&lt;/code&gt; type must validate the length of incoming  values.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-9-number"&gt;Topic 9: number&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/number.rkt"&gt;number.rkt&lt;/a&gt;  performs simple transformations on &lt;code&gt;Real&lt;/code&gt;-valued expressions.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: r Real)

  ;; --------------------------------------------------
  ;; Before Optimization
  (+ r)

  ;; --------------------------------------------------
  ;; After Optimization
  r&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-10-pair"&gt;Topic 10: pair&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/pair.rkt"&gt;pair.rkt&lt;/a&gt;  safely applies pair-access operations to (possibly-nested) pairs.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: p (Pairof (Pairof Symbol Void) String))

  ;; --------------------------------------------------
  ;; Before Optimization
  (cdar p)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-cdr (unsafe-car p))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: unsafe&lt;/p&gt;

&lt;p&gt;Transient guarantees the first level of a type, but nothing more. Concretely, &lt;code&gt;Shape(Pairof (Pairof Symbol Void) String) = Pairof Any Any&lt;/code&gt;  and so the &lt;code&gt;unsafe-cdr&lt;/code&gt; above is not safe.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-11-sequence"&gt;Topic 11: sequence&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/sequence.rkt"&gt;sequence.rkt&lt;/a&gt;  safely applies unsafe sequence operations to expressions with &lt;code&gt;(Sequenceof T)&lt;/code&gt; type.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: s String)

  ;; --------------------------------------------------
  ;; Before Optimization
  (for ((c s))
    (void))

  ;; --------------------------------------------------
  ;; After Optimization (simplified)
  (for ((c (in-string s)))
    (void))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, with strong enough shape checks (see &lt;strong&gt;list&lt;/strong&gt; and &lt;strong&gt;vector&lt;/strong&gt;)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-12-string"&gt;Topic 12: string&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/string.rkt"&gt;string.rkt&lt;/a&gt;  safely applies unsafe string operations to expressions with &lt;code&gt;String&lt;/code&gt; type. (Note that &lt;code&gt;unsafe-string-ref&lt;/code&gt; is only safe when the result is sure to be  a Latin&amp;ndash;1 character.)&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: b Bytes)

  ;; --------------------------------------------------
  ;; Before Optimization
  (bytes-length b)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-bytes-length b)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-13-struct"&gt;Topic 13: struct&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/struct.rkt"&gt;struct.rkt&lt;/a&gt;  safely applies unsafe struct operations to struct expressions, using  Typed Racket&amp;rsquo;s &lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/types/struct-table.rkt"&gt;internal registry of struct info&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (struct open-interval ([lo : Real] [hi : Real]))
  (: ivl open-interval)

  ;; --------------------------------------------------
  ;; Before Optimization
  (open-interval-lo ivl)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-struct-ref ivl 0)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-14-unboxed-let"&gt;Topic 14: unboxed-let&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/unboxed-let.rkt"&gt;unboxed-let.rkt&lt;/a&gt;  cooperates with the &lt;code&gt;float-complex&lt;/code&gt; pass by transforming the binding-site  of some complex numbers. This pass may change a &lt;code&gt;let&lt;/code&gt;-expression into a &lt;code&gt;let-values&lt;/code&gt; that expects  a real-part and imag-part, and may change a function to expect twice as many  arguments &amp;mdash; provided the optimizer can find &lt;em&gt;all&lt;/em&gt; calls to the function.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: k Float-Complex)

  ;; --------------------------------------------------
  ;; Before Optimization
  (let ((f (lambda ((n : Float-Complex)) (+ n n))))
    (f k))

  ;; --------------------------------------------------
  ;; After Optimization
  (let ((f (lambda (real-part-n imag-part-n) ....)))
    (f (unsafe-flreal-part k) (unsafe-flimag-part k)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, thanks to the (conservative) escape analysis&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-15-vector"&gt;Topic 15: vector&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/vector.rkt"&gt;vector.rkt&lt;/a&gt;  safely applies vector operations to vector expressions.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: v (Vector (Listof Symbol) String))
  (: lst (Listof Symbol))

  ;; --------------------------------------------------
  ;; Before Optimization
  (vector-set! v lst 0)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-vector-set! v lst 0)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, with strong-enough shape checks&lt;/p&gt;

&lt;p&gt;The check for &lt;code&gt;(Vector T ...)&lt;/code&gt; must check the length of incoming values.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;

&lt;p&gt;The Typed Racket optimizer implements 15 kinds of transformations. Two are definitely unsafe for Transient as-is (&lt;strong&gt;dead-code&lt;/strong&gt;, &lt;strong&gt;pair&lt;/strong&gt;). One must take care when rewriting a Transient function (&lt;strong&gt;float-complex&lt;/strong&gt;). One may limit our ability to reduce the number of run-time checks in a program (&lt;strong&gt;apply&lt;/strong&gt;). Two others require transient checks whose cost depends on the size of the input values (&lt;strong&gt;list&lt;/strong&gt;, &lt;strong&gt;sequence&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;There may be other issues that I missed while reading the optimizer code. If so, I&amp;rsquo;ll try to remember to update this post.&lt;/p&gt;</content></entry></feed>